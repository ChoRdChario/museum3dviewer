<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>LociMyu</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#121821; --panel2:#141b24; --text:#e7eef7; --muted:#9cb0c7; --acc:#3aa0ff;
    --btn:#1b2430; --line:#213040;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Helvetica,Arial;}
  #app{display:grid;grid-template-columns:280px 1fr 380px;grid-template-rows:auto 1fr;grid-template-areas:
    "top top top"
    "left view right";
    height:100%;
  }
  header{grid-area:top;display:flex;gap:8px;align-items:center;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--line);}
  header .spacer{flex:1;}
  header button, .btn{background:var(--btn);color:var(--text);border:1px solid var(--line);border-radius:8px;padding:8px 12px;cursor:pointer}
  header button[disabled]{opacity:.5;cursor:not-allowed}
  aside#left{grid-area:left;background:var(--panel2);border-right:1px solid var(--line);overflow:auto}
  main#view{grid-area:view;position:relative;overflow:hidden;background:#000;}
  aside#right{grid-area:right;background:var(--panel2);border-left:1px solid var(--line);overflow:auto}
  section.block{padding:12px;border-bottom:1px solid var(--line)}
  h3{margin:.2rem 0 .6rem;font-size:14px;color:var(--muted)}
  label.row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:.4rem 0}
  input[type="range"]{width:160px}
  input[type="checkbox"]{transform:scale(1.2)}
  select, input[type="text"], input[type="number"], input[type="color"]{background:#0f151e;border:1px solid var(--line);color:var(--text);border-radius:6px;padding:6px 8px}
  #canvas{position:absolute;inset:0}
  #loading{position:absolute;inset:0;display:grid;place-items:center;background:#0008;backdrop-filter:saturate(120%) blur(2px);z-index:10}
  #loading.hidden{display:none}
  .ring{width:60px;height:60px;border:6px solid #ffffff25;border-top-color:var(--acc);border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  .caption{border:1px solid var(--line);background:#0f141c;border-radius:10px;padding:10px;margin:10px}
  .caption .thumb{width:100%;max-height:220px;object-fit:contain;background:#000}
  .caption .thumbWrap{position:relative}
  .caption .fallback{position:absolute;right:8px;top:8px;background:#0008;padding:2px 6px;border-radius:6px;font-size:12px}
  .row-2{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .muted{color:var(--muted);font-size:12px}
  .error{color:#ff8080}
  .ok{color:#76e29b}
  .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);background:#0f151e;border-radius:999px;padding:4px 10px}
  .kvs{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre-wrap;background:#0b1118;border:1px solid #152333;border-radius:8px;padding:8px}
</style>
</head>
<body>
<div id="app">
  <header>
    <strong>LociMyu</strong>
    <span class="spacer"></span>
    <button id="btnSignIn">Google サインイン</button>
    <button id="btnLoadGLB" disabled>GLB を読み込む</button>
    <button id="btnLoadSheet" disabled>キャプションシートを選択</button>
    <span id="authStat" class="pill muted">未サインイン</span>
  </header>

  <aside id="left">
    <section class="block">
      <h3>ビュー</h3>
      <label class="row"><span>平行投影</span><input id="projOrtho" type="checkbox" /></label>
      <label class="row"><span>背景色</span><input id="bgColor" type="color" value="#101418"/></label>
      <div class="row" style="gap:6px;margin-top:8px">
        <button class="btn" id="camFront">前</button>
        <button class="btn" id="camBack">後</button>
        <button class="btn" id="camLeft">左</button>
        <button class="btn" id="camRight">右</button>
        <button class="btn" id="camTop">上</button>
        <button class="btn" id="camBottom">下</button>
      </div>
    </section>
    <section class="block">
      <h3>マテリアル</h3>
      <label class="row"><span>選択</span>
        <select id="matSelect"></select>
      </label>
      <label class="row"><span>Unlit</span><input id="matUnlit" type="checkbox" /></label>
      <label class="row"><span>裏面描画</span><input id="matDoubleSided" type="checkbox" /></label>
      <label class="row"><span>不透明度</span><input id="matOpacity" type="range" min="0" max="1" step="0.01" value="1"/></label>
      <label class="row"><span>白→透明</span><input id="matWhiteTransparent" type="checkbox" /></label>
      <label class="row"><span>黒→透明（反転）</span><input id="matInvert" type="checkbox" /></label>
      <label class="row"><span>閾値（αTest）</span><input id="matThreshold" type="range" min="0" max="1" step="0.01" value="0.0"/></label>
      <div class="muted">スライダーは即時反映・自動保存</div>
    </section>
    <section class="block">
      <h3>デバッグ</h3>
      <div id="dbg" class="kvs"></div>
    </section>
  </aside>

  <main id="view">
    <canvas id="canvas"></canvas>
    <div id="loading" class="hidden"><div class="ring"></div></div>
  </main>

  <aside id="right">
    <section class="block">
      <h3>キャプション</h3>
      <div id="capList"></div>
    </section>
  </aside>
</div>

<!-- three.js modules -->
<script type="module">
/* ===== Imports ===== */
import * as THREE from "https://unpkg.com/three@0.156.1/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.156.1/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "https://unpkg.com/three@0.156.1/examples/jsm/loaders/GLTFLoader.js";

/* ====== Globals / State ====== */
const el = {
  btnSignIn: document.getElementById('btnSignIn'),
  btnLoadGLB: document.getElementById('btnLoadGLB'),
  btnLoadSheet: document.getElementById('btnLoadSheet'),
  authStat: document.getElementById('authStat'),
  canvas: document.getElementById('canvas'),
  loading: document.getElementById('loading'),
  // mat UI
  matSelect: document.getElementById('matSelect'),
  matUnlit: document.getElementById('matUnlit'),
  matDoubleSided: document.getElementById('matDoubleSided'),
  matOpacity: document.getElementById('matOpacity'),
  matWhiteTransparent: document.getElementById('matWhiteTransparent'),
  matInvert: document.getElementById('matInvert'),
  matThreshold: document.getElementById('matThreshold'),
  // view
  projOrtho: document.getElementById('projOrtho'),
  bgColor: document.getElementById('bgColor'),
  // camera quick
  camFront: document.getElementById('camFront'),
  camBack: document.getElementById('camBack'),
  camLeft: document.getElementById('camLeft'),
  camRight: document.getElementById('camRight'),
  camTop: document.getElementById('camTop'),
  camBottom: document.getElementById('camBottom'),
  dbg: document.getElementById('dbg'),
};

let renderer, scene, camera, controls;
let currentModel=null;
let bbox = new THREE.Box3();
let center = new THREE.Vector3();
let size = new THREE.Vector3();

let isSignedIn = false;
let driveFolderId = null; // 任意：GLB と同階層の親フォルダを後で保持
let activeSheet = { sheetId:null, title:'pins' };

const materials = []; // シーン内の編集対象マテリアル
const materialKeyByMaterial = new Map(); // Mat -> key
const matState = new Map(); // key -> {unlit,doubleSided,opacity,whiteTransparent,blackTransparent,threshold}

function clamp01(v, def=1){ v = Number(v); return Number.isFinite(v)? Math.min(1, Math.max(0, v)) : def; }
function requestRender(){ if(renderer) renderer.setAnimationLoop(loop); }
function transientRender(){ if(renderer){ renderer.render(scene, camera); } }

/* ====== Renderer / Scene ====== */
initThree();

function initThree(){
  renderer = new THREE.WebGLRenderer({canvas: el.canvas, antialias:true, alpha:false, powerPreference:'high-performance'});
  resize();
  window.addEventListener('resize', resize);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(el.bgColor.value);

  camera = new THREE.PerspectiveCamera(50, getAspect(), 0.01, 2000);
  camera.position.set(0,1.2,2.2);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 1.0);
  hemi.position.set(0,1,0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(1,2,1);
  scene.add(dir);

  loop();
}
function getAspect(){ return el.view?.clientWidth / el.view?.clientHeight || (window.innerWidth/window.innerHeight); }
function resize(){
  const w = document.getElementById('view').clientWidth;
  const h = document.getElementById('view').clientHeight;
  renderer.setSize(w,h,false);
  if(camera && camera.isPerspectiveCamera){
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
}
function loop(){
  controls?.update?.();
  renderer.render(scene,camera);
}

/* ====== Auth (Google) minimal wiring ======
   ※ 既存の client_id / API key を流用。SDK ロードは下の非 module script で行う。
*/
let tokenClient, gapiInited=false, gisInited=false;
window.gapiLoaded = async ()=>{
  gapi.load('client', async ()=>{
    await gapi.client.init({
      apiKey: window.__API_KEY__,
      discoveryDocs: [
        "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
        "https://sheets.googleapis.com/$discovery/rest?version=v4"
      ]
    });
    gapiInited=true; maybeReady();
  });
};
window.gisLoaded = ()=>{
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: window.__CLIENT_ID__,
    scope: "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/spreadsheets",
    callback: (resp)=>{
      isSignedIn = !!resp.access_token;
      el.authStat.textContent = isSignedIn ? "サインイン済み" : "未サインイン";
      el.btnLoadGLB.disabled = !isSignedIn;
      el.btnLoadSheet.disabled = !isSignedIn;
    }
  });
  gisInited=true; maybeReady();
};
function maybeReady(){
  if(gapiInited && gisInited){
    el.btnSignIn.disabled = false;
  }
}
el.btnSignIn.addEventListener('click', ()=>{
  if(!tokenClient){ return; }
  tokenClient.requestAccessToken({prompt:'consent'});
});

/* ====== Drive picker (簡易) ====== */
el.btnLoadGLB.addEventListener('click', onClickLoadGLB);
el.btnLoadSheet.addEventListener('click', onClickLoadSheet);

async function onClickLoadGLB(){
  if(!isSignedIn) return;
  const q = "mimeType='model/gltf-binary'";
  const res = await gapi.client.drive.files.list({q, fields:"files(id,name,parents)"});
  const list = res.result.files||[];
  if(list.length===0){ alert("GLB が見つかりませんでした（Drive 全体の検索）。"); return; }
  // ひとまず最初を読み込む（本番は UI リストで選択）
  const f = list[0];
  driveFolderId = (f.parents && f.parents[0]) || null;
  await loadGLBByFileId(f.id, f.name);
}

async function loadGLBByFileId(fileId, name){
  showLoading(true);
  try{
    // WebContentLink 経由（dl=1）
    const meta = await gapi.client.drive.files.get({fileId, fields:"id,name,mimeType,webContentLink,parents"});
    const link = meta.result.webContentLink;
    const dl = link ? link.replace(/&export=download/,'').replace('view?usp=drivesdk','uc?export=download') : `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
    const url = dl.includes('uc?') ? dl : `${dl}&alt=media`;

    const loader = new GLTFLoader();
    const arrayBuffer = await (await fetch(url, {credentials:'omit'})).arrayBuffer();
    const gltf = await new Promise((resolve,reject)=>{
      loader.parse(arrayBuffer, '', resolve, reject);
    });

    if(currentModel){ scene.remove(currentModel); }
    currentModel = gltf.scene;
    scene.add(currentModel);

    // マテリアル収集
    materials.length = 0;
    materialKeyByMaterial.clear();

    currentModel.traverse(obj=>{
      if(obj.isMesh && obj.material){
        const mats = Array.isArray(obj.material)? obj.material : [obj.material];
        mats.forEach(m=>{
          if(!materials.includes(m)){
            materials.push(m);
            const key = genMaterialKey(m);
            materialKeyByMaterial.set(m, key);
            if(!matState.has(key)){
              matState.set(key, {unlit:false,doubleSided:false,opacity:1,whiteTransparent:false,blackTransparent:false,threshold:0.0});
            }
          }
        });
      }
    });

    rebuildMatSelect();
    fitToScene();

    // 背景色・投影の反映
    scene.background.set(el.bgColor.value);
    applyProjection();

    // メタ（背景・投影・各マテリアル）を読み込む（存在すれば）
    await ensureSpreadsheet(meta.result.parents?.[0]||null);
    await loadMetaFromSheet();

    // 投影再反映（読込後）
    applyProjection();

  }catch(e){
    console.error(e);
    alert("GLB 読み込みに失敗しました。");
  }finally{
    showLoading(false);
    requestRender();
  }
}

function fitToScene(){
  if(!currentModel) return;
  bbox.setFromObject(currentModel);
  bbox.getCenter(center);
  bbox.getSize(size);
  const maxDim = Math.max(size.x,size.y,size.z) || 1;
  const fitDist = maxDim * 1.8;

  controls.target.copy(center);
  if(camera.isPerspectiveCamera){
    const dir = new THREE.Vector3(0.8,0.6,0.8).normalize();
    camera.position.copy(center).addScaledVector(dir, fitDist);
  }else{
    camera.position.set(center.x+fitDist, center.y+fitDist, center.z+fitDist);
  }
  camera.updateProjectionMatrix();
  controls.update();
  transientRender();
}

/* ====== Camera Quick Buttons ====== */
el.camFront.onclick = ()=> setViewFrom('front');
el.camBack.onclick  = ()=> setViewFrom('back');
el.camLeft.onclick  = ()=> setViewFrom('left');
el.camRight.onclick = ()=> setViewFrom('right');
el.camTop.onclick   = ()=> setViewFrom('top');
el.camBottom.onclick= ()=> setViewFrom('bottom');

function setViewFrom(dir){
  if(!currentModel){return;}
  bbox.setFromObject(currentModel); bbox.getCenter(center); bbox.getSize(size);
  const d = Math.max(size.x,size.y,size.z) * 1.6;
  const v = new THREE.Vector3();
  switch(dir){
    case 'front':  v.set(0, 0, 1); break;
    case 'back':   v.set(0, 0,-1); break;
    case 'left':   v.set(-1,0, 0); break;
    case 'right':  v.set(1, 0, 0); break;
    case 'top':    v.set(0, 1, 0); break;
    case 'bottom': v.set(0,-1, 0); break;
  }
  camera.position.copy(center).addScaledVector(v, d);
  controls.target.copy(center);
  camera.updateProjectionMatrix();
  controls.update();
  transientRender();
}

/* ====== Projection & BG ====== */
el.projOrtho.onchange = ()=>{ applyProjection(); saveMetaToSheet(); };
el.bgColor.oninput    = ()=>{ if(scene) scene.background.set(el.bgColor.value); requestRender(); saveMetaToSheet(); };

function applyProjection(){
  const useOrtho = el.projOrtho.checked;
  const view = document.getElementById('view');
  const w = view.clientWidth, h=view.clientHeight, aspect = w/h;
  if(useOrtho && !camera.isOrthographicCamera){
    const frustum = 1.2;
    const ortho = new THREE.OrthographicCamera(-frustum*aspect, frustum*aspect, frustum, -frustum, 0.01, 5000);
    ortho.position.copy(camera.position);
    camera = ortho;
    controls.object = camera;
  }else if(!useOrtho && !camera.isPerspectiveCamera){
    const persp = new THREE.PerspectiveCamera(50, aspect, 0.01, 5000);
    persp.position.copy(camera.position);
    camera = persp;
    controls.object = camera;
  }
  camera.updateProjectionMatrix();
  controls.update();
  transientRender();
}

/* ====== Materials UI ====== */
function genMaterialKey(m){
  const base = (m.name && m.name.trim()) || (m.type||'Material');
  // 同名対策
  let idx=1; let key = base;
  while([...matState.keys()].includes(key)){ key = `${base}_${++idx}`; }
  return key;
}

function rebuildMatSelect(){
  el.matSelect.innerHTML = '';
  materials.forEach(m=>{
    const key = materialKeyByMaterial.get(m);
    const opt = document.createElement('option');
    opt.value = key; opt.textContent = key;
    el.matSelect.appendChild(opt);
  });
  if(materials.length){
    el.matSelect.value = materialKeyByMaterial.get(materials[0]);
    syncMatUIFromState(el.matSelect.value);
  }
}

function syncMatUIFromState(key){
  const s = matState.get(key);
  if(!s) return;
  el.matUnlit.checked           = !!s.unlit;
  el.matDoubleSided.checked     = !!s.doubleSided;
  el.matOpacity.value           = String(clamp01(s.opacity,1));
  el.matWhiteTransparent.checked= !!s.whiteTransparent;
  el.matInvert.checked          = !!s.blackTransparent;
  el.matThreshold.value         = String(clamp01(s.threshold,0));
  requestRender();
}

el.matSelect.onchange = ()=>{
  // 選択変更時：UI を現在の記録値へ
  const key = el.matSelect.value;
  syncMatUIFromState(key);
  // 選択マテリアルへ適用（UI 値→選択のみ）
  const mat = materials.find(m=>materialKeyByMaterial.get(m)===key);
  if(mat) applyMatUITo(mat);
  saveMetaToSheet();
};

['matUnlit','matDoubleSided','matWhiteTransparent','matInvert'].forEach(id=>{
  el[id].addEventListener('change', ()=>{
    const key = el.matSelect.value; const s = matState.get(key); if(!s) return;
    s.unlit = el.matUnlit.checked;
    s.doubleSided = el.matDoubleSided.checked;
    s.whiteTransparent = el.matWhiteTransparent.checked;
    s.blackTransparent = el.matInvert.checked;
    const mat = materials.find(m=>materialKeyByMaterial.get(m)===key);
    if(mat){ applyMatUITo(mat); }
    saveMetaToSheet();
  });
});
['matOpacity','matThreshold'].forEach(id=>{
  el[id].addEventListener('input', ()=>{
    const key = el.matSelect.value; const s = matState.get(key); if(!s) return;
    if(id==='matOpacity')   s.opacity   = clamp01(el.matOpacity.value,1);
    if(id==='matThreshold') s.threshold = clamp01(el.matThreshold.value,0);
    const mat = materials.find(m=>materialKeyByMaterial.get(m)===key);
    if(mat){ applyMatUITo(mat); }
    saveMetaToSheet();
  });
});

// ---------- Shader patch helpers ----------
function setOBC(material, fn){
  // 常に関数を保持（renderer 内で onBeforeCompile 未定義が参照されるケース回避）
  material.onBeforeCompile = (typeof fn==='function') ? fn : (shader)=>{};
}
function sanitizeAllMaterials(){
  materials.forEach(m=>{
    // MeshStandard 系以外にパッチが残っていたら解除
    if(!m.isMeshStandardMaterial && !m.isMeshPhysicalMaterial){
      setOBC(m, null);
    }
  });
}

/* ====== ★ 修正版 applyMatUITo（Unlit・白/黒→透明・透明度） ====== */
function applyMatUITo(material){
  if(!material) return;

  // Shader/RawShader は触らない（クラッシュ回避）
  if (material.isShaderMaterial || material.isRawShaderMaterial) {
    material.needsUpdate = true; sanitizeAllMaterials(); requestRender(); return;
  }

  // UI 値
  const unlit   = !!el.matUnlit.checked;
  const dbl     = !!el.matDoubleSided.checked;
  const opacity = clamp01(el.matOpacity.value, 1);
  const makeWhiteTransparent = !!el.matWhiteTransparent.checked;
  const makeBlackTransparent = !!el.matInvert.checked;
  const thr     = clamp01(el.matThreshold.value, 0); // 0..1

  // three 側のフラグ
  material.lights     = !unlit;
  material.toneMapped = !unlit;
  material.side       = dbl ? THREE.DoubleSide : THREE.FrontSide;

  // α を使う場合 true
  const needAlphaWork = (opacity < 1) || makeWhiteTransparent || makeBlackTransparent;

  // alphaTest は「カットアウト」用。ルマ変換と両立させるため、ここは最小値を小さく保つ
  material.alphaTest  = needAlphaWork ? Math.max(0.0001, thr) : 0.0;
  material.transparent = needAlphaWork;
  material.depthWrite  = !(needAlphaWork && opacity < 1); // 半透明時のソート破綻を緩和

  const cacheKey = JSON.stringify({U:+unlit,D:+dbl,O:+opacity.toFixed(2),WT:+makeWhiteTransparent,BT:+makeBlackTransparent,T:+thr.toFixed(3)});
  material.customProgramCacheKey = ()=> cacheKey;

  // パッチ不要（完全不透明・通常ライティング・白黒透明化なし）
  if(!unlit && !needAlphaWork){
    setOBC(material, null);
    material.needsUpdate = true; sanitizeAllMaterials(); requestRender(); 
    return;
  }

  // フラグメント修正
  setOBC(material, (shader)=>{
    try{
      let frag = shader.fragmentShader;

      // <common> 付近に uniform を宣言
      const headerNeedle = '#include <common>';
      const decls = `
uniform float uLMThreshold;   // 0..1
uniform float uLMOpacity;     // 0..1
uniform int   uLMWhiteToAlpha;
uniform int   uLMBlackToAlpha;
uniform int   uLMUnlit;
`;
      if (frag.includes(headerNeedle)) {
        frag = frag.replace(headerNeedle, `${headerNeedle}\n${decls}`);
      } else {
        frag = `${decls}\n${frag}`;
      }

      // 出力直前で α と発光/出力を上書き
      const injected = `
// ---- LociMyu Injection ----
float lm_luma = dot( diffuseColor.rgb, vec3(0.299, 0.587, 0.114) );
float lm_a = diffuseColor.a * uLMOpacity;

// 白→透明（明るい部分を抜く）
if(uLMWhiteToAlpha==1){
  // thr 以上のところを滑らかに削る
  lm_a *= 1.0 - smoothstep(uLMThreshold, 1.0, lm_luma);
}

// 黒→透明（暗い部分を抜く）
if(uLMBlackToAlpha==1){
  lm_a *= smoothstep(uLMThreshold, 1.0, lm_luma);
}

diffuseColor.a = lm_a;

// Unlit: ライティング無効化（標準マテリアルの最終合成をバイパス）
if(uLMUnlit==1){
  vec3 outgoingLight = diffuseColor.rgb;
}
// ---- LociMyu Injection End ----
`;

      // #include <output_fragment> の直前に注入（なければ末尾）
      const footer = '#include <output_fragment>';
      if (frag.includes(footer)) {
        frag = frag.replace(footer, `${injected}\n${footer}`);
      } else {
        frag = `${frag}\n${injected}\n`;
      }

      shader.fragmentShader = frag;
      shader.uniforms.uLMThreshold     = { value: thr };
      shader.uniforms.uLMOpacity       = { value: opacity };
      shader.uniforms.uLMWhiteToAlpha  = { value: makeWhiteTransparent ? 1 : 0 };
      shader.uniforms.uLMBlackToAlpha  = { value: makeBlackTransparent ? 1 : 0 };
      shader.uniforms.uLMUnlit         = { value: unlit ? 1 : 0 };
    }catch(e){
      console.warn('shader patch skipped:', e);
      // パッチ失敗時は no-op に戻す
      setOBC(material, null);
    }
  });

  material.needsUpdate = true;
  sanitizeAllMaterials();
  requestRender();
}

/* ====== Sheet（保存/読込） ====== */

// 汎用：0-based 列番号 -> A1 列名
function colNameFromIndex(idx){
  let n = idx + 1, s = '';
  while(n > 0){
    const r = (n - 1) % 26;
    s = String.fromCharCode(65 + r) + s;
    n = Math.floor((n - 1) / 26);
  }
  return s;
}

async function ensureSpreadsheet(parentId){
  // 既存検索：同階層 parentId に "pins" シート含む spreadsheet
  // 簡易：ドライブ直下検索から開始（本運用は親IDで q を追加）
  const q = "mimeType='application/vnd.google-apps.spreadsheet'";
  const r = await gapi.client.drive.files.list({q, fields:"files(id,name)"});
  if(r.result.files?.length){
    activeSheet.sheetId = r.result.files[0].id;
    activeSheet.title = 'pins'; // 固定運用
    return;
  }
  // 作成
  const create = await gapi.client.sheets.spreadsheets.create({
    resource:{
      properties:{ title:"LociMyu Captions" },
      sheets:[{properties:{title:'pins'}}]
    }
  });
  activeSheet.sheetId = create.result.spreadsheetId;
  activeSheet.title = 'pins';
}

async function loadMetaFromSheet(){
  if(!activeSheet.sheetId) return;
  try{
    // J1:ZZ1（値行）, J2:ZZ2（キー行）
    const startColIdx = 9; // J
    const endColIdx   = 60; // BD くらいまで余裕（必要に応じ拡張）
    const startCol    = colNameFromIndex(startColIdx);
    const endCol      = colNameFromIndex(endColIdx);
    const range1 = `'${activeSheet.title}'!${startCol}1:${endCol}1`;
    const range2 = `'${activeSheet.title}'!${startCol}2:${endCol}2`;

    const [v1, v2] = await Promise.all([
      gapi.client.sheets.spreadsheets.values.get({spreadsheetId:activeSheet.sheetId, range:range1}),
      gapi.client.sheets.spreadsheets.values.get({spreadsheetId:activeSheet.sheetId, range:range2}),
    ]);

    const values = (v1.result.values && v1.result.values[0]) || [];
    const keys   = (v2.result.values && v2.result.values[0]) || [];

    const meta = {};
    for(let i=0;i<Math.min(values.length, keys.length);i++){
      if(keys[i]) meta[keys[i]] = values[i];
    }

    // 背景
    if(meta.bg){ el.bgColor.value = meta.bg; scene.background.set(meta.bg); }
    if(meta.ortho!==undefined){ el.projOrtho.checked = !!Number(meta.ortho); applyProjection(); }

    // 各マテリアル
    materials.forEach(m=>{
      const key = materialKeyByMaterial.get(m);
      const s = matState.get(key) || {unlit:false,doubleSided:false,opacity:1,whiteTransparent:false,blackTransparent:false,threshold:0};
      s.unlit = !!Number(meta[`m:${key}:unlit`] ?? s.unlit);
      s.doubleSided = !!Number(meta[`m:${key}:double`] ?? s.doubleSided);
      s.opacity = (meta[`m:${key}:opacity`]!==undefined) ? clamp01(Number(meta[`m:${key}:opacity`]),1) : s.opacity;
      s.blackTransparent = !!Number(meta[`m:${key}:blackT`] ?? s.blackTransparent);
      s.whiteTransparent = !!Number(meta[`m:${key}:whiteT`] ?? s.whiteTransparent);
      s.threshold = (meta[`m:${key}:thresh`]!==undefined) ? clamp01(Number(meta[`m:${key}:thresh`]),0) : s.threshold;
      matState.set(key, s);
      // 反映
      if(materials.includes(m)){
        // UI は現在選択のものだけ更新
        if(el.matSelect.value === key) syncMatUIFromState(key);
        // ただし見た目には全マテリアルへ適用
        applyMatUITo(m);
      }
    });

  }catch(e){
    console.warn('loadMetaFromSheet failed', e);
  }
}

/* ====== ★ 修正版 saveMetaToSheet（A1 範囲 400 対策） ====== */
async function saveMetaToSheet(){
  if(!activeSheet.sheetId) return;

  const meta={ bg: el.bgColor.value, ortho: el.projOrtho.checked?1:0 };
  materials.forEach(m=>{
    const key=materialKeyByMaterial.get(m); const s=matState.get(key); if(!s) return;
    meta[`m:${key}:unlit`]=s.unlit?1:0;
    meta[`m:${key}:double`]=s.doubleSided?1:0;
    meta[`m:${key}:opacity`]=clamp01(s.opacity,1);
    meta[`m:${key}:blackT`]=s.blackTransparent?1:0;
    meta[`m:${key}:whiteT`]=s.whiteTransparent?1:0;
    meta[`m:${key}:thresh`]=clamp01(s.threshold,0);
  });

  const keys   = Object.keys(meta);
  const values = keys.map(k=> meta[k]);

  // 空ならスキップ
  if(keys.length===0) return;

  // J 列開始、終端列はキー長に合わせる
  const startColIdx = 9; // J
  const endColIdx   = startColIdx + keys.length - 1;
  const startCol    = colNameFromIndex(startColIdx);
  const endCol      = colNameFromIndex(endColIdx);

  const rangeRow1 = `'${activeSheet.title}'!${startCol}1:${endCol}1`; // 値
  const rangeRow2 = `'${activeSheet.title}'!${startCol}2:${endCol}2`; // キー

  try{
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId:activeSheet.sheetId,
      range: rangeRow1,
      valueInputOption:'RAW',
      resource:{ values:[values] }
    });
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId:activeSheet.sheetId,
      range: rangeRow2,
      valueInputOption:'RAW',
      resource:{ values:[keys] }
    });
  }catch(e){
    console.warn('saveMetaToSheet failed', e);
  }
}

/* ====== Simple captions (placeholders) ====== */
function renderCaptions(){
  const root = document.getElementById('capList');
  root.innerHTML = '';
  const div = document.createElement('div');
  div.className = 'caption';
  div.innerHTML = `
    <div class="thumbWrap">
      <img class="thumb" id="capThumb" alt="">
      <span class="fallback muted" id="capFallback" hidden>画像を読み込めませんでした</span>
    </div>
    <div style="margin-top:6px">
      <strong>キャプションタイトル</strong>
      <div class="muted">本文がここに入ります。</div>
    </div>
  `;
  root.appendChild(div);
}
renderCaptions();

/* ====== Helpers ====== */
function showLoading(v){ el.loading.classList.toggle('hidden', !v); }
function dbg(o){ el.dbg.textContent = JSON.stringify(o, null, 2); }

/* ====== Auto start if URL に ?view=1 など（閲覧モード相当の自動ロード雰囲気） ====== */
const params = new URLSearchParams(location.search);
if(params.get('autoload')==='1'){
  el.btnSignIn.onclick = ()=>{};
  // 実運用では認可後に onClickLoadGLB() を呼ぶ
}

</script>

<!-- Google API SDKs -->
<script>
  // ★ ここにあなたの Credentials を設定（既に提供された値を使う）
  window.__CLIENT_ID__ = "595200751510-ncahnf7edci6b9925becn5to49r6cguv.apps.googleusercontent.com";
  window.__API_KEY__   = "AIzaSyCUnTCr5yWUWPdEXST9bKP1LpgawU5rIbI";
</script>
<script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
</body>
</html>
