<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LociMyu v0.9.2 (Connector + pin toggle + small pins)</title>
  <link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="28" fill="%230b0f14"/><text x="32" y="39" font-size="28" text-anchor="middle" fill="%2353b7ff" font-family="Arial">L</text></svg>'>
  <style>
    :root{ --bg:#0b0f14; --panel:#121922; --text:#e6edf3; --accent:#53b7ff; --muted:#8fa3bd; --radius:16px;}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    .app{display:grid;grid-template-rows:auto 1fr;height:100vh}
    header{display:flex;gap:.75rem;align-items:center;padding:10px 12px;background:linear-gradient(180deg,#0e1520,#0b0f14);border-bottom:1px solid #1e2837}
    .pill{background:rgba(255,255,255,.06);padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.08);font-weight:700}
    input[type=text], select, textarea{background:#0f1722;border:1px solid #203049;color:var(--text);border-radius:10px;padding:8px 10px;min-width:260px}
    button{background:#152133;color:var(--text);border:1px solid #223146;border-radius:10px;padding:8px 12px;cursor:pointer}
    button[disabled]{opacity:.5;cursor:not-allowed}
    button:hover{background:#1a2b45}
    .accent{border-color:#2c82c9}
    .main{display:grid;grid-template-columns:360px 1fr 420px;gap:10px;padding:10px;height:calc(100vh - 58px)}
    .panel{background:#121922;border:1px solid #1e2837;border-radius:var(--radius);overflow:hidden;display:flex;flex-direction:column;min-height:0}
    .panel h3{margin:0;padding:10px 12px;border-bottom:1px solid #203049;background:#0f1722;font-size:.95rem;font-weight:600}
    .panel .body{padding:10px;overflow:auto}
    #viewer{position:relative}
    #viewerCanvas{display:block;width:100%;height:100%;background:#0a0f16;border-radius:var(--radius)}
    /* connector overlay */
    #connector{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    #connector line{stroke:#7cc4ff;stroke-width:2;stroke-opacity:.9;filter:url(#dropshadow)}
    #connector circle{fill:#7cc4ff;opacity:.9}
    .hud{position:absolute;left:10px;bottom:10px;display:flex;gap:8px}
    .chip{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px}
    .spinner{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg, rgba(10,15,22,.75), rgba(10,15,22,.75));backdrop-filter: blur(2px);}
    .spinner[hidden]{display:none}
    .lds{width:64px;height:64px;border-radius:50%;border:6px solid rgba(255,255,255,.12);border-top-color:var(--accent);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .signin-gate{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 600px at 50% 15%, rgba(83,183,255,.08), transparent 60%), linear-gradient(180deg,#0a0f16,#05070b);z-index:20}
    .card{width:min(560px,92vw);background:#0c1118;border:1px solid #1d2a3d;border-radius:24px;box-shadow:0 10px 30px rgba(0,0,0,.3);padding:20px}
    .card h1{margin:4px 0 8px;font-size:1.35rem}
    .card p{color:#c2d0e2;opacity:.9}
    .list{display:flex;flex-direction:column;gap:8px}
    .list .row{display:flex;align-items:center;justify-content:space-between;gap:8px;background:#0f1722;border:1px solid #203049;border-radius:12px;padding:10px;cursor:pointer}
    .row .title{font-weight:600}
    .row .meta{color:#a9b8cf;font-size:.85rem}
    .row:hover{background:#132035}
    .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .small{font-size:.85rem;color:#a9b8cf}
    .grid2{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
    .thumbs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .thumbs img{width:72px;height:72px;object-fit:cover;border-radius:10px;border:1px solid #223146}
    .hidden{display:none !important}
    .field{display:flex;gap:8px;align-items:center;margin:8px 0}
    .field label{min-width:120px;color:#a9b8cf}
    input[type="range"]{width:160px}
    .subtle{opacity:.8}
    .viewgrid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:40}
    .modal[hidden]{display:none}
    .modal .box{width:min(90vw,980px);max-height:80vh;background:#0f1722;border:1px solid #203049;border-radius:16px;overflow:hidden;display:flex;flex-direction:column}
    .modal header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:#0c131d;border-bottom:1px solid #203049}
    .modal .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;padding:10px;overflow:auto}
    .modal .cell{background:#0c1118;border:1px solid #223146;border-radius:12px;padding:8px;cursor:pointer;display:flex;flex-direction:column;gap:6px}
    .modal .cell img{width:100%;height:110px;object-fit:cover;border-radius:8px}
    .modal .cell:hover{background:#132035}
    #viewerPreview{position:absolute;top:10px;right:10px;max-width:28%;max-height:40%;border:1px solid #203049;border-radius:8px;background:#0a0f16cc;backdrop-filter: blur(2px);padding:6px;display:flex;flex-direction:column;gap:4px}
    #viewerPreview.hidden{display:none}
    #viewerPreview img{max-width:100%;max-height:36vh;border-radius:6px;display:block}
    #viewerPreview .cap{font-size:.8rem;color:#a9b8cf}
    @media (max-width: 1100px){ .main{grid-template-columns:1fr; grid-template-rows: 360px 1fr 480px} }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.157.0/examples/jsm/"
    }
  }
  </script>
  <script src="https://unpkg.com/heic2any@0.0.4/dist/heic2any.min.js"></script>
</head>
<body>
<div class="app">
  <header>
    <span class="pill">LociMyu</span>
    <div class="toolbar" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <input id="inputGLB" type="text" placeholder="GLB fileId or share URL" />
      <input id="inputSheet" type="text" placeholder="SpreadsheetId or share URL（空なら自動作成）" />
      <button id="btnLoad" class="accent" disabled>GLBを読み込む</button>
      <button id="btnViewOnly">閲覧リンクを生成</button>
      <span id="statusLabel" class="chip">サインイン待ち…</span>
    </div>
  </header>
  <div class="main">
    <!-- LEFT: Toolbox -->
    <section class="panel" id="leftToolbox">
      <h3>ツールボックス（マテリアル & カメラ & ピン）</h3>
      <div class="body">
        <div class="small subtle">Shift + クリック でピンを配置</div>
        <div class="flex" style="margin-top:6px;margin-bottom:6px">
          <button id="btnAddPin" disabled>＋ ピン追加モード</button>
          <button id="btnGizmo" disabled>ギズモ: OFF</button>
          <button id="btnTogglePins" disabled>ピン表示: ON</button>
          <button id="btnUndo" disabled>Ctrl+Z</button>
        </div>

        <div class="flex" style="align-items:center">
          <div class="small">ピン色:</div>
          <div id="colorPresets" class="flex"></div>
          <input id="colorPicker" type="color" value="#ff6b6b" />
        </div>

        <hr style="border-color:#203049;border-width:1px 0;margin:12px 0">

        <div class="small" style="margin:4px 0 6px">マテリアル編集</div>
        <div class="field"><label>対象</label><select id="matSelect"><option value="__all__">（全マテリアル）</option></select></div>
        <div class="field"><label>Unlit</label><input id="matUnlit" type="checkbox"><span class="small">明暗なし</span></div>
        <div class="field"><label>裏面描画</label><input id="matDoubleSided" type="checkbox"><span class="small">DoubleSide</span></div>
        <div class="field"><label>透明</label><input id="matTransparent" type="checkbox"><span class="small">ONで不透明度適用</span></div>
        <div class="field"><label>不透明度</label><input id="matOpacity" type="range" min="0" max="1" step="0.01" value="1"><span id="matOpacityVal" class="small">1.00</span></div>
        <div class="field"><label>テクスチャ反転</label><input id="matInvert" type="checkbox"><span class="small">色を反転</span></div>
        <div class="field"><label>白→透明</label><input id="matWhiteTransparent" type="checkbox"><span class="small">白ほど透明</span></div>
        <div class="field"><label>閾値（αTest）</label><input id="matThreshold" type="range" min="0" max="1" step="0.01" value="0"><span id="matThresholdVal" class="small">0.00</span></div>

        <hr style="border-color:#203049;border-width:1px 0;margin:12px 0">

        <div class="small" style="margin:4px 0 6px">ビュー</div>
        <div class="viewgrid" style="margin-bottom:8px">
          <button id="viewFront">前面</button>
          <button id="viewBack">背面</button>
          <button id="viewLeft">左面</button>
          <button id="viewRight">右面</button>
          <button id="viewTop">上面</button>
          <button id="viewBottom">下面</button>
        </div>
        <div class="field"><label>平行投影</label><input id="projOrtho" type="checkbox"><span class="small">ON: Orthographic</span></div>
        <div class="field"><label>背景色</label><input id="bgColor" type="color" value="#0a0f16"></div>
      </div>
    </section>

    <!-- CENTER: Viewer -->
    <section class="panel" id="viewer">
      <div class="spinner" id="loading" hidden><div class="lds"></div></div>
      <canvas id="viewerCanvas"></canvas>
      <!-- connector SVG -->
      <svg id="connector">
        <defs>
          <filter id="dropshadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="0" dy="0" stdDeviation="2" flood-color="#001a33" flood-opacity="0.9"/>
          </filter>
        </defs>
        <line id="connLine" x1="0" y1="0" x2="0" y2="0" style="display:none"/>
        <circle id="connDot" r="3" cx="0" cy="0" style="display:none"/>
      </svg>

      <div id="viewerPreview" class="hidden">
        <img id="previewImg" alt="preview"/>
        <div class="cap" id="previewCap"></div>
      </div>
      <div class="hud"><div class="chip" id="modeLabel">Orbit</div></div>
    </section>

    <!-- RIGHT: Caption box -->
    <section class="panel" id="rightCaption">
      <h3>キャプション</h3>
      <div class="body">
        <div class="small">ピン一覧</div>
        <div id="pinsList" class="list" style="margin:8px 0 14px"></div>
        <div id="noSelection">ピンを選択してください</div>
        <div id="editor" class="hidden">
          <div class="grid2">
            <label>タイトル<input id="capTitle" type="text" placeholder="タイトル" /></label>
            <button id="btnSavePin" class="accent" disabled>保存（Sheets）</button>
          </div>
          <label>本文<textarea id="capBody" rows="6" placeholder="キャプション本文"></textarea></label>
          <div class="flex">
            <input id="imgLocal" type="file" accept="image/*,.heic,.HEIC" />
            <button id="btnAttach" class="accent" disabled>画像を添付してDriveに保存</button>
          </div>
          <div class="flex">
            <button id="btnPickFromFolder" class="accent" disabled>📁 フォルダから選択</button>
          </div>
          <div class="thumbs" id="thumbs"></div>
          <div class="flex" style="justify-content:space-between;margin-top:8px;margin-bottom:8px">
            <button id="btnDeletePin" style="border-color:#5a1f26;color:#ffb4b4" disabled>ピン削除</button>
            <span class="small" id="autosaveTip">入力は数秒後に自動保存</span>
          </div>
          <div class="small subtle">※ ピン選択でビューが自動で寄ります</div>
        </div>
      </div>
    </section>
  </div>
</div>

<!-- Modal: Folder Picker -->
<div id="pickerModal" class="modal" hidden>
  <div class="box">
    <header>
      <strong>フォルダ内の画像を選択</strong>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="btnPickerReload">再読み込み</button>
        <button id="btnPickerClose">閉じる</button>
      </div>
    </header>
    <div id="pickerGrid" class="grid"></div>
  </div>
</div>

<!-- Sign-in Gate -->
<div class="signin-gate" id="gate">
  <div class="card">
    <h1>Googleにサインイン</h1>
    <p>本ツールは Google Drive / Google Sheets を使用します。先にサインインしてください。</p>
    <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
      <button id="btnSignIn" class="accent" style="font-weight:700">🔐 Sign in with Google</button>
      <span class="meta" style="opacity:.8">OAuth2 (Drive.file / Sheets)</span>
    </div>
  </div>
</div>

<!-- Google flags -->
<script>
  window.__flags = { gapi:false, gis:false };
  function onGapi(){ window.__flags.gapi = true; }
  function onGis(){  window.__flags.gis  = true; }
</script>
<script async defer src="https://accounts.google.com/gsi/client" onload="onGis()"></script>
<script async defer src="https://apis.google.com/js/api.js" onload="onGapi()"></script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';

// ====== CONFIG ======
const CLIENT_ID = '595200751510-ncahnf7edci6b9925becn5to49r6cguv.apps.googleusercontent.com';
const API_KEY   = 'AIzaSyCUnTCr5yWUWPdEXST9bKP1LpgawU5rIbI';
const DISCOVERY_DOCS = [
  'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest',
  'https://www.googleapis.com/discovery/v1/apis/sheets/v4/rest'
];
const SCOPES = [
  'https://www.googleapis.com/auth/drive.file',
  'https://www.googleapis.com/auth/drive.readonly',
  'https://www.googleapis.com/auth/drive.metadata.readonly',
  'https://www.googleapis.com/auth/spreadsheets'
].join(' ');

// ====== Elements & State ======
const el = {
  gate: document.getElementById('gate'),
  statusLabel: document.getElementById('statusLabel'),
  inputGLB: document.getElementById('inputGLB'),
  inputSheet: document.getElementById('inputSheet'),
  btnLoad: document.getElementById('btnLoad'),
  loading: document.getElementById('loading'),
  viewerCanvas: document.getElementById('viewerCanvas'),
  viewerPreview: document.getElementById('viewerPreview'),
  previewImg: document.getElementById('previewImg'),
  previewCap: document.getElementById('previewCap'),
  pinsList: document.getElementById('pinsList'),
  rightNoSel: document.getElementById('noSelection'),
  rightEditor: document.getElementById('editor'),
  capTitle: document.getElementById('capTitle'),
  capBody: document.getElementById('capBody'),
  btnSavePin: document.getElementById('btnSavePin'),
  btnDeletePin: document.getElementById('btnDeletePin'),
  btnAddPin: document.getElementById('btnAddPin'),
  btnGizmo: document.getElementById('btnGizmo'),
  btnTogglePins: document.getElementById('btnTogglePins'),
  btnUndo: document.getElementById('btnUndo'),
  modeLabel: document.getElementById('modeLabel'),
  btnSignIn: document.getElementById('btnSignIn'),
  colorPresets: document.getElementById('colorPresets'),
  colorPicker: document.getElementById('colorPicker'),
  imgLocal: document.getElementById('imgLocal'),
  btnAttach: document.getElementById('btnAttach'),
  btnPickFromFolder: document.getElementById('btnPickFromFolder'),
  thumbs: document.getElementById('thumbs'),
  autosaveTip: document.getElementById('autosaveTip'),
  // material
  matSelect: document.getElementById('matSelect'),
  matUnlit: document.getElementById('matUnlit'),
  matDoubleSided: document.getElementById('matDoubleSided'),
  matTransparent: document.getElementById('matTransparent'),
  matOpacity: document.getElementById('matOpacity'),
  matOpacityVal: document.getElementById('matOpacityVal'),
  matInvert: document.getElementById('matInvert'),
  matWhiteTransparent: document.getElementById('matWhiteTransparent'),
  matThreshold: document.getElementById('matThreshold'),
  matThresholdVal: document.getElementById('matThresholdVal'),
  // camera/tools
  viewFront: document.getElementById('viewFront'),
  viewBack: document.getElementById('viewBack'),
  viewLeft: document.getElementById('viewLeft'),
  viewRight: document.getElementById('viewRight'),
  viewTop: document.getElementById('viewTop'),
  viewBottom: document.getElementById('viewBottom'),
  projOrtho: document.getElementById('projOrtho'),
  bgColor: document.getElementById('bgColor'),
  // connector
  connector: document.getElementById('connector'),
  connLine: document.getElementById('connLine'),
  connDot: document.getElementById('connDot'),
  // modal
  pickerModal: document.getElementById('pickerModal'),
  pickerGrid: document.getElementById('pickerGrid'),
  btnPickerReload: document.getElementById('btnPickerReload'),
  btnPickerClose: document.getElementById('btnPickerClose'),
};
const viewOnly = new URLSearchParams(location.search).get('view') === '1';
let tokenClient; let gapiInited=false; let gisInited=false; let accessToken=null;
let renderer, scene, camera, controls, tcontrols, pinGroup, loader, currentModel=null;
let perspCam, orthoCam;
let raycaster, pointer;
let addPinMode=false, currentColor='#ff6b6b';
let pins=[], selectedPinId=null, undoStack=[];
let glbParents=[];
let autosaveTimer=null;
// materials
let materials=[], materialMap=new Map(); // key -> ORIGINAL material
let matOriginals=new WeakMap(); // ORIGINAL material -> {props}
let isOrtho=false;

// Image blob cache
const imageBlobCache = new Map(); // key: driveFileId or url string -> objectURL

// ====== Helpers ======
function extractDriveFileId(input){
  if(!input) return '';
  const m1 = input.match(/\/file\/d\/([a-zA-Z0-9_-]{10,})/); if(m1) return m1[1];
  const m2 = input.match(/[?&]id=([a-zA-Z0-9_-]{10,})/);     if(m2) return m2[1];
  const m3 = input.match(/^([a-zA-Z0-9_-]{20,})$/);          if(m3) return m3[1];
  return input.trim();
}
function extractSpreadsheetId(input){
  if(!input) return '';
  const m1 = input.match(/spreadsheets\/d\/([a-zA-Z0-9_-]{10,})/); if(m1) return m1[1];
  const m2 = input.match(/[?&]id=([a-zA-Z0-9_-]{10,})/);           if(m2) return m2[1];
  const m3 = input.match(/^([a-zA-Z0-9_-]{20,})$/);                if(m3) return m3[1];
  return input.trim();
}
function driveIdFromUrlMaybe(url){
  if(!url) return null;
  if(/^https?:\/\/drive\.google\.com\//.test(url)){
    return extractDriveFileId(url);
  }
  if(/^https?:\/\/(?:www\.)?google\.com\/uc/.test(url)){
    const u = new URL(url);
    const id = u.searchParams.get('id'); if(id) return id;
  }
  return null;
}
function toast(msg){ el.statusLabel.textContent=msg; setTimeout(()=> el.statusLabel.textContent='Ready', 2000); }
function setDisabled(ids, on){ ids.forEach(id=>{ const b=document.getElementById(id); if(b){ if(on) b.setAttribute('disabled','true'); else b.removeAttribute('disabled'); } }); }
function debounceSave(){ clearTimeout(autosaveTimer); autosaveTimer=setTimeout(()=> upsertPinToSheet().catch(console.error), 1200); }
function fmt(n){ return typeof n==='number'? Number(n.toFixed(6)) : n; }
function ensureArray(x){ return Array.isArray(x)?x:[]; }

// Resolve image URL with OAuth fetch if needed
async function resolveImageURL(url){
  const did = driveIdFromUrlMaybe(url);
  if(did){
    if(imageBlobCache.has(did)) return imageBlobCache.get(did);
    const obj = await driveFileToObjectURL(did);
    imageBlobCache.set(did, obj);
    return obj;
  }
  // plain URL
  if(imageBlobCache.has(url)) return imageBlobCache.get(url);
  imageBlobCache.set(url, url);
  return url;
}
async function driveFileToObjectURL(fileId){
  const dlUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
  const res = await fetch(dlUrl, { headers:{ Authorization:`Bearer ${accessToken}` } });
  if(!res.ok) throw new Error('image fetch failed '+res.status);
  const blob = await res.blob();
  return URL.createObjectURL(blob);
}

// ====== Google init ======
const waitGoogle = setInterval(()=>{
  if(!gapiInited && window.__flags.gapi && window.gapi){ gapi.load('client', initGapiClient); }
  if(!gisInited && window.__flags.gis){ gisInited = true; maybeReady(); }
  if(gapiInited && gisInited){ clearInterval(waitGoogle); }
}, 200);

async function initGapiClient(){
  try{
    await gapi.client.init({ apiKey: API_KEY, discoveryDocs: DISCOVERY_DOCS });
    gapiInited = true; maybeReady();
  }catch(e){ console.error('gapi init failed', e); }
}
function maybeReady(){
  if(!gapiInited || !gisInited) return;
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID, scope: SCOPES,
    callback: (resp)=>{
      accessToken = resp.access_token;
      if(accessToken){
        el.gate.style.display = 'none';
        setDisabled(['btnLoad','btnAddPin','btnGizmo','btnTogglePins','btnUndo','btnSavePin','btnDeletePin','btnAttach','btnPickFromFolder'], false);
        el.statusLabel.textContent = 'Ready';
        if(viewOnly){
          document.getElementById('leftToolbox').classList.add('hidden');
          document.getElementById('rightCaption').classList.add('hidden');
        }
      }
    }
  });
  el.btnSignIn.addEventListener('click', ()=>{
    if(!tokenClient){ alert('Google API 初期化中。少し待って再試行'); return; }
    tokenClient.requestAccessToken({ prompt:'consent' });
  });
}

// ====== Three viewer & cameras ======
function viewerInit(){
  renderer = new THREE.WebGLRenderer({ canvas: el.viewerCanvas, antialias:true });
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0f16);
  perspCam = new THREE.PerspectiveCamera(60, 2, 0.1, 5000);
  perspCam.position.set(2.8,1.6,3.6);
  orthoCam = new THREE.OrthographicCamera(-2,2,2,-2, -5000, 5000);
  camera = perspCam;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x223355, 0.6); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3,5,4); scene.add(dir);

  buildControls();

  pinGroup = new THREE.Group(); scene.add(pinGroup);
  loader = new GLTFLoader();
  raycaster = new THREE.Raycaster();
  pointer = new THREE.Vector2();
  window.addEventListener('resize', resize);
  el.viewerCanvas.addEventListener('pointerdown', onPointerDown);
  resize(); animate();
}
function buildControls(){
  if(controls){ controls.dispose(); }
  controls = new OrbitControls(camera, el.viewerCanvas); controls.target.set(0,1,0); controls.update();
  if(tcontrols){ scene.remove(tcontrols); }
  tcontrols = new TransformControls(camera, el.viewerCanvas);
  tcontrols.setSize(0.9); tcontrols.setSpace('world');
  tcontrols.addEventListener('dragging-changed', e=>{ controls.enabled = !e.value; });
  scene.add(tcontrols); tcontrols.visible=false; tcontrols.enabled=false; // default OFF
}
function resize(){
  const w = el.viewerCanvas.clientWidth || el.viewerCanvas.parentElement.clientWidth;
  const h = el.viewerCanvas.clientHeight || el.viewerCanvas.parentElement.clientHeight;
  renderer.setSize(w,h,false);
  if(camera.isPerspectiveCamera){
    camera.aspect = w/h;
  }else{
    const aspect = w/h;
    const halfH = (orthoCam.top - orthoCam.bottom)/2 || 1;
    orthoCam.left = -halfH*aspect; orthoCam.right = halfH*aspect;
  }
  camera.updateProjectionMatrix();
}
function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); updateConnector(); }
function renderNow(){ renderer.render(scene,camera); updateConnector(); }
viewerInit();

function sceneBounds(){
  if(!currentModel){ return { center:new THREE.Vector3(0,0,0), radius: 2 }; }
  const box = new THREE.Box3().setFromObject(currentModel);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const radius = Math.max(size.x,size.y,size.z)/2 || 1;
  return { center, radius: radius*1.2 };
}
function fitToScene(){
  const { center, radius } = sceneBounds();
  if(camera.isPerspectiveCamera){
    const dist = radius*2.2;
    const dir = new THREE.Vector3(1,0.6,1).normalize();
    camera.position.copy(center.clone().addScaledVector(dir, dist));
    controls.target.copy(center); controls.update();
  }else{
    updateOrthoFrustum();
    camera.position.set(center.x + 1, center.y + 0.6, center.z + 1);
    controls.target.copy(center); controls.update();
  }
}
function updateOrthoFrustum(){
  const { radius } = sceneBounds();
  const rect = el.viewerCanvas.getBoundingClientRect();
  const aspect = (rect.width||1)/(rect.height||1);
  const halfH = radius;
  orthoCam.top =  halfH;
  orthoCam.bottom = -halfH;
  orthoCam.left = -halfH*aspect;
  orthoCam.right = halfH*aspect;
  orthoCam.zoom = 1;
  orthoCam.updateProjectionMatrix();
}
function switchProjection(useOrtho){
  const pos = camera.position.clone();
  const tar = controls.target.clone();
  isOrtho = !!useOrtho;
  if(isOrtho){
    updateOrthoFrustum();
    camera = orthoCam;
  }else{
    camera = perspCam;
  }
  camera.position.copy(pos);
  buildControls();
  controls.target.copy(tar); controls.update();
  tcontrols.camera = camera;
  resize(); renderNow();
}
// Remapped camera directions with Left/Right swapped
function setNamedView(name){
  const { center, radius } = sceneBounds();
  const d = radius*2.2;
  let dir = new THREE.Vector3(0,0,d);
  switch(name){
    case 'front': dir.set(d,0,0); break;     // +X
    case 'back':  dir.set(-d,0,0); break;    // -X
    case 'left':  dir.set(0,0,-d); break;    // -Z
    case 'right': dir.set(0,0,d); break;     // +Z
    case 'top':   dir.set(0,d,0); break;
    case 'bottom':dir.set(0,-d,0); break;
  }
  camera.position.copy(center.clone().add(dir));
  controls.target.copy(center);
  controls.update();
  if(!camera.isPerspectiveCamera){ updateOrthoFrustum(); }
  renderNow();
}

// ====== Connector (pin -> preview) ======
function getCanvasRelativePointFromWorld(world){
  const v = world.clone().project(camera);
  const rect = el.viewerCanvas.getBoundingClientRect();
  const x = (v.x + 1) / 2 * rect.width;
  const y = (1 - (v.y + 1) / 2) * rect.height;
  return { x, y };
}
function getPreviewAnchor(){
  if(el.viewerPreview.classList.contains('hidden')) return null;
  const rectCanvas = el.viewerCanvas.getBoundingClientRect();
  const rectPrev = el.viewerPreview.getBoundingClientRect();
  const x = (rectPrev.left - rectCanvas.left); // left edge center
  const y = (rectPrev.top - rectCanvas.top) + rectPrev.height/2;
  return { x, y };
}
function updateConnector(){
  const p = pins.find(x=>x.id===selectedPinId);
  if(!p || !p.mesh || el.viewerPreview.classList.contains('hidden') || !pinGroup.visible){
    el.connLine.style.display = 'none';
    el.connDot.style.display = 'none';
    return;
  }
  const a = getCanvasRelativePointFromWorld(p.pos);
  const b = getPreviewAnchor();
  if(!b){ el.connLine.style.display = 'none'; el.connDot.style.display = 'none'; return; }

  const svg = el.connector;
  const rect = el.viewerCanvas.getBoundingClientRect();
  svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);

  el.connLine.setAttribute('x1', a.x); el.connLine.setAttribute('y1', a.y);
  el.connLine.setAttribute('x2', b.x); el.connLine.setAttribute('y2', b.y);
  el.connLine.style.display = 'block';

  el.connDot.setAttribute('cx', a.x); el.connDot.setAttribute('cy', a.y);
  el.connDot.style.display = 'block';
}

// ====== Pins ======
function setAddPinMode(on){ addPinMode=on; el.modeLabel.textContent=on?'Add Pin: Click model (または Shift+クリック)':(tcontrols.visible?'Gizmo':'Orbit'); }
function getIntersectPoint(event){
  const rect=el.viewerCanvas.getBoundingClientRect();
  pointer.x=((event.clientX-rect.left)/rect.width)*2-1;
  pointer.y=-((event.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(pointer,camera);
  const hits=currentModel?raycaster.intersectObject(currentModel,true):[];
  return hits.length?hits[0].point.clone():null;
}
function onPointerDown(e){
  if(!currentModel || viewOnly) return;
  if(tcontrols.dragging) return;
  if(e.shiftKey){
    const pt=getIntersectPoint(e);
    if(pt){ createPin(pt,currentColor); return; }
  }
  if(addPinMode){
    const pt=getIntersectPoint(e);
    if(pt){ createPin(pt,currentColor); setAddPinMode(false); }
    return;
  }
  const rect=el.viewerCanvas.getBoundingClientRect();
  pointer.x=((e.clientX-rect.left)/rect.width)*2-1;
  pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(pointer,camera);
  const hits=raycaster.intersectObjects(pinGroup.children,false);
  if(hits.length){ selectPin(hits[0].object.userData.pinId, {fly:true}); }
}
function addUndo(u){ undoStack.push(u); }
function undo(){ const u = undoStack.pop(); if(!u) return; if(u.type==='move'){ const p=pins.find(x=>x.id===u.id); if(p){ p.pos.copy(u.from); placePinMesh(p); selectPin(p.id); renderNow(); } } else if(u.type==='add'){ removePin(u.id,{silent:true}); } else if(u.type==='delete'){ pins.push(u.pin); placePinMesh(u.pin); refreshPinsList(); selectPin(u.pin.id); renderNow(); } }
function createPin(pos,color){ const id=`p_${Date.now()}_${Math.random().toString(36).slice(2,7)}`; const pin={id,pos:pos.clone(),color:color||'#ff6b6b',title:'',body:'',images:[],mesh:null}; pins.push(pin); placePinMesh(pin); refreshPinsList(); selectPin(id); addUndo({type:'add',id}); }
function placePinMesh(pin){
  if(pin.mesh){ pinGroup.remove(pin.mesh); pin.mesh.geometry.dispose(); pin.mesh.material.dispose(); pin.mesh=null; }
  const geo=new THREE.SphereGeometry(0.006,16,16);
  const mat=new THREE.MeshBasicMaterial({color:new THREE.Color(pin.color)});
  const mesh=new THREE.Mesh(geo,mat);
  mesh.position.copy(pin.pos); mesh.userData.pinId=pin.id;
  pin.mesh=mesh; pinGroup.add(mesh);
}
function selectPin(id,{fly}={}){
  selectedPinId=id;
  const p=pins.find(x=>x.id===id);
  if(!p){ el.rightEditor.classList.add('hidden'); el.rightNoSel.classList.remove('hidden'); updateViewerPreviewForPin(null); return; }
  el.rightNoSel.classList.add('hidden'); el.rightEditor.classList.remove('hidden');
  document.getElementById('capTitle').value=p.title||'';
  document.getElementById('capBody').value=p.body||'';
  renderThumbs(p);
  updateViewerPreviewForPin(p);
  tcontrols.attach(p.mesh);
  tcontrols.visible = false; tcontrols.enabled = false; // keep OFF by default
  document.getElementById('btnGizmo').textContent = 'ギズモ: OFF';
  if(fly){ flyTo(p.pos); } else { controls.target.copy(p.pos); controls.update(); }
}
function flyTo(target){
  const startPos = camera.position.clone();
  const startTar = controls.target.clone();
  const endTar = target.clone();
  const dir = new THREE.Vector3().subVectors(startPos, startTar);
  const endPos = endTar.clone().add(dir);
  const t0 = performance.now(); const dur = 600;
  (function tick(now){
    const t = Math.min(1, (now - t0)/dur);
    const k = t<.5 ? 2*t*t : -1+(4-2*t)*t;
    camera.position.lerpVectors(startPos, endPos, k);
    controls.target.lerpVectors(startTar, endTar, k);
    controls.update();
    renderNow();
    if(t<1) requestAnimationFrame(tick);
  })(t0);
}
function refreshPinsList(){
  el.pinsList.innerHTML='';
  pins.forEach(p=>{
    const row=document.createElement('div'); row.className='row'; row.dataset.id=p.id;
    const left=document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='8px';
    const dot=document.createElement('div'); dot.style.width='10px'; dot.style.height='10px'; dot.style.borderRadius='999px'; dot.style.background=p.color;
    const title=document.createElement('div'); title.className='title'; title.textContent=p.title||'(無題)';
    const meta=document.createElement('div'); meta.className='meta'; meta.textContent=`x:${p.pos.x.toFixed(2)} y:${p.pos.y.toFixed(2)} z:${p.pos.z.toFixed(2)}`;
    left.appendChild(dot); left.appendChild(title);
    row.appendChild(left); row.appendChild(meta);
    row.addEventListener('click',()=>selectPin(p.id,{fly:true}));
    el.pinsList.appendChild(row);
  });
}
function removePin(id,{silent}={}){
  const idx=pins.findIndex(x=>x.id===id); if(idx<0) return;
  const pin=pins[idx]; if(pin.mesh){ pinGroup.remove(pin.mesh); pin.mesh.geometry.dispose(); pin.mesh.material.dispose(); }
  pins.splice(idx,1);
  if(!silent) addUndo({type:'delete',pin});
  refreshPinsList(); el.rightEditor.classList.add('hidden'); el.rightNoSel.classList.remove('hidden'); selectedPinId=null; updateViewerPreviewForPin(null);
}
function renderThumbs(p){
  const thumbs=document.getElementById('thumbs'); thumbs.innerHTML='';
  ensureArray(p.images).forEach(async (url)=>{
    const img=document.createElement('img'); img.alt = 'thumb';
    thumbs.appendChild(img);
    try{
      img.src = await resolveImageURL(url);
      img.addEventListener('click', async ()=>{ const src = await resolveImageURL(url); setPreview(src, p.title||''); });
    }catch{ img.remove(); }
  });
}
async function setPreview(url, cap){
  if(!url){ el.viewerPreview.classList.add('hidden'); return; }
  try{
    const src = await resolveImageURL(url);
    el.previewImg.src = src;
    el.previewCap.textContent = cap||'';
    el.viewerPreview.classList.remove('hidden');
  }catch(e){
    console.warn('preview failed', e);
    el.viewerPreview.classList.add('hidden');
  }
}
function updateViewerPreviewForPin(p){ setPreview(p && p.images && p.images[0] ? p.images[0] : null, p?.title); }

// ====== Colors ======
const PRESET_COLORS = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#ef476f','#f72585','#b5179e','#7209b7','#3a0ca3','#4361ee','#4cc9f0'];
function buildColorPresets(){
  if(!el.colorPresets) return;
  el.colorPresets.innerHTML='';
  PRESET_COLORS.forEach(c=>{
    const b=document.createElement('button'); b.style.width='18px'; b.style.height='18px'; b.style.borderRadius='999px'; b.style.border='2px solid #223146'; b.style.background=c; b.title=c;
    b.addEventListener('click',()=>{ currentColor=c; if(el.colorPicker) el.colorPicker.value=c; if(selectedPinId){ const p=pins.find(x=>x.id===selectedPinId); p.color=c; placePinMesh(p); refreshPinsList(); debounceSave(); } });
    el.colorPresets.appendChild(b);
  });
  if(el.colorPicker){
    el.colorPicker.addEventListener('input', ()=>{ currentColor=el.colorPicker.value; if(selectedPinId){ const p=pins.find(x=>x.id===selectedPinId); p.color=currentColor; placePinMesh(p); refreshPinsList(); debounceSave(); } });
  }
}
buildColorPresets();

// ====== GLB load ======
document.getElementById('btnLoad').addEventListener('click', ()=>{
  const fid = extractDriveFileId(el.inputGLB.value.trim());
  el.inputGLB.value = fid;
  loadGLBByFileId(fid);
});
document.getElementById('btnViewOnly')?.addEventListener('click', ()=>{
  const fid = extractDriveFileId(el.inputGLB.value.trim());
  const sid = extractSpreadsheetId(el.inputSheet.value.trim());
  const url = new URL(location.href); url.searchParams.set('view','1'); if(fid) url.searchParams.set('fileId', fid); if(sid) url.searchParams.set('sheetId', sid);
  navigator.clipboard.writeText(url.toString()); toast('閲覧リンクをコピーしました');
});

async function loadGLBByFileId(fileId){
  if(!accessToken){ alert('先にサインインしてください'); return; }
  if(!fileId){ alert('GLBの fileId または共有URLを入力してください'); return; }
  el.loading.hidden = false;
  try{
    el.statusLabel.textContent = 'GLBを読み込み中…';
    const meta = await gapi.client.drive.files.get({ fileId, fields:'id,name,mimeType,parents' });
    glbParents = meta.result.parents || [];
    const dlUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
    const res = await fetch(dlUrl, { headers:{ Authorization:`Bearer ${accessToken}` } });
    if(!res.ok){
      let hint = ''; if(res.status === 403 || res.status === 404){ hint = '（IDや共有設定を確認してください）'; }
      throw new Error(`Drive download failed: ${res.status} ${res.statusText} ${hint}`);
    }
    const ab = await res.arrayBuffer();
    if(currentModel){
      scene.remove(currentModel);
      currentModel.traverse(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material){ if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose()); else o.material.dispose(); } });
      currentModel=null;
    }
    await new Promise((resolve,reject)=>{
      try{
        loader.parse(ab, '', (gltf)=>{ currentModel = gltf.scene; scene.add(currentModel); fitToScene(); collectMaterials(); renderNow(); resolve(); }, (err)=> reject(err||new Error('parse failed')) );
      }catch(err){ reject(err); }
    });
    el.statusLabel.textContent = `Loaded: ${meta.result.name}`;
    if(!extractSpreadsheetId(el.inputSheet.value.trim())){
      const sheetId = await ensureSpreadsheet(meta.result.name);
      el.inputSheet.value = sheetId;
      toast('スプレッドシートを自動作成しました');
    }
  }catch(err){
    console.error(err);
    el.statusLabel.textContent = 'Load failed';
    alert('GLB読み込みに失敗しました：' + (err?.message || 'unknown error'));
  }finally{
    el.loading.hidden = true;
  }
}

// ====== Materials (always visible) ======
function collectMaterials(){
  materials=[]; materialMap.clear();
  const set = new Set();
  currentModel.traverse(obj=>{
    const m=obj.material;
    if(Array.isArray(m)){ m.forEach(mm=>{ if(mm && !set.has(mm)){ set.add(mm); materials.push(mm); ensureMatRecord(mm); } }); }
    else if(m){ if(!set.has(m)){ set.add(m); materials.push(m); ensureMatRecord(m); } }
  });
  el.matSelect.innerHTML = '<option value="__all__">（全マテリアル）</option>';
  materials.forEach((m,idx)=>{
    const name = m.name && m.name.trim() ? m.name : `Material_${idx}`;
    materialMap.set(name, m);
    const opt=document.createElement('option'); opt.value=name; opt.textContent=name; el.matSelect.appendChild(opt);
  });
  applyMaterialLive(); // ensure controls reflect
}
function ensureMatRecord(m){
  if(matOriginals.has(m)) return;
  matOriginals.set(m, {
    color: (m.color ? m.color.clone() : new THREE.Color(0xffffff)),
    map: m.map || null,
    alphaMap: m.alphaMap || null,
    transparent: !!m.transparent,
    opacity: (m.opacity ?? 1),
    alphaTest: (m.alphaTest ?? 0),
    side: m.side ?? THREE.FrontSide,
    depthWrite: m.depthWrite,
    depthTest: m.depthTest,
    blending: m.blending,
    toneMapped: m.toneMapped,
    wasUnlit: false,
    unlitMat: null
  });
}
function getSelectedOriginalMaterials(){
  const key=el.matSelect.value;
  if(key==='__all__') return materials;
  const m = materialMap.get(key);
  return m? [m] : [];
}
function getActiveMaterialFor(originalM){
  const rec = matOriginals.get(originalM);
  return (rec && rec.wasUnlit && rec.unlitMat) ? rec.unlitMat : originalM;
}
function copyTextureParams(from, to){
  to.wrapS = from.wrapS; to.wrapT = from.wrapT;
  to.repeat.copy(from.repeat); to.offset.copy(from.offset);
  to.center.copy(from.center); to.rotation = from.rotation;
  to.flipY = from.flipY;
  to.magFilter = from.magFilter; to.minFilter = from.minFilter;
  to.generateMipmaps = from.generateMipmaps;
  to.anisotropy = from.anisotropy;
  to.colorSpace = from.colorSpace ?? THREE.SRGBColorSpace;
}
async function processTextureToCanvasTextureFromOriginal(originalTex, { invertRGB=false, alphaFromWhite=false, threshold=0 }){
  if(!originalTex || !originalTex.image) return null;
  const image = originalTex.image;
  const w = image.width || image.videoWidth || 0;
  const h = image.height || image.videoHeight || 0;
  if(!w || !h) return null;

  const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  try{ ctx.drawImage(image, 0, 0, w, h); }
  catch(e){ try{ const bmp = await createImageBitmap(image); ctx.drawImage(bmp,0,0,w,h); } catch(e2){ return null; } }
  const img = ctx.getImageData(0,0,w,h); const data = img.data;
  for(let i=0;i<data.length;i+=4){
    let r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
    if(invertRGB){ r=255-r; g=255-g; b=255-b; }
    let alpha=a;
    if(alphaFromWhite){
      const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
      let alf = 1 - L;
      if(threshold>0){ alf = (alf >= threshold) ? alf : 0; }
      alpha = Math.round(Math.min(1,Math.max(0,alf))*255);
    }
    data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=alpha;
  }
  ctx.putImageData(img,0,0);
  const ctex = new THREE.CanvasTexture(canvas);
  copyTextureParams(originalTex, ctex);
  ctex.needsUpdate = true;
  return ctex;
}
async function applyMaterialLive(){
  const wantUnlit = el.matUnlit.checked;
  const wantDouble = el.matDoubleSided.checked;
  const wantTransparent = el.matTransparent.checked;
  const opacity = parseFloat(el.matOpacity.value);
  const invert = el.matInvert.checked;
  const whiteToAlpha = el.matWhiteTransparent.checked;
  const thresh = parseFloat(el.matThreshold.value);

  const targets = getSelectedOriginalMaterials();
  for(const origM of targets){
    ensureMatRecord(origM);
    const rec = matOriginals.get(origM);

    // Unlit swap (carry .color)
    if(wantUnlit && !rec.wasUnlit){
      const active = getActiveMaterialFor(origM);
      const um = new THREE.MeshBasicMaterial();
      um.color = (active.color ? active.color.clone() : rec.color.clone());
      um.map = active.map || rec.map || null;
      um.transparent = active.transparent;
      um.opacity = active.opacity;
      um.alphaTest = active.alphaTest;
      um.side = active.side;
      um.depthWrite = active.depthWrite;
      um.depthTest = active.depthTest;
      um.blending = active.blending;
      um.toneMapped = false;
      rec.unlitMat = um; rec.wasUnlit = true;
      currentModel.traverse(obj=>{
        const m=obj.material;
        if(m===origM || m===active){ obj.material = um; }
        else if(Array.isArray(m)){ obj.material = m.map(x=> (x===origM||x===active)? um : x ); }
      });
    }else if(!wantUnlit && rec.wasUnlit){
      currentModel.traverse(obj=>{
        const m=obj.material;
        if(m===rec.unlitMat){ obj.material = origM; }
        else if(Array.isArray(m)){ obj.material = m.map(x=> (x===rec.unlitMat)? origM : x ); }
      });
      rec.wasUnlit = false;
    }

    const mat = getActiveMaterialFor(origM);

    // Side
    mat.side = wantDouble ? THREE.DoubleSide : THREE.FrontSide;

    // Transparency & opacity
    mat.transparent = wantTransparent || whiteToAlpha || (opacity < 1.0);
    mat.opacity = opacity;
    mat.alphaTest = thresh;
    mat.depthWrite = !mat.transparent || thresh>0;

    // Texture processing
    if((invert || whiteToAlpha) && rec.map){
      try{
        const processed = await processTextureToCanvasTextureFromOriginal(rec.map, { invertRGB: invert, alphaFromWhite: whiteToAlpha, threshold: thresh });
        if(processed){ mat.map = processed; mat.map.needsUpdate = true; }
      }catch(e){ console.warn('texture process failed', e); }
    }else if(!invert && !whiteToAlpha){
      // restore original map if existed; otherwise keep color-only
      mat.map = rec.map || null;
      if(mat.map) mat.map.needsUpdate = true;
    }

    // Ensure color is preserved even if map is null
    if(!mat.color && rec.color){ mat.color = rec.color.clone(); }
    if(mat.color) mat.color.needsUpdate = true;

    mat.needsUpdate = true;
  }
  renderNow();
}

// UI events for material (live)
el.matOpacity.addEventListener('input', ()=>{ el.matOpacityVal.textContent = parseFloat(el.matOpacity.value).toFixed(2); applyMaterialLive(); });
el.matThreshold.addEventListener('input', ()=>{ el.matThresholdVal.textContent = parseFloat(el.matThreshold.value).toFixed(2); applyMaterialLive(); });
el.matTransparent.addEventListener('change', ()=> applyMaterialLive());
el.matInvert.addEventListener('change', ()=> applyMaterialLive());
el.matWhiteTransparent.addEventListener('change', ()=> applyMaterialLive());
el.matUnlit.addEventListener('change', ()=> applyMaterialLive());
el.matDoubleSided.addEventListener('change', ()=> applyMaterialLive());
el.matSelect.addEventListener('change', ()=> applyMaterialLive());

// ====== Camera tools ======
el.viewFront.addEventListener('click', ()=> setNamedView('front'));
el.viewBack.addEventListener('click', ()=> setNamedView('back'));
el.viewLeft.addEventListener('click', ()=> setNamedView('left'));
el.viewRight.addEventListener('click', ()=> setNamedView('right'));
el.viewTop.addEventListener('click', ()=> setNamedView('top'));
el.viewBottom.addEventListener('click', ()=> setNamedView('bottom'));
el.projOrtho.addEventListener('change', ()=> switchProjection(el.projOrtho.checked));
el.bgColor.addEventListener('input', ()=>{ scene.background = new THREE.Color(el.bgColor.value); renderNow(); });

// ====== Sheets: ensure + upsert ======
async function ensureSpreadsheet(glbName){
  const title = `LociMyu - ${glbName}`;
  const resp = await gapi.client.sheets.spreadsheets.create({
    resource: { properties: { title }, sheets: [{ properties: { title: 'pins' } }] }
  });
  const spreadsheetId = resp.result.spreadsheetId;
  await gapi.client.sheets.spreadsheets.values.update({
    spreadsheetId, range: 'pins!A1',
    valueInputOption:'RAW',
    resource:{ values: [[ 'pin_id','title','body','x','y','z','color','images','updated_at' ]] }
  });
  return spreadsheetId;
}
async function upsertPinToSheet(){
  const sheetId = extractSpreadsheetId(el.inputSheet.value.trim()); if(!sheetId) return;
  const p = pins.find(x=>x.id===selectedPinId); if(!p) return;
  try{
    const col = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: sheetId, range: 'pins!A:A' });
    const rows = col.result.values || [];
    let rowIndex = -1;
    for(let i=0;i<rows.length;i++){ if(rows[i][0]===p.id){ rowIndex=i; break; } }
    const values = [[ p.id, p.title||'', p.body||'', fmt(p.pos.x), fmt(p.pos.y), fmt(p.pos.z), p.color, JSON.stringify(ensureArray(p.images)), new Date().toISOString() ]];
    if(rowIndex>=0){
      const range = `pins!A${rowIndex+1}:I${rowIndex+1}`;
      await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: sheetId, range, valueInputOption:'RAW', resource:{ values } });
    }else{
      await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: sheetId, range: 'pins!A1', valueInputOption:'RAW', resource:{ values } });
    }
    el.autosaveTip.textContent = '保存しました';
    setTimeout(()=> el.autosaveTip.textContent='入力は数秒後に自動保存', 1500);
  }catch(e){ console.error(e); }
}
document.getElementById('btnSavePin').addEventListener('click', ()=> upsertPinToSheet());

// ====== Image attach & Drive upload / folder picker ======
document.getElementById('btnAttach').addEventListener('click', async ()=>{
  const file = el.imgLocal.files?.[0]; const p = pins.find(x=>x.id===selectedPinId);
  if(!file || !p){ alert('画像とピンを確認してください'); return; }
  try{
    const blob = await toUploadableBlob(file);
    const uploaded = await driveMultipartUpload(blob, sanitizeName(file.name), glbParents);
    const url = `https://drive.google.com/uc?id=${uploaded.id}`;
    p.images = ensureArray(p.images); p.images.push(url);
    renderThumbs(p);
    setPreview(url, p.title||'');
    debounceSave();
    toast('画像をアップロードしました');
  }catch(err){ console.error(err); alert('画像アップロードに失敗しました'); }
});
function sanitizeName(n){ return n.replace(/[^\p{Letter}\p{Number}\s._-]+/gu,'_'); }
async function toUploadableBlob(file){
  const ext = (file.name.split('.').pop()||'').toLowerCase();
  if(ext==='heic' || ext==='heif'){
    const jpegBlob = await window.heic2any({ blob:file, toType:'image/jpeg', quality:0.9 });
    return new Blob([jpegBlob], { type:'image/jpeg' });
  }
  return file;
}
async function driveMultipartUpload(blob, name, parents){
  const meta = { name, parents: parents && parents.length ? parents : undefined };
  const boundary = '-------loci' + Math.random().toString(36).slice(2);
  const bufMeta = new TextEncoder().encode(
    `\r\n--${boundary}\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(meta)}\r\n`
  );
  const bufTail = new TextEncoder().encode(`\r\n--${boundary}--`);
  const stream = new Blob([ bufMeta, blob, bufTail ], { type: 'multipart/related; boundary='+boundary });
  const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
    method: 'POST',
    headers: { 'Authorization': 'Bearer ' + accessToken },
    body: stream
  });
  if(!res.ok) throw new Error('Drive upload failed ' + res.status);
  return await res.json();
}

// Folder picker
el.btnPickFromFolder.addEventListener('click', openPickerModal);
el.btnPickerClose.addEventListener('click', ()=> el.pickerModal.hidden = true);
el.btnPickerReload.addEventListener('click', loadFolderImages);

async function openPickerModal(){
  if(!glbParents || !glbParents.length){ alert('GLBの親フォルダが不明です。先にGLBを読み込んでください。'); return; }
  await loadFolderImages();
  el.pickerModal.hidden = false;
}
async function loadFolderImages(){
  if(!accessToken){ alert('先にサインインしてください'); return; }
  el.pickerGrid.innerHTML = '<div class="small">読み込み中…</div>';
  const cells = [];
  try{
    for(const parent of glbParents){
      const q = `'${parent}' in parents and trashed=false and (mimeType contains 'image/')`;
      const resp = await gapi.client.drive.files.list({
        q, pageSize: 100, fields: 'files(id,name,mimeType)'
      });
      const files = resp.result.files || [];
      for(const f of files){
        const id = f.id;
        const url = `https://drive.google.com/uc?id=${id}`;
        const cell = document.createElement('div'); cell.className='cell';
        const img = document.createElement('img'); img.alt = f.name;
        // resolve via OAuth to avoid 403
        resolveImageURL(url).then(objUrl => { img.src = objUrl; }).catch(()=>{});
        const cap = document.createElement('div'); cap.textContent = f.name; cap.className='small';
        cell.appendChild(img); cell.appendChild(cap);
        cell.addEventListener('click', ()=> chooseFolderImage(url));
        cells.push(cell);
      }
    }
    el.pickerGrid.innerHTML='';
    if(!cells.length){
      el.pickerGrid.innerHTML = '<div class="small">フォルダに画像が見つかりませんでした。</div>';
    }else{
      cells.forEach(c=> el.pickerGrid.appendChild(c));
    }
  }catch(e){
    console.error(e);
    el.pickerGrid.innerHTML = '<div class="small">読み込みに失敗しました。</div>';
  }
}
function chooseFolderImage(url){
  el.pickerModal.hidden = true;
  const p = pins.find(x=>x.id===selectedPinId);
  if(!p){ alert('先にピンを選択してください'); return; }
  p.images = ensureArray(p.images); p.images.push(url);
  renderThumbs(p);
  setPreview(url, p.title||'');
  debounceSave();
}

// ====== Gizmo & Inputs ======
document.getElementById('btnAddPin').addEventListener('click', ()=> setAddPinMode(!addPinMode));
document.getElementById('btnGizmo').addEventListener('click', ()=>{
  if(!selectedPinId){ toast('ピンを選択してください'); return; }
  tcontrols.visible = !tcontrols.visible;
  tcontrols.enabled = tcontrols.visible;
  document.getElementById('btnGizmo').textContent = 'ギズモ: ' + (tcontrols.visible?'ON':'OFF');
  el.modeLabel.textContent = tcontrols.visible ? 'Gizmo' : 'Orbit';
});
document.getElementById('btnTogglePins').addEventListener('click', ()=>{
  pinGroup.visible = !pinGroup.visible;
  document.getElementById('btnTogglePins').textContent = 'ピン表示: ' + (pinGroup.visible? 'ON' : 'OFF');
  renderNow();
});
document.getElementById('btnUndo').addEventListener('click', ()=> undo());
document.getElementById('capTitle').addEventListener('input', ()=>{ const p=pins.find(x=>x.id===selectedPinId); if(p){ p.title=el.capTitle.value; refreshPinsList(); debounceSave(); updateViewerPreviewForPin(p); } });
document.getElementById('capBody').addEventListener('input', ()=>{ const p=pins.find(x=>x.id===selectedPinId); if(p){ p.body=el.capBody.value; debounceSave(); } });

// Track gizmo move → update pin pos
tcontrols.addEventListener('objectChange', ()=>{
  if(!selectedPinId || !tcontrols.object || !tcontrols.visible) return;
  const p=pins.find(x=>x.id===selectedPinId);
  if(!p) return;
  const prev = p.pos.clone();
  p.pos.copy(tcontrols.object.position);
  addUndo({type:'move', id:p.id, from:prev});
  debounceSave();
});

document.getElementById('btnDeletePin').addEventListener('click', ()=>{ if(!selectedPinId) return; const id=selectedPinId; removePin(id); debounceSave(); });

</script>
</body>
</html>
