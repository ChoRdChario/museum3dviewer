<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<title>Drive GLB Viewer + Pins (v1.22.0-bg)</title>
<link href="https://accounts.google.com" rel="preconnect"/>
<script async="" src="https://accounts.google.com/gsi/client"></script>
<script async="" src="https://apis.google.com/js/api.js"></script>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<link href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='%23222'/%3E%3Ccircle cx='32' cy='32' r='18' fill='%23e33'/%3E%3C/svg%3E" rel="icon"/>
<style>
  /* 非活性行の見た目と操作抑止 */
.disabled { opacity: .55; pointer-events: none; }
    :root { --bg:#111; --muted:#666; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:#222;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    header{display:flex;gap:8px;align-items:center;padding:10px 12px;background:#f8f8f8;border-bottom:1px solid #e8e8e8;position:sticky;top:0;z-index:10;flex-wrap:wrap}
    header input{padding:6px 8px;border:1px solid #ddd;border-radius:8px;min-width:200px}
    header button{padding:6px 10px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer}
    header .grow{flex:1}
    main{display:grid;grid-template-columns: 1fr 360px;gap:10px;}
#view{
  position:relative;
  width:100%;
  height:calc(100dvh - 56px); /* ← 100vh → 100dvh に変更 */
  overflow:hidden;
  background:#222;
}
    #canvas{display:block;width:100%;height:100%}
    aside{height:calc(100dvh - 56px);overflow:auto;background:#fafafa;border-left:1px solid #eee}
    .sec{padding:10px 12px;border-bottom:1px solid #eee}
    .row{display:flex;gap:8px;align-items:center;margin-top:6px;flex-wrap:wrap}
    .muted{color:var(--muted);font-size:12px}
    .hidden{display:none}
    .warn{color:#b00}
    .badge{display:inline-block;background:#eef;border:1px solid #dde;border-radius:999px;padding:2px 8px;font-size:12px}
    .pin{border:1px solid #e5e5e5;background:#fff;border-radius:10px;padding:8px;margin-top:8px}
    .pin input,.pin textarea{width:100%;border:1px solid #ddd;border-radius:6px;padding:6px}
    .pin img{max-width:100%;border-radius:8px;margin-top:6px;cursor:zoom-in}
    #dbg{position:fixed;left:8px;bottom:8px;color:#0f0;font:12px/1.2 monospace;z-index:9999;pointer-events:none;white-space:pre}
    .float-layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .float-card{
      position:absolute; min-width:200px; max-width:280px; pointer-events:auto;
      background:#fff; border:1px solid #ddd; border-radius:10px; box-shadow:0 8px 22px rgba(0,0,0,0.3);
      user-select:none;
    }
    .float-card header{display:flex; align-items:center; gap:8px; padding:6px 8px; border-bottom:1px solid #eee;
      background:#f6f7fb; border-radius:10px 10px 0 0; cursor:grab;}
    .float-card header:active{ cursor:grabbing; }
    .float-card header input{flex:1; min-width:0; border:1px solid #ddd; border-radius:6px; padding:4px 6px; font-size:13px; background:#fff;}
    .float-card .body{ padding:8px }
    .float-card .body textarea{ width:100%; border:1px solid #ddd; border-radius:6px; padding:6px; min-height:70px }
    .float-card .body img{ display:block; max-width:100%; border-radius:8px; margin-top:6px; cursor:zoom-in }
    .float-card .footer{ display:flex; gap:6px; padding:8px; border-top:1px solid #eee; flex-wrap:wrap; align-items:center }
    .float-card .btn{ padding:4px 8px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer; font-size:12px }
    .float-card .btn.warn{ color:#b00 }
    .float-card a.small { font-size:12px; color:#06c; text-decoration:none }
    .float-card a.small:hover { text-decoration:underline }
    .lines{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none }
    .lines line{ stroke:#fff; stroke-opacity:0.85; stroke-width:2; filter:drop-shadow(0 0 1px rgba(0,0,0,.7)); }
    .pill {font-size:12px;border:1px solid #ddd;border-radius:999px;padding:4px 8px;background:#fff;display:inline-flex;gap:6px;align-items:center}
    .pill input{margin:0}
    .pill.small{font-size:11px;padding:2px 6px}
    .save-ok{color:#0a0}.save-pending{color:#a60}.save-fail{color:#b00}

    /* ==== Editor Dock ==== */
    .dock{
      position:absolute; top:12px; right:12px; width:340px; max-height:80vh; overflow:auto;
      background:#ffffffea; backdrop-filter:saturate(1.2) blur(4px);
      border:1px solid #ddd; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35);
      z-index:8; /* ← ヘッダー(z=10)より下：被り防止 */
    }
    .dock header{
      display:flex; align-items:center; gap:8px; padding:8px 10px; border-bottom:1px solid #eee;
      position:sticky; top:0; background:#f6f7fb; border-radius:12px 12px 0 0;
    }
    .dock .tabs{ display:flex; gap:6px; flex-wrap:wrap }
    .dock .tabbtn{ padding:4px 10px; font-size:12px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:pointer; }
    .dock .tabbtn.active{ background:#eef; border-color:#cdd; }
    .dock .minbtn{ margin-left:auto; padding:4px 8px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer; font-size:12px }
    .dock .body{ padding:10px }
    .dock.collapsed .body{ display:none }
    .dock.collapsed header{ border-radius:12px }
    .tool-row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:8px }
    .tool-btn{ padding:6px 10px; border:1px solid #ddd; background:#fff; border-radius:8px; font-size:12px; cursor:pointer }
    .tool-btn.toggled{ background:#e8f0fe; border-color:#c7dafc }
    .tool-input{ display:flex; align-items:center; gap:8px; margin-bottom:8px }
    .tool-input input[type="range"]{ width:160px }

    /* ==== Modal (list/picker) ==== */
    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:50; }
    .modal{ width:840px; max-width:95vw; max-height:86vh; overflow:auto; background:#fff; border:1px solid #ddd; border-radius:12px; box-shadow:0 20px 40px rgba(0,0,0,0.4); }
    .modal header{ position:sticky; top:0; background:#f6f7fb; border-bottom:1px solid #eee; padding:10px 12px; display:flex; gap:8px; align-items:center }
    .modal .body{ padding:12px }
    .list{ border:1px solid #eee; border-radius:10px; overflow:hidden }
    .rowi{ display:grid; grid-template-columns: 1fr 200px 120px; gap:8px; padding:8px 10px; border-bottom:1px solid #f0f0f0; align-items:center }
    .rowi:last-child{ border-bottom:none }
    .rowi .name{ font-weight:600 }
    .rowi .meta{ font-size:12px; color:#666 }
    .modal footer{ padding:10px 12px; border-top:1px solid #eee; display:flex; gap:8px; justify-content:flex-end }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap:10px }
    .card{ border:1px solid #eee; border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:6px; }
    .card img{ width:100%; aspect-ratio: 1 / 1; object-fit:cover; border-radius:8px; background:#f3f3f3 }
    .card .title{ font-size:12px; line-height:1.4; }
    .card .meta{ font-size:11px; color:#666; }
    .card button{ padding:6px 8px; font-size:12px; }

    /* ==== Image Zoom Viewer ==== */
    
    /* ==== Sign-in Gate (mobile first) ==== */
.gate-overlay{
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.55); z-index:40;
}
.gate{
  background:#fff; border:1px solid #ddd; border-radius:14px; padding:16px 18px;
  width:min(92vw,420px); text-align:center; box-shadow:0 18px 40px rgba(0,0,0,.35);
}
.gate h3{ margin:0 0 8px; font-size:16px }
.gate p { margin:0 0 12px; color:#666; font-size:13px }
.gate .btn{ padding:10px 14px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:pointer; font-size:14px }
.hidden{ display:none }

/* FAB: モバイルでドックを開く小ボタン */

  #dockFab{ display:none; }

    
    .zoom-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.85); display:flex; align-items:center; justify-content:center; z-index:60; cursor:grab }
    .zoom-img{ max-width:none; max-height:none; transform-origin: 0 0; user-select:none; -webkit-user-drag:none; }
    .zoom-close{ position:fixed; top:12px; right:12px; z-index:61; padding:8px 10px; background:#fff; border:1px solid #ddd; border-radius:8px; cursor:pointer; }

    /* ==== Toolbar groups ==== */
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-start; width:100% }
    .hgroup{
      background:#fff; border:1px solid #e6e6e6; border-radius:12px; padding:8px 10px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .hgroup .title{ font-weight:600; font-size:12px; color:#444; padding:2px 8px; background:#f4f4f6; border:1px solid #e9e9ee; border-radius:999px }
    .hgroup input{ padding:6px 8px; border:1px solid #ddd; border-radius:8px; min-width:220px }
    .hgroup .tiny{ font-size:12px; color:#666 }
    .hgroup .iconbtn{ padding:4px 8px; font-size:12px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer }
    .hgroup .sep{ width:1px; height:20px; background:#eee; margin:0 2px }
    header .grow{ flex:1 }
    .header-utils{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    #pillAutosave { padding:2px 8px }
    #pillAutosave input { transform:scale(.95) }

    @media (max-width: 960px){
      main{ grid-template-columns: 1fr }
      aside{ display:none }
      .dock{ left:12px; right:12px; width:auto }
      .dock .tabbtn{ padding:6px 12px }
      .tool-btn{ padding:8px 12px }
    }
    
    /* === Mobile compact mode (≈15% 常時UI) === */
@media (max-width: 640px){
  /* ヘッダーはオートハイド用に固定配置 */
  header{ position: fixed; top:0; left:0; right:0; transform: translateY(0); transition: transform .25s; z-index: 10; }
  header.compact{ transform: translateY(-100%); }
  

  /* 1) ヘッダーは“初期から”隠す（必要時のみスワイプで表示） */
  header{ transform: translateY(-100%) !important; }

  /* 2) ミニバー：ボタンを丸型・小型化（高さ=約40px） */
  .mini-bar{
    padding: 4px 6px !important;
    gap: 6px !important;
    border-radius: 999px !important;
  }
  .mini-btn{
    width: 40px; height: 40px;
    padding: 0 !important; border-radius: 999px !important;
    font-size: 18px; line-height: 40px;
  }

  /* 3) FAB：丸型アイコン化（テキスト非表示） */
  #dockFab{ display:none; }
  /* アイコンは疑似要素で表示 */
  

  /* 4) 保存ステータスのピル：さらに小型に */
  #pillAutosave{
    padding: 2px 6px !important;
    font-size: 11px; gap: 6px;
  }
  #pillAutosave input{ transform: scale(.9); }

  /* 5) ボトムシート（dock）は開いた時のみ可視。高さは最大 40–45vh */
  .dock{
    max-height: min(40vh, 380px) !important;
    box-shadow: 0 16px 40px rgba(0,0,0,.35);
  }

  /* 6) フロートカード類のフォント/パディングを気持ち小さく */
  .float-card{ font-size: 13px; }
  .float-card header{ padding: 6px 8px; }
  .float-card .body{ padding: 8px; }
  .float-card .footer{ padding: 8px; gap: 6px; }
  .float-card .btn{ padding: 4px 8px; font-size: 12px; }

/* ヘッダー再表示のトランジションは既存を利用 */

  /* レイアウトを viewer 全画面化 */
  main{ grid-template-columns: 1fr }
  aside{ display:none }
  #view{ height: 100dvh; }

  /* 右下の FAB（既存）を使ってボトムシートを開閉 */
  #dockFab{ display:none; }

  /* 保存ステータスのピルを右上に固定 */
  #pillAutosave{
    position: fixed; right:12px; top:12px; z-index:9;
    background:#ffffffea; backdrop-filter: blur(4px);
    border:1px solid #ddd; border-radius:999px; padding:2px 8px;
  }

  /* 左下のミニツールバー（常時表示はココだけ+FAB） */
  .mini-bar{
    position:fixed; left:12px; bottom:14px; z-index:9; display:flex; gap:8px;
    background:#ffffffea; backdrop-filter:blur(4px);
    border:1px solid #ddd; border-radius:999px; padding:6px 8px;
  }
  .mini-btn{ border:0; background:transparent; padding:6px; border-radius:10px; }
  .mini-btn:active{ background:#efefef }

  /* 既存の .dock を “ボトムシート” に */
  .dock{
    position: fixed; left:0; right:0; bottom:0; top:auto;
    width:auto; max-height:min(45vh, 420px); overflow:auto;
    border-radius:16px 16px 0 0; margin:0 0 env(safe-area-inset-bottom,0) 0;
    display:none; /* 初期は閉 */
  }
  .dock.collapsed{ display:none } /* 明示的に閉 */
}

/* ボトムシートのグラブハンドル */
.dock::before{
  content:""; display:block; width:44px; height:4px; border-radius:999px;
  background:#d0d0d0; margin:8px auto;
}

/* 画面の下の安全域（iPhoneのホームバーなど）をよける */
.float-layer { padding-bottom: env(safe-area-inset-bottom, 0); }

/* カードが小画面でも読みやすい幅に */
.float-card { max-width: min(92vw, 320px); }


    
  
/* === Added: Desktop open-dock button (top-right) === */
#btnOpenDock_hidden{ min-width:40px; min-height:40px; outline:1px solid transparent; outline-offset:2px;
  position:fixed; top:12px; right:12px; z-index:11;
  padding:8px 12px; border:1px solid #ddd; border-radius:10px; background:#fff; cursor:pointer; font-size:13px;
  box-shadow:0 8px 20px rgba(0,0,0,.15);
}
@media (max-width: 960px){ #btnOpenDock_hidden{ min-width:40px; min-height:40px; outline:1px solid transparent; outline-offset:2px; display:none } } /* hide on mobile */
#btnOpenDock_hidden:hover{ outline-color:#ddd }

/* === Added: Mobile sheet style for caption card === */
.float-card.sheet{
  position:fixed !important; left:0 !important; right:0 !important; bottom:0 !important; top:auto !important;
  margin:0; width:auto !important; max-height:min(48vh, 460px); overflow:auto;
  border-radius:16px 16px 0 0;
}
.float-card header .grab-handle{
  width:42px; height:4px; border-radius:999px; background:#d0d0d0; margin-right:8px; flex:0 0 auto;
}
@media (max-width: 640px){
  .float-card header .close-btn{ font-size:14px; padding:6px 8px }
}

/* === Added: Make the card header an obvious drag area on mobile === */
@media (max-width: 640px){
  .float-card header{ cursor:grab; user-select:none }
  .float-card header:active{ cursor:grabbing }
}

/* === Added: Ensure close button is visible and aligned === */
.float-card header .close-btn{
  border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer; padding:4px 8px; font-size:12px;
}

/* === Added: Fix caption tab text overflow inside dock === */
#tab-camera .tool-input textarea, #tab-materials textarea{
  max-width:100%; box-sizing:border-box;
}

/* === Added: Center loader overlay === */
#loaderOverlay{
  position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:1000;
  background:rgba(0,0,0,.45);
}
#loaderOverlay.active{ display:flex }
.spinner{
  width:56px; height:56px; border-radius:50%;
  border:4px solid rgba(255,255,255,.35); border-top-color:#fff;
  animation:spin 1s linear infinite;
}
@keyframes spin{ to{ transform:rotate(360deg) } }

/* === Added: Dock visibility helpers === */
.d-none{ display:none !important }


/* tabs: aria-selected 表示 */
.dock .tabbtn[aria-selected="true"]{
  background:#eef; border-color:#cdd; text-decoration:underline;
}

/* === Caption Bottom Sheet === */
.cap-sheet{
  position:fixed; left:0; right:0; bottom:0; z-index:60;
  background:#fff; border-radius:16px 16px 0 0; box-shadow:0 -10px 30px rgba(0,0,0,.35);
  transform:translateY(110%); transition:transform .24s ease, opacity .12s ease; opacity:0;
  max-height:92vh;
}
.cap-sheet[open]{ opacity:1; transform:translateY(0) }
.cap-sheet[data-snap="peek"]{ transform:translateY(calc(100% - 28vh)); }
.cap-sheet[data-snap="half"]{ transform:translateY(calc(100% - 50vh)); }
.cap-sheet[data-snap="full"]{ transform:translateY(0); }
.cap-handle{ height:28px; display:flex; align-items:center; justify-content:center; cursor:grab; touch-action:none; }
.cap-handle::before{ content:""; width:44px; height:4px; border-radius:999px; background:#d0d0d0; box-shadow:inset 0 -1px 0 #c7c7c7; }
.cap-header{ display:flex; gap:8px; align-items:center; padding:6px 12px; border-bottom:1px solid #eee; cursor:grab; user-select:none }
.cap-title{ flex:1; font-weight:600 }
.cap-close{ padding:8px 10px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer }
.cap-body{ padding:10px 12px; overflow:auto; max-height:calc(92vh - 28px - 44px - env(safe-area-inset-bottom,0)); }
.cap-row{ display:flex; gap:8px; align-items:center; margin-bottom:10px; flex-wrap:wrap }
.cap-sheet input[type="text"], .cap-sheet textarea{ width:100%; border:1px solid #ddd; border-radius:8px; padding:8px; background:#fff; color:#222; box-sizing:border-box }
.cap-sheet textarea{ min-height:96px; max-height:calc(8lh + 12px); overflow:auto }
@media (max-width: 960px){
  /* Dockはモバイルでは基本使わない（FAB→シート遷移を想定） */
  #btnOpenDock_hidden{ display:none }
}


/* === Workspace inline tool button (PC) === */
.tool-inline-btn{
  position:absolute; right:12px; top:12px; z-index:6;
  padding:8px 12px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:pointer;
  box-shadow:0 8px 24px rgba(0,0,0,.25);
  min-width:40px; min-height:40px; outline:1px solid transparent; outline-offset:2px;
}
.tool-inline-btn:hover{ outline-color:#ddd }
#dock[data-open="true"] ~ main #view .tool-inline-btn{ display:none } /* Dock openなら隠す */

/* === Mobile load FAB & sheet === */
.load-fab{
  position:fixed; left:14px; bottom:14px; z-index:9; display:none;
  padding:12px 16px; border:1px solid #ddd; border-radius:999px; background:#fff; box-shadow:0 12px 28px rgba(0,0,0,.35); cursor:pointer;
}
@media (max-width: 960px){
  .load-fab{ display:block }
}

/* reuse .sheet styles already present */
.load-sheet .title{ font-weight:600 }
.load-sheet .row{ display:flex; gap:8px; align-items:center; margin-bottom:10px; flex-wrap:wrap }
.load-sheet input{ width:100%; border:1px solid #ddd; border-radius:8px; padding:8px }

#toolFab{ display:none }
@media (max-width: 960px){
  #toolFab{ display:block }
}

@media (max-width: 960px){
  #dockFab{ display:block; position:fixed; right:14px; bottom:14px; padding:12px 16px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
}
</style>
</head>
<body>
<!-- Desktop open-dock button (hidden on mobile) -->
<!-- Global loader overlay -->
<div aria-hidden="true" id="loaderOverlay">
<div style="display:flex;flex-direction:column;align-items:center;gap:10px">
<div aria-label="読み込み中" class="spinner" role="progressbar"></div>
<div id="loadingMsg" style="color:#fff">GLBを読み込み中…</div>
<div class="progress" style="width:min(360px,80vw);height:4px;background:rgba(255,255,255,.25);border-radius:9999px;overflow:hidden">
<i id="loadingBar" style="display:block;height:100%;width:0%;background:#fff;transition:width .2s ease"></i>
</div>
</div>
<div aria-label="読み込み中" class="spinner" role="progressbar"></div>
</div>
<header>
<div class="toolbar">
<!-- 📦 モデル -->
<div class="hgroup" id="grpModel">
<span class="title">モデル</span>
<input autocomplete="off" id="fileId" placeholder="GLBの fileId または 共有リンク"/>
<button class="iconbtn" id="btnLoad">読み込む</button>
<button class="iconbtn" id="helpModel" title="対応形式など">？</button>
<span class="tiny" id="status">未サインイン</span>
</div>
<!-- 📍 キャプション -->
<div class="hgroup" id="grpPins">
<span class="title">キャプション</span>
<input autocomplete="off" id="pinsId" placeholder="（任意）pins.json の fileId / 共有リンク"/>
<button class="iconbtn" id="btnPickPins">選択…</button>
<button class="iconbtn" id="btnClearPins">クリア</button>
<span class="sep"></span>
<span class="tiny">Save FolderId:</span>
<input autocomplete="off" id="folderId" placeholder="（任意）保存先フォルダID"/>
<button class="iconbtn" id="helpPins" title="pins.jsonの説明">？</button>
</div>
<!-- 🔑 共有・権限 -->
<div class="hgroup" id="grpShare">
<span class="title">共有・権限</span>
<button class="iconbtn" id="btnAuth">Googleにサインイン</button>
<div class="pill" id="pillAutosave" title="pins.json を自動保存">
<label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;">
<input checked="" id="autoSave" type="checkbox"/> 🧷オートセーブ
        </label>
<span class="muted" id="saveStatus">待機中</span>
</div>
<div class="sep"></div>
<div class="pill"><button id="btnCopyReadonlyUrl" title="閲覧専用URLをコピー">閲覧専用URLをコピー</button></div>
<div class="pill"><span class="muted">GLB:</span><button id="btnToggleGlbPublic" title="公開/限定を切替（デフォルトは限定）">限定</button></div>
<div class="pill"><span class="muted">pins:</span><button disabled="" id="btnTogglePinsPublic" title="公開/限定を切替（デフォルトは限定）">限定</button></div>
</div>
<div class="grow"></div>
<!-- 右端ユーティリティ -->
<div class="header-utils">
<a class="iconbtn" href="./docs/museum3dviewer_user_guide.pdf" id="btnGuidePdf" rel="noopener" target="_blank">使い方ガイド（PDF）</a>
<span class="tiny">v1.22.0-bg</span>
</div>
</div>
</header>
<!-- Mini toolbar (mobile) -->
<div class="mini-bar" id="miniBar" style="display:none">
<button class="mini-btn" id="miniLoad" title="読み込み">🗂</button>
<button class="mini-btn" id="miniPin" title="ピン追加">📍</button>
<button class="mini-btn" id="miniShare" title="共有">🔗</button>
</div>
<main>
<div id="view">
  <button id="toolInlineBtn" class="tool-inline-btn" aria-label="ツール">ツール</button>
<canvas id="canvas"></canvas>
<svg class="lines" id="lines"></svg>
<div class="float-layer" id="floatLayer"></div>
<!-- サインインゲート（必要なときだけ表示） -->
<div class="gate-overlay hidden" id="signinGateWrap">
<div class="gate">
<h3>Googleにサインイン</h3>
<p>Driveの読み書きが必要です。ボタンを押して開始してください。</p>
<button class="btn" id="btnGateSignIn">サインインして続行</button>
</div>
</div>
<!-- モバイル用：ドック表示トグル -->
<button aria-label="ツールを開く" id="dockFab" title="ツール">ツール</button>
<!-- 編集ドック -->
<div class="dock" id="editorDock">
<header>
<div class="tabs">
<button class="tabbtn" data-tab="materials">マテリアル</button>
<button class="tabbtn" data-tab="camera">カメラ</button>
</div>
<button class="minbtn" id="dockClose">閉じる</button>
</header>
<div class="body">
<div class="tool-row">
<button class="tool-btn toggled" id="axisX">X</button>
<button class="tool-btn toggled" id="axisY">Y</button>
<button class="tool-btn toggled" id="axisZ">Z</button>
</div>
<div class="muted">G：ギズモ切替 / X,Y,Z：軸表示 / Esc：ポップアップ閉じ</div>
</div>
<div id="tab-materials" style="display:none">
<div class="muted" style="margin-bottom:6px">3Dスキャン前提。必要最低限の調整のみ。</div>
<div id="materialsDock"></div>
</div>
<div id="tab-camera" style="display:none">
<div class="tool-row">
<label class="pill" style="gap:10px">
<span>投影:</span>
<select id="projMode">
<option value="persp">透視投影</option>
<option value="ortho">平行投影</option>
</select>
</label>
<button class="tool-btn" id="btnFrame">モデルにフィット</button>
</div>
<div class="tool-input" id="rowFov">
<span class="muted" style="width:70px">視野角</span>
<input id="fov" max="90" min="25" step="1" type="range"/>
<span class="muted" id="fovVal"></span>
</div>
<div class="tool-input" id="rowZoom" style="display:none">
<span class="muted" style="width:70px">ズーム</span>
<input id="zoom" max="3" min="0.5" step="0.01" type="range" value="1"/>
<span class="muted" id="zoomVal">1.00</span>
</div>
<div class="tool-row">
<span class="muted" style="width:70px">ビュー</span>
<button class="tool-btn" data-view="front">前</button>
<button class="tool-btn" data-view="back">後</button>
<button class="tool-btn" data-view="left">左</button>
<button class="tool-btn" data-view="right">右</button>
<button class="tool-btn" data-view="top">上</button>
<button class="tool-btn" data-view="bottom">下</button>
</div>
<div class="tool-row">
<label class="pill" style="gap:10px">
<span>背景:</span>
<select id="bgMode">
<option selected="" value="dark">暗</option>
<option value="light">明</option>
</select>
</label>
<label class="pill" style="gap:10px">
<span>背景色</span>
<input id="bgColor" type="color" value="#222222"/>
</label>
</div>
<div class="tool-row">
<label class="pill" style="gap:10px">
<input id="touchMode" type="checkbox"/> タッチUIを使う
            </label>
</div>
<div class="muted" id="touchHelp"></div>
</div>
</div>
</div>

<aside>
<div class="sec">
<div class="muted" id="hintDesktop" style="margin-top:6px">
        Shift+クリック = ピン追加 / 左=回転 / 右=パン / ホイール=ズーム<br/>
        ピンをクリック → ポップアップを<strong>複数</strong>開けます（Ctrl+クリック＝このピンだけ残す）<br/>
        Escで全ポップアップ閉、移動モードOFFでギズモ非表示
      </div>
<div class="muted hidden" id="hintTouch" style="margin-top:6px">
        1本指=回転 / 2本指=パン / ピンチ=ズーム / <b>長押し</b>=ピン追加<br/>
        ピンをタップ → ポップアップを複数開けます（長押しで位置追加）
      </div>
<div class="warn muted" id="scopeWarn" style="display:none;margin-top:6px">
        書き込み権限不足。上の「Googleにサインイン」から再同意、または「ピンをDriveに保存」を押してください。
      </div>
</div>
<div class="sec">
<div class="row" id="pinActions">
<button disabled="" id="btnUndo">元に戻す (Ctrl+Z)</button>
<button disabled="" id="btnRedo">やり直す (Ctrl+Shift+Z)</button>
<button id="btnSavePins">ピンをDriveに保存（リネーム）</button>
<button id="btnAddPin">ピン追加（画面中央）</button>
<label class="pill" id="pillMove" title="Gキーでも切替"><input id="moveMode" type="checkbox"/> 移動モード（ギズモ）</label>
</div>
<strong>ピン一覧（クリックで編集） <span class="badge" id="pinCount">ピン: 0</span></strong>
<div id="pins"></div>
<div class="muted" id="pinsInfo" style="margin-top:6px"></div>
</div>
</aside>
</main>
<button aria-label="モデル読み込み" class="load-fab" id="loadFab">読み込み</button>
<section aria-hidden="true" aria-label="モデル読み込み" aria-modal="true" class="sheet load-sheet" hidden="" id="loadSheet" role="dialog">
<div class="handle" id="loadHandle" title="ドラッグしてサイズ変更"></div>
<header class="load-header">
<div class="title">モデル読み込み</div>
<button class="close" id="loadClose">閉じる</button>
</header>
<div class="body">
<div class="row"><input id="loadInput" placeholder="URL または Google DriveのfileID" type="text"/></div>
<div class="row">
<button id="loadStart">読み込む</button>
</div>
<p class="hint">URLを貼り付けるか、fileIDのみでもOK（例: 1AbC... → https://drive.google.com/uc?id=1AbC... に変換）</p>
</div>
</section>
<!-- Caption Bottom Sheet (mobile first) -->
<section aria-hidden="true" aria-label="キャプション" aria-modal="true" class="cap-sheet" hidden="" id="capSheet" role="dialog">
<div class="cap-handle" title="ドラッグしてサイズ変更"></div>
<header class="cap-header">
<div class="cap-title">キャプション</div>
<button class="cap-close" id="capClose">閉じる</button>
</header>
<div class="cap-body">
<div class="cap-row"><input id="capTitle" placeholder="タイトル" type="text"/></div>
<div class="cap-row"><textarea id="capText" placeholder="本文（最大8行）"></textarea></div>
<div class="cap-row">
<label>色 <input id="capColor" type="color" value="#ee3333"/></label>
<button id="capPickImage">画像を選ぶ</button>
</div>
<div class="cap-row" hidden="" id="capImageRow">
<img alt="" id="capImage" style="max-width:100%; border-radius:10px;"/>
</div>
</div>
</section>
<div id="dbg"></div>
<div class="hidden" id="modalRoot"></div>
<script type="module">
'use strict';
console.log('drive_three_pins v1.22.0-bg');


/* === Loader helpers === */
function showLoader(msg){ const ol=document.getElementById('loaderOverlay'); if(!ol) return; ol.classList.add('active'); const m=document.getElementById('loadingMsg'); if(m) m.textContent = msg||'読み込み中…'; const bar=document.getElementById('loadingBar'); if(bar) bar.style.width='8%'; }
function hideLoader(){ const ol=document.getElementById('loaderOverlay'); if(!ol) return; ol.classList.remove('active'); const bar=document.getElementById('loadingBar'); if(bar) bar.style.width='0%'; }

function setLoadingProgress(p,msg){ const bar=document.getElementById('loadingBar'); if(bar){ bar.style.width = Math.max(8, Math.min(100, Math.round(p*100))) + '%'; } const m=document.getElementById('loadingMsg'); if(m&&msg) m.textContent = msg; }
/* === Dock visibility helpers (desktop button logic) === */
function openDock(){
  dock.classList.remove('collapsed');
  dock.style.display = 'block';
  dock.setAttribute('data-open','true');
  dock.setAttribute('aria-hidden','false');
  const inlineBtn = document.getElementById('toolInlineBtn');
  if (inlineBtn){ inlineBtn.style.display='none'; }
}
function closeDock(){
  dock.classList.add('collapsed');
  dock.style.display = 'none';
  dock.setAttribute('data-open','false');
  dock.setAttribute('aria-hidden','true');
  const inlineBtn = document.getElementById('toolInlineBtn'); if (inlineBtn){ inlineBtn.style.display=''; }
}
/* ===== Config: OAuth / Drive ===== */
const SCOPES_READ  = "https://www.googleapis.com/auth/drive.readonly";
const SCOPES_WRITE = "https://www.googleapis.com/auth/drive.file";
const SCOPES_FULL  = "https://www.googleapis.com/auth/drive";
const ALL_SCOPES   = `${SCOPES_READ} ${SCOPES_WRITE} ${SCOPES_FULL}`;
const CLIENT_ID    = "595200751510-ncahnf7edci6b9925becn5to49r6cguv.apps.googleusercontent.com";

/* ===== DOM ===== */
const canvas       = document.getElementById('canvas');
const view         = document.getElementById('view');
const statusEl     = document.getElementById('status');
const dbg          = document.getElementById('dbg');
const linesSvg     = document.getElementById('lines');
const floatLayer   = document.getElementById('floatLayer');
const pinsEl       = document.getElementById('pins');
const pinCountEl   = document.getElementById('pinCount');
const pinsInfoEl   = document.getElementById('pinsInfo');
const scopeWarnEl  = document.getElementById('scopeWarn');
const autoSaveEl   = document.getElementById('autoSave');
const saveStatusEl = document.getElementById('saveStatus');
const btnAuth      = document.getElementById('btnAuth');
const btnLoad      = document.getElementById('btnLoad');
const btnSavePins  = document.getElementById('btnSavePins');
const btnAddPin    = document.getElementById('btnAddPin');
const moveModeEl   = document.getElementById('moveMode');
const pillMove     = document.getElementById('pillMove');
const pillAutosave = document.getElementById('pillAutosave');
const fileIdInput  = document.getElementById('fileId');
const pinsIdInput  = document.getElementById('pinsId');
const folderIdInput= document.getElementById('folderId');
const btnPickPins  = document.getElementById('btnPickPins');
const btnClearPins = document.getElementById('btnClearPins');
const btnCopyReadonlyUrl = document.getElementById('btnCopyReadonlyUrl');
const btnToggleGlbPublic = document.getElementById('btnToggleGlbPublic');
const btnTogglePinsPublic= document.getElementById('btnTogglePinsPublic');
const btnHelpModel = document.getElementById('helpModel');
const btnHelpPins  = document.getElementById('helpPins');

/* Gate & FAB */
const signinGateWrap = document.getElementById('signinGateWrap');
const btnGateSignIn  = document.getElementById('btnGateSignIn');
const dockFab        = document.getElementById('dockFab');

/* 端末判定（モバイル寄り） */
const IS_MOBILE = window.matchMedia('(max-width: 640px), (pointer: coarse)').matches;



/* Driveの共有URLでもIDでもOK */
function extractDriveId(v=''){
  if(!v) return '';
  v = String(v).trim();
  const m1 = v.match(/https?:\/\/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]{10,})/);
  if (m1) return m1[1];
  const m2 = v.match(/https?:\/\/drive\.google\.com\/open\?id=([a-zA-Z0-9_-]{10,})/);
  if (m2) return m2[1];
  const m3 = v.match(/[a-zA-Z0-9_-]{10,}/);
  return m3 ? m3[0] : '';
}
['fileId','pinsId'].forEach(id=>{
  const el = document.getElementById(id);
  el.addEventListener('blur', ()=>{ el.value = extractDriveId(el.value) || ''; });
  el.addEventListener('paste', (e)=>{
    const txt = (e.clipboardData || window.clipboardData).getData('text');
    const id = extractDriveId(txt);
    if (id){ e.preventDefault(); el.value = id; }
  });
});
fileIdInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') btnLoad.click(); });

/* Dock */
const dock = document.getElementById('editorDock');
const dockClose = document.getElementById('dockClose');
const materialsDockEl = document.getElementById('materialsDock');
const tabButtons = dock.querySelectorAll('.tabbtn');
tabButtons.forEach((b,i)=>b.setAttribute('aria-selected', i===0 ? 'true' : 'false'));
const tabMaterials = document.getElementById('tab-materials');
tabButtons.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    tabButtons.forEach(b=>b.setAttribute('aria-selected', b===btn ? 'true' : 'false'));
  });
});
const tabCamera = document.getElementById('tab-camera');
const dockMin = null;

/* Camera tab controls */
const projModeSel = document.getElementById('projMode');
const fovRange = document.getElementById('fov');
const fovVal = document.getElementById('fovVal');
const zoomRange = document.getElementById('zoom');
const zoomVal = document.getElementById('zoomVal');
const btnFrame = document.getElementById('btnFrame');
const bgModeSel = document.getElementById('bgMode');
const bgColorEl = document.getElementById('bgColor');

/* Touch UI */
const touchModeEl = document.getElementById('touchMode');
const hintDesktop = document.getElementById('hintDesktop');
const hintTouch = document.getElementById('hintTouch');
const touchHelp = document.getElementById('touchHelp');

const modalRoot    = document.getElementById('modalRoot');

/* ===== State ===== */
let READ_ONLY = false;

const pinMap = new Map();
let selectedPinId = '';

let PINS = [];
let MATERIALS = {};
const materialList = [];
const materialCache = new Map();

let loadedPinsId = '';
let autosaveId   = '';
let loadedPinsName = '';
let autosaveName   = 'pins.json';

// Camera
let camera, cameraPersp, cameraOrtho, controls, gizmo, labelRenderer;
let cameraMode = 'persp';
let fitMaxDim = 1, fitDist = 3;

// Touch UI
let TOUCH_MODE = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
const DOCK_MIN_KEY = 'editorDock_min';

/* ===== Local mapping for autosave pins.json ===== */
const MAP_KEY = 'pinsMap_v1';
function loadMap(){ try{ return JSON.parse(localStorage.getItem(MAP_KEY)||'{}') }catch{ return {} } }
function saveMap(m){ localStorage.setItem(MAP_KEY, JSON.stringify(m)) }
function rememberAutosave(glbId, id){ const m=loadMap(); m[glbId]=id; saveMap(m); }


/* ===== gapi / GSI ===== */
function showSignInGate() {
  signinGateWrap.classList.remove('hidden');
  statusEl.textContent = 'サインインが必要です';
}
function hideSignInGate() {
  signinGateWrap.classList.add('hidden');
}

/* gapi ローダ：既に読み込まれていれば待つだけに変更 */
async function loadGapi(){
  if (window.gapiLoaded) return;
  await new Promise((resolve) => {
    if (window.gapi) return resolve();
    const t = setInterval(()=>{ if (window.gapi){ clearInterval(t); resolve(); } }, 30);
  });
  await new Promise((res)=> gapi.load('client', res));
  await gapi.client.init({ discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"] });
  window.gapiLoaded = true;
}
/* 起動直後に裏で初期化（ユーザー操作をブロックしない） */
(async ()=>{ try{ await loadGapi(); }catch(e){} })();

let accessToken = null;
let accessTokenExpiresAt = 0;
let tokenRefreshing = null;

/* クリック“直下”でだけ使う：初回トークン取得（ポップアップブロック回避） */
function requestTokenInteractive(scopes = ALL_SCOPES) {
  return new Promise((resolve, reject) => {
    try {
      if (!window.google?.accounts?.oauth2) {
        reject(new Error('GSIがまだ読み込まれていません'));
        return;
      }
      const client = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: scopes,
        prompt: '',
        callback: (resp) => {
          if (!resp?.access_token) { reject(new Error('access_tokenなし')); return; }
          accessToken = resp.access_token;
          const ttlMs = Math.max(60_000, (Number(resp.expires_in) || 3600) * 1000);
          accessTokenExpiresAt = Date.now() + ttlMs;
          resolve(resp);
        }
      });
      client.requestAccessToken(); // ← クリック同一ハンドラ内で即発火
    } catch (e) { reject(e); }
  });
}

/* 以後の更新/401リトライ用（ユーザー操作外でも通る想定） */
async function ensureToken() {
  const now = Date.now();
  if (accessToken && accessTokenExpiresAt - 30_000 > now) return;
  if (tokenRefreshing) { await tokenRefreshing; return; }

  tokenRefreshing = new Promise((resolve, reject)=>{
    try{
      if (!window.google?.accounts?.oauth2) throw new Error('GSI未ロード');
      const client = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: ALL_SCOPES,
        prompt: '',
        callback: (resp)=>{
          try{
            if (!resp?.access_token) throw new Error('トークンが返らない');
            accessToken = resp.access_token;
            const ttl = (resp.expires_in ? Number(resp.expires_in) : 3600) * 1000;
            accessTokenExpiresAt = Date.now() + Math.max(60_000, ttl);
            resolve();
          }catch(e){ reject(e); }
        }
      });
      client.requestAccessToken();
    }catch(e){ reject(e); }
  });

  try{ await tokenRefreshing; } finally { tokenRefreshing = null; }
}

/* 未サインインならゲート表示＆中断。既に有効なら true を返す */
async function ensureSignedInIfNeeded() {
  if (accessToken && (accessTokenExpiresAt - 30_000 > Date.now())) {
    scopeWarnEl.style.display = 'none';
    statusEl.textContent = 'サインイン済み';
    return true;
  }
  statusEl.textContent = '未サインイン（公開ファイルのみ閲覧可）';
  showSignInGate();
  return false;
}

/* ===== Drive helpers ===== */
/* すべて accessToken（ensureToken 経由）と gapi.client.drive を利用 */

async function gapiReady(){
  // 新しい loadGapi は「gapiが居たら待つだけ」なので呼べば安全
  if (!window.gapiLoaded) { try{ await loadGapi(); }catch(e){} }
}

async function driveFetchBinary(fileId){
  await ensureToken();
  const res = await fetch(`https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?alt=media`, {
    headers: { Authorization: `Bearer ${accessToken}` }
  });
  if (!res.ok) throw new Error(`driveFetchBinary failed: ${res.status}`);
  return await res.blob();
}

async function driveGetMetadata(fileId, fields='id,name,parents,capabilities,permissions,driveId,modifiedTime,owners'){
  await gapiReady();
  const r = await gapi.client.drive.files.get({ fileId, fields });
  return r.result || {};
}

async function driveListFiles({ q='', pageSize=100, orderBy='modifiedTime desc', fields }={}){
  await gapiReady();
  const r = await gapi.client.drive.files.list({
    q, pageSize, orderBy,
    fields: fields || "files(id,name,mimeType,modifiedTime,parents,thumbnailLink),nextPageToken"
  });
  return r.result || { files:[] };
}

/* multipart アップロード（新規作成） */
async function driveCreateFile({ name, mimeType='application/octet-stream', parents=[], dataBlob }){
  await ensureToken();
  const meta = { name, mimeType, parents };
  const boundary = '----drivehelper_' + Math.random().toString(36).slice(2);
  const body = new Blob([
    `--${boundary}\r\n`,
    'Content-Type: application/json; charset=UTF-8\r\n\r\n',
    JSON.stringify(meta), '\r\n',
    `--${boundary}\r\n`,
    `Content-Type: ${mimeType}\r\n\r\n`,
    dataBlob, '\r\n',
    `--${boundary}--`
  ], { type: `multipart/related; boundary=${boundary}` });

  const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
    method: 'POST',
    headers: { Authorization: `Bearer ${accessToken}` },
    body
  });
  if (!res.ok) throw new Error(`driveCreateFile failed: ${res.status}`);
  return await res.json();
}

/* multipart アップロード（内容＋名前の更新） */
async function driveUpdateFile({ fileId, name, mimeType='application/octet-stream', dataBlob }){
  await ensureToken();
  const meta = { name, mimeType };
  const boundary = '----drivehelper_' + Math.random().toString(36).slice(2);
  const body = new Blob([
    `--${boundary}\r\n`,
    'Content-Type: application/json; charset=UTF-8\r\n\r\n',
    JSON.stringify(meta), '\r\n',
    `--${boundary}\r\n`,
    `Content-Type: ${mimeType}\r\n\r\n`,
    dataBlob, '\r\n',
    `--${boundary}--`
  ], { type: `multipart/related; boundary=${boundary}` });

  const res = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${encodeURIComponent(fileId)}?uploadType=multipart`, {
    method: 'PATCH',
    headers: { Authorization: `Bearer ${accessToken}` },
    body
  });
  if (!res.ok) throw new Error(`driveUpdateFile failed: ${res.status}`);
  return await res.json();
}

/* 共有：公開状態の取得 */
async function driveIsPublic(fileId){
  await gapiReady();
  const r = await gapi.client.drive.permissions.list({ fileId, fields: "permissions(id,type,role)" });
  const perms = r.result?.permissions || [];
  return perms.some(p => p.type === 'anyone' && (p.role === 'reader' || p.role === 'writer' || p.role === 'commenter'));
}

/* 共有：公開/限定を切り替え */
async function driveSetPublic(fileId, isPublic){
  await gapiReady();
  if (isPublic){
    await gapi.client.drive.permissions.create({
      fileId,
      resource: { type: 'anyone', role: 'reader' }
    });
  } else {
    const r = await gapi.client.drive.permissions.list({ fileId, fields: "permissions(id,type)" });
    const any = (r.result?.permissions||[]).find(p => p.type === 'anyone');
    if (any){
      await gapi.client.drive.permissions.delete({ fileId, permissionId: any.id });
    }
  }
}



/* ===== Three.js ===== */
import * as THREE from 'https://esm.sh/three@0.152.2';
import { OrbitControls } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://esm.sh/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { CSS2DRenderer as ThreeCSS2DRenderer } from 'https://esm.sh/three@0.152.2/examples/jsm/renderers/CSS2DRenderer.js';
import { TransformControls as ThreeTransformControls } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/TransformControls.js';

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.max(1, window.devicePixelRatio || 1));
renderer.setSize(view.clientWidth, view.clientHeight);
const scene = new THREE.Scene();
scene.background = null;

function makePerspective(){
  const aspect = view.clientWidth / view.clientHeight;
  const c = new THREE.PerspectiveCamera(60, aspect, 0.01, 2000);
  return c;
}
function makeOrtho(frustumHeight){
  const aspect = view.clientWidth / view.clientHeight;
  const h = frustumHeight || (fitMaxDim*2.2);
  const w = h * aspect;
  const c = new THREE.OrthographicCamera(-w/2, w/2, h/2, -h/2, 0.01, 2000);
  c.zoom = 1; c.updateProjectionMatrix(); return c;
}

cameraPersp = makePerspective();
camera = cameraPersp;
camera.position.set(0, 1, 3);

controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = true;
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
controls.target.set(0, 0, 0);

scene.add(new THREE.AmbientLight(0xffffff, 1.0));
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3, 5, 2); scene.add(dir);

labelRenderer = new ThreeCSS2DRenderer();
labelRenderer.setSize(view.clientWidth, view.clientHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.top = '0';
labelRenderer.domElement.style.left = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
view.appendChild(labelRenderer.domElement);

function updateCameraAspect(){
  const aspect = view.clientWidth / view.clientHeight;
  if (cameraMode==='persp'){
    camera.aspect = aspect;
  } else {
    const h = fitMaxDim*2.2, w = h * aspect;
    camera.left = -w/2; camera.right = w/2; camera.top = h/2; camera.bottom = -h/2;
  }
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', ()=>{
  renderer.setSize(view.clientWidth, view.clientHeight);
  labelRenderer.setSize(view.clientWidth, view.clientHeight);
  updateCameraAspect();
});

// 向き/サイズが変わったら、全部のカードを画面内に戻す
window.addEventListener('resize', ()=>{
  for (const {floatDom} of pinMap.values()){
    if (floatDom) clampCardToViewport(floatDom);
  }
});
window.addEventListener('orientationchange', ()=>{
  setTimeout(()=>{
    for (const {floatDom} of pinMap.values()){
      if (floatDom) clampCardToViewport(floatDom);
    }
  }, 50);
});

/* ===== 背景 ===== */
function applyBackgroundMode(mode){
  const col = mode==='light' ? '#f2f2f2' : '#222';
  view.style.background = col;
  renderer.setClearAlpha(0);
  scene.background = null;
}
function applyBackgroundColor(hex){
  if (!hex) return;
  view.style.background = hex;
  renderer.setClearAlpha(0);
  scene.background = null;
}

/* ===== リーダーライン ===== */
function updateLeaderLines(){
  for (const [id, rec] of pinMap){
    if (!rec.floatDom || !rec.lineEl) continue;
    const world = rec.node.getWorldPosition(new THREE.Vector3());
    const v = world.clone().project(camera);
    const w=view.clientWidth, h=view.clientHeight;
    const sx = (v.x * 0.5 + 0.5) * w;
    const sy = (-v.y * 0.5 + 0.5) * h;
    const cr = rec.floatDom.getBoundingClientRect();
    const vr = view.getBoundingClientRect();
    const cx = (cr.left - vr.left) + Math.min(16, cr.width*0.2);
    const cy = (cr.top  - vr.top ) + Math.min(16, cr.height*0.2);
    rec.lineEl.setAttribute('x1', sx.toFixed(1));
    rec.lineEl.setAttribute('y1', sy.toFixed(1));
    rec.lineEl.setAttribute('x2', cx.toFixed(1));
    rec.lineEl.setAttribute('y2', cy.toFixed(1));
  }
}
function tick(){
  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
  updateLeaderLines();
  requestAnimationFrame(tick);
}
tick();
document.getElementById('toolInlineBtn')?.addEventListener('click', openDock);


/* === Mobile: model load sheet === */
const loadFab = document.getElementById('loadFab');
const loadSheet = document.getElementById('loadSheet');
const loadHandle = document.getElementById('loadHandle');
const loadClose = document.getElementById('loadClose');
const loadInput = document.getElementById('loadInput');
const loadStart = document.getElementById('loadStart');

function openLoadSheet(){
  loadSheet.dataset.snap = 'half';
  loadSheet.hidden = false;
  loadSheet.setAttribute('open','');
  loadSheet.setAttribute('aria-hidden','false');
  setTimeout(()=> loadInput?.focus(), 50);
}
function closeLoadSheet(){
  loadSheet.removeAttribute('open');
  loadSheet.setAttribute('aria-hidden','true');
  setTimeout(()=>{ loadSheet.hidden = true; }, 160);
}

loadFab?.addEventListener('click', openLoadSheet);
loadClose?.addEventListener('click', closeLoadSheet);

// drag (reuse caption logic style: handle only)
(function(){
  let startY=0, startSnap='half', dragging=false;
  const order = ['peek','half','full'];
  function next(dir){ let i=order.indexOf(startSnap); i=Math.max(0,Math.min(order.length-1,i-dir)); return order[i]; }
  function onDown(ev){ dragging=true; startY = ev.touches? ev.touches[0].clientY : ev.clientY; startSnap = loadSheet.dataset.snap||'half'; ev.preventDefault(); }
  function onMove(ev){ if(!dragging) return; const y=ev.touches? ev.touches[0].clientY : ev.clientY; const dy=y-startY; const dir=(dy<-10)?-1:((dy>10)?+1:0); if(dir){ loadSheet.dataset.snap = next(dir); } }
  function onUp(ev){ if(!dragging) return; dragging=false; const endY = ev.changedTouches? ev.changedTouches[0].clientY : ev.clientY; if((loadSheet.dataset.snap||'peek')==='peek' && endY-startY>80){ closeLoadSheet(); } }
  loadHandle?.addEventListener('mousedown', onDown); loadHandle?.addEventListener('touchstart', onDown, {passive:false});
  window.addEventListener('mousemove', onMove, {passive:false}); window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('mouseup', onUp); window.addEventListener('touchend', onUp);
})();

function toLoadUrl(val){
  const s = (val||'').trim();
  if (!s) return '';
  if (s.includes('://')) return s;
  // treat as Google Drive fileId
  return 'https://drive.google.com/uc?id=' + encodeURIComponent(s);
}

loadStart?.addEventListener('click', ()=>{
  const url = toLoadUrl(loadInput?.value||'');
  if(!url){ alert('URLかfileIDを入力してください'); return; }
  // メッセージ更新＆読み込み開始
  if (typeof showLoading === 'function') showLoading('GLBを読み込み中…');
  (async ()=>{
    try{
      await loadModel(url);
    }catch(e){
      console.error(e);
      alert('読み込みに失敗しました');
    }finally{
      if (typeof hideLoading === 'function') hideLoading();
      closeLoadSheet();
    }
  })();
});

try{ dockClose?.addEventListener('click', closeDock); }catch(e){}

/* ===== カメラ補間 ===== */
function animateCameraTo({ fromPos, toPos, fromTarget, toTarget, duration=400, ease=(t)=>t }){
  const start = performance.now();
  function step(){
    const now = performance.now();
    const t = Math.min(1, (now - start) / duration);
    const k = ease(t);
    camera.position.lerpVectors(fromPos, toPos, k);
    controls.target.lerpVectors(fromTarget, toTarget, k);
    camera.updateProjectionMatrix?.();
    controls.update();
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* ===== GLB 読み込み ===== */
let gltfRoot = null;
const pinsGroup = new THREE.Group(); scene.add(pinsGroup);

function frameToObject(){
  if (!gltfRoot) return;
  const box = new THREE.Box3().setFromObject(gltfRoot);
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  gltfRoot.position.sub(center);
  fitMaxDim = Math.max(size.x, size.y, size.z) || 1;
  fitDist = fitMaxDim * 1.8 / Math.tan(THREE.MathUtils.degToRad((camera.fov||60)/2));
  camera.position.set(0, fitMaxDim*0.6, fitDist);
  controls.target.set(0, 0, 0); controls.update();
  cameraOrtho = makeOrtho(fitMaxDim*2.2);
  cameraOrtho.position.copy(camera.position);
  cameraOrtho.lookAt(controls.target);
  updateCameraAspect();
}
async function loadGLBFromDrive(fileId){
  const blob = await driveFetchBinary(fileId);
  const url  = URL.createObjectURL(blob);
  if (gltfRoot) {
    scene.remove(gltfRoot);
    gltfRoot.traverse(o=>{
      if(o.geometry) o.geometry.dispose();
      if(o.material){
        const mats = Array.isArray(o.material)? o.material : [o.material];
        mats.forEach(m=>{
          if (m.map && m.map.dispose) m.map.dispose();
          if (m.dispose) m.dispose();
        });
      }
    });
    gltfRoot = null;
    materialList.length = 0;
    materialCache.clear();
    materialsDockEl.innerHTML = '';
  }
  const loader = new GLTFLoader();
  await new Promise((resolve, reject)=>{
    loader.load(url, (gltf)=>{
      gltfRoot = gltf.scene; scene.add(gltfRoot);
      frameToObject();
      collectMaterials(gltfRoot);
      buildMaterialsUI(materialsDockEl);
      URL.revokeObjectURL(url);
      resolve();
    }, undefined, reject);
  });
}

/* ===== ピン ===== */
const safePos = a => (Array.isArray(a)&&a.length>=3)?a.map(n=>Number(n)||0):[0,0,0];

function pinColorOf(pin){ return (pin && pin.color) ? String(pin.color) : '#ee3333'; }

// ★追加：ピンの基本の透明度（お好みで 0.55〜0.75 推奨）
const PIN_BASE_OPACITY = 0.65;

// ★新しい makePinSprite（ピンを半透明にする）
function makePinSprite(color = '#ee3333', opacity = PIN_BASE_OPACITY){
  const size = 64, cvs = document.createElement('canvas'); cvs.width=cvs.height=size;
  const ctx = cvs.getContext('2d');
  // 外側白リング
  ctx.beginPath(); ctx.arc(size/2,size/2,size*0.28,0,Math.PI*2);
  ctx.fillStyle='#fff'; ctx.fill();
  // 中の色ドット
  ctx.beginPath(); ctx.arc(size/2,size/2,size*0.22,0,Math.PI*2);
  ctx.fillStyle=color; ctx.fill();
  // 縁
  ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2; ctx.stroke();

  const tex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({
    map: tex,
    depthTest: true,
    depthWrite: false,
    transparent: true,
    opacity
  });
  const spr = new THREE.Sprite(mat);
  spr.scale.set(0.022,0.022,0.022);
  return spr;
}


function updatePinSpriteColor(id){
  const rec = pinMap.get(id); if (!rec) return;
  const pin = PINS.find(p=>p.id===id);
  const col = pinColorOf(pin);
  const currentOpacity = rec.sprite?.material?.opacity ?? PIN_BASE_OPACITY;

  // 新しい色で絵を作り直す（透明度はそのまま）
  const tex = makePinSprite(col, currentOpacity).material.map;
  rec.sprite.material.map.dispose?.();
  rec.sprite.material.map = tex;
  rec.sprite.material.needsUpdate = true;
}

// === 光る輪っか（使い回し用）
let highlightRingTexture = null;
function getHighlightRingTexture(){
  if (highlightRingTexture) return highlightRingTexture;
  const size = 128, cvs = document.createElement('canvas'); cvs.width=cvs.height=size;
  const ctx = cvs.getContext('2d');
  const g = ctx.createRadialGradient(size/2,size/2,size*0.25, size/2,size/2,size*0.48);
  g.addColorStop(0.00, 'rgba(0,128,255,0.00)');
  g.addColorStop(0.60, 'rgba(0,128,255,0.35)');
  g.addColorStop(0.90, 'rgba(0,128,255,0.00)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(size/2,size/2,size*0.48,0,Math.PI*2); ctx.fill();
  highlightRingTexture = new THREE.CanvasTexture(cvs);
  return highlightRingTexture;
}

// === ピンを一時的に強調（光る輪っか + 少し大きく）
function highlightPin(pinId, duration = 1000){
  const rec = pinMap.get(pinId); if (!rec) return;
  const sprite = rec.sprite;

  const ringMat = new THREE.SpriteMaterial({
    map: getHighlightRingTexture(),
    transparent: true,
    depthTest: false,
    depthWrite: false,
    opacity: 0.0
  });
  const ring = new THREE.Sprite(ringMat);
  ring.scale.set(0.06, 0.06, 0.06);
  rec.node.add(ring);

  const baseScale = sprite.scale.clone();
  const baseOpacity = sprite.material.opacity ?? PIN_BASE_OPACITY;

  const start = performance.now();
  function step(){
    const t = Math.min(1, (performance.now() - start) / duration);
    const k = t < 0.5 ? (2*t*t) : (1 - Math.pow(-2*t + 2, 2)/2); // なめらかに

    // 輪っかは前半明るく→後半消える
    ring.material.opacity = (t < 0.5 ? t*2 : (1 - t)*2) * 0.9;

    // ピンは少し大きく＆少しハッキリ
    const s = 1 + 0.45 * k;
    sprite.scale.set(baseScale.x*s, baseScale.y*s, baseScale.z*s);
    sprite.material.opacity = baseOpacity + (1.0 - baseOpacity) * Math.min(1, k*1.1);

    if (t < 1){ requestAnimationFrame(step); }
    else {
      sprite.scale.copy(baseScale);
      sprite.material.opacity = baseOpacity;
      rec.node.remove(ring);
      ring.material.map.dispose?.();
      ring.material.dispose?.();
    }
  }
  requestAnimationFrame(step);
}



/* 画像ノード作成（HEICはpreviewにフォールバック） */
function makePictureNode(pin) {
  if (!pin.imageUrl && !pin.imageDriveId) return null;
  const mime = pin.imageMime || '';
  const previewUrl = pin.imageDriveId ? `https://drive.google.com/file/d/${pin.imageDriveId}/preview` : '';
  if (mime.includes('heic') || mime.includes('heif')) {
    const iframe = document.createElement('iframe');
    iframe.src = previewUrl || pin.imageUrl; iframe.width = '100%'; iframe.height = '240'; iframe.style.border = 'none'; iframe.loading = 'lazy';
    return iframe;
  }
  const img = document.createElement('img');
  img.src = pin.imageUrl || previewUrl; img.alt = '';
  img.addEventListener('click', ()=> openImageViewer(img.src));
  return img;
}

/* ピン一覧描画 */
function redrawPins(){
  detachGizmo();
  while(pinsGroup.children.length) pinsGroup.remove(pinsGroup.children[0]);
  for (const {floatDom, lineEl} of pinMap.values()){
    floatDom?.parentNode?.removeChild(floatDom);
    lineEl?.parentNode?.removeChild(lineEl);
  }
  pinMap.clear();

  for (const p of PINS) {
    const v = safePos(p.position);
    const node = new THREE.Object3D(); node.position.set(v[0],v[1],v[2]); pinsGroup.add(node);
    const sprite = makePinSprite(pinColorOf(p)); sprite.userData.pinId=p.id; node.add(sprite);
    pinMap.set(p.id, { node, sprite, floatDom:null, lineEl:null });
  }

  pinsEl.innerHTML=''; pinCountEl.textContent=`ピン: ${PINS.length}`;
  for (const pin of PINS) {
    const wrap=document.createElement('details'); wrap.className='pin';
    const hid=`file_${pin.id}`;
    const driveLink = pin.imageDriveId ? `https://drive.google.com/file/d/${pin.imageDriveId}/view?usp=drive_link` : '';
    wrap.innerHTML = `
      <summary data-summary="${pin.id}">${pin.title||'（無題）'} <span class="muted">@ ${safePos(pin.position).map(n=>Number(n).toFixed(3)).join(', ')}</span></summary>
      <div class="row"><input data-k="title" placeholder="タイトル" value="${pin.title||''}" ${READ_ONLY?'disabled':''} autocomplete="off"></div>
      <div class="row"><textarea data-k="text" rows="3" placeholder="キャプション" ${READ_ONLY?'disabled':''}>${pin.text||''}</textarea></div>
      <div class="row"><label class="pill small">色 <input type="color" data-k="color" value="${pin.color||'#ee3333'}" ${READ_ONLY?'disabled':''}></label></div>
      ${READ_ONLY?'':`<input id="${hid}" class="hidden" type="file" accept="image/*">`}
      <div class="row">
        ${READ_ONLY?'':`<button data-act="choose">ローカルから</button>
        <button data-act="pickDrive">フォルダから選ぶ</button>`}
        ${pin.imageUrl||pin.imageDriveId?'<div class="pic-holder" data-pic="'+pin.id+'"></div>':''}
        ${driveLink?`<a class="small" href="${driveLink}" target="_blank" rel="noopener">元画像を開く ↗</a>`:''}
        ${pin.imageDriveId?`<button data-act="copyPrev" title="Driveの埋め込み用URLをコピー">コピー：プレビューURL</button>
        <button data-act="togglePub" title="公開/限定を切替">公開↔限定</button>`:''}
      </div>
      <div class="row">
        <button data-act="center">このピンへ移動</button>
        <button data-act="toggle">ポップアップ</button>
        ${READ_ONLY?'':`<button data-act="remove" class="warn">削除</button>`}
      </div>`;
    if (!READ_ONLY){
      wrap.addEventListener('input',(e)=>{
        const t=e.target;
        if(t.dataset.k==='title'){ pin.title=t.value; updateListPositionSummary(pin.id); scheduleAutoSave(); }
        if(t.dataset.k==='text'){ pin.text=t.value; scheduleAutoSave(); }
        if(t.dataset.k==='color'){ pin.color=t.value; updatePinSpriteColor(pin.id); scheduleAutoSave(); }
      });
    }
    wrap.querySelector('[data-act="center"]').onclick = ()=> centerToPin(pin);
    wrap.querySelector('[data-act="toggle"]').onclick = ()=> togglePinPopup(pin.id);
    if (!READ_ONLY){
      wrap.querySelector('[data-act="remove"]')?.addEventListener('click', ()=>{
        const selId = selectedPinId;
        PINS=PINS.filter(p=>p.id!==pin.id); 
        redrawPins(); 
        scheduleAutoSave();
        if (selId===pin.id) detachGizmo();
      });

      const fileInput = wrap.querySelector('#'+hid);
      wrap.querySelector('[data-act="choose"]')?.addEventListener('click', ()=> fileInput.click());
      fileInput && (fileInput.onchange = async ()=>{
        if (!fileInput.files || !fileInput.files[0]) return;
        await uploadAndAttachImage(fileInput.files[0], pin);
      });
      wrap.querySelector('[data-act="pickDrive"]')?.addEventListener('click', ()=> chooseDriveImageForPin(pin));
    }
    wrap.querySelector('[data-act="copyPrev"]')?.addEventListener('click', ()=>{
      if (!pin.imageDriveId) return;
      copyText(`https://drive.google.com/file/d/${pin.imageDriveId}/preview`, 'プレビューURLをコピーしました');
    });
    wrap.querySelector('[data-act="togglePub"]')?.addEventListener('click', async ()=>{
      try{
        await ensureToken();
        const isPub = await driveIsPublic(pin.imageDriveId);
        await driveSetPublic(pin.imageDriveId, !isPub);
        alert(`画像を ${!isPub?'公開（リンクを知っている全員が閲覧可）':'限定'} にしました`);
      }catch(e){ await explainShareError(pin.imageDriveId, e); }
    });
    pinsEl.appendChild(wrap);
    const holder = wrap.querySelector('.pic-holder');
    if (holder) {
      const node = makePictureNode(pin);
      if (node) holder.appendChild(node);
      // D&D（このピンにドロップで画像差し替え）
      if (!READ_ONLY){
        holder.addEventListener('dragover', (ev)=>{ ev.preventDefault(); holder.style.outline='2px dashed #09f'; });
        holder.addEventListener('dragleave', ()=>{ holder.style.outline=''; });
        holder.addEventListener('drop', async (ev)=>{
          ev.preventDefault(); holder.style.outline='';
          const f = ev.dataTransfer.files?.[0];
          if (f && f.type.startsWith('image/')) await uploadAndAttachImage(f, pin);
        });
      }
    }
  }
}
function updateListPositionSummary(id){
  const rec = pinMap.get(id); if(!rec) return;
  const p = rec.node.position;
  const summary = document.querySelector(`summary[data-summary="${id}"]`);
  if (summary) {
    const title = (PINS.find(x=>x.id===id)?.title)||'（無題）';
    summary.innerHTML = `${title} <span class="muted">@ ${[p.x,p.y,p.z].map(n=>n.toFixed(3)).join(', ')}</span>`;
  }
}

/* centerToPin */

function centerToPin(pin){
  const v = safePos(pin.position);
  const target = new THREE.Vector3(v[0], v[1], v[2]);
  const currentPos = camera.position.clone();
  const currentTarget = controls.target.clone();
  const currentDir = currentPos.clone().sub(currentTarget);
  const ideal = Math.max(0.2, fitMaxDim * 0.3);
  const dir = currentDir.normalize();
  const nextPos = target.clone().addScaledVector(dir, ideal);

  animateCameraTo({
    fromPos: currentPos,
    toPos: nextPos,
    fromTarget: currentTarget,
    toTarget: target,
    duration: 380,
    ease: t => 1 - Math.pow(1 - t, 3),
  });

  // ★追加：移動と同時にピンを光らせる（1秒）
  const p = PINS.find(p=>p.id===pin.id);
  if (p) highlightPin(p.id, 1000);
    if (!pinMap.get(pin.id)?.floatDom) togglePinPopup(pin.id);
  clampCardToViewport(pinMap.get(pin.id)?.floatDom);
  
  

}


/* ===== ポップアップ ===== */
function projectToScreen(vec3){
  const v = vec3.clone().project(camera);
  const w = view.clientWidth, h = view.clientHeight;
  return { x: (v.x * 0.5 + 0.5) * w, y: (-v.y * 0.5 + 0.5) * h };
}

// 画面からはみ出さないように、カード位置を直す
function clampCardToViewport(card){
  const vw = view.clientWidth, vh = view.clientHeight;
  const r  = card.getBoundingClientRect();
  const vr = view.getBoundingClientRect();
  const W = r.width, H = r.height;
  const M = 10; // 余白
  // iPhoneの下の安全域（CSSのenv()ぶん）
  const safeBottom = parseInt(getComputedStyle(floatLayer).paddingBottom) || 0;

  // 現在の left/top を取り出し（px→数値）
  let L = parseFloat(card.style.left||'0');
  let T = parseFloat(card.style.top ||'0');

  // 収まるように補正
  L = Math.max(M, Math.min(vw - W - M, L));
  T = Math.max(M, Math.min(vh - H - M - safeBottom, T));

  card.style.left = L + 'px';
  card.style.top  = T + 'px';
}


function closeAllPopups(){
  for (const [id, rec] of pinMap){
    rec.floatDom?.parentNode?.removeChild(rec.floatDom);
    rec.floatDom = null;
    rec.lineEl?.parentNode?.removeChild(rec.lineEl);
    rec.lineEl = null;
  }
  detachGizmo();
}
function closePinPopup(id){
  const rec = pinMap.get(id); if(!rec) return;
  rec.floatDom?.parentNode?.removeChild(rec.floatDom);
  rec.floatDom = null;
  rec.lineEl?.parentNode?.removeChild(rec.lineEl);
  rec.lineEl = null;
  if (selectedPinId === id) detachGizmo();
}

function makeFloatCard(pinId){
  const pin = PINS.find(p=>p.id===pinId); if(!pin) return null;
  const card = document.createElement('div'); card.className='float-card'; card.style.left='0px'; card.style.top='0px';
  const hdr = document.createElement('header');
  const title = document.createElement('input'); title.placeholder='タイトル'; title.value = pin.title||''; if (READ_ONLY) title.disabled = true;
  const btnClose = document.createElement('button'); btnClose.textContent='閉じる'; btnClose.className='btn close-btn';
  hdr.appendChild(title); hdr.appendChild(btnClose);
  const body = document.createElement('div'); body.className='body';
  const ta = document.createElement('textarea'); ta.placeholder='キャプション'; ta.value = pin.text||''; if (READ_ONLY) ta.disabled = true;
  body.appendChild(ta);
  // 色
  const row = document.createElement('div'); row.className='row';
  const colorLabel = document.createElement('label'); colorLabel.className='pill small'; colorLabel.textContent='色 ';
  const colorInput = document.createElement('input'); colorInput.type='color'; colorInput.value = pin.color || '#ee3333'; if (READ_ONLY) colorInput.disabled = true;
  colorLabel.appendChild(colorInput); body.appendChild(row); row.appendChild(colorLabel);

  if (pin.imageUrl || pin.imageDriveId) {
    const pic = makePictureNode(pin);
    if (pic) body.appendChild(pic);
  }

  const ftr = document.createElement('div'); ftr.className='footer';
  const btnCenter = document.createElement('button'); btnCenter.className='btn'; btnCenter.textContent='ピンへ移動';
  const btnChoose = !READ_ONLY ? (()=>{ const b=document.createElement('button'); b.className='btn'; b.textContent='ローカルから'; return b; })() : null;
  const btnPickDrive = !READ_ONLY ? (()=>{ const b=document.createElement('button'); b.className='btn'; b.textContent='フォルダから選ぶ'; return b; })() : null;
  const driveLink = pin.imageDriveId ? `https://drive.google.com/file/d/${pin.imageDriveId}/view?usp=drive_link` : '';
  const previewLink = pin.imageDriveId ? `https://drive.google.com/file/d/${pin.imageDriveId}/preview` : '';
  if (driveLink){
    const a = document.createElement('a'); a.href = driveLink; a.target='_blank'; a.rel='noopener'; a.className='small'; a.textContent='元画像を開く ↗'; ftr.appendChild(a);
    const copyBtn = document.createElement('button'); copyBtn.className='btn'; copyBtn.textContent='コピー：プレビューURL';
    copyBtn.onclick = ()=> copyText(previewLink, 'プレビューURLをコピーしました');
    ftr.appendChild(copyBtn);
    const togBtn = document.createElement('button'); togBtn.className='btn'; togBtn.textContent='公開↔限定';
    togBtn.onclick = async ()=>{
      try{
        await ensureToken();
        const isPub = await driveIsPublic(pin.imageDriveId);
        await driveSetPublic(pin.imageDriveId, !isPub);
        alert(`画像を ${!isPub?'公開（リンクを知っている全員が閲覧可）':'限定'} にしました`);
      }catch(e){ await explainShareError(pin.imageDriveId, e); }
    };
    ftr.appendChild(togBtn);
  }
  ftr.appendChild(btnCenter);
  if (btnChoose) ftr.appendChild(btnChoose);
  if (btnPickDrive) ftr.appendChild(btnPickDrive);
  card.appendChild(hdr); card.appendChild(body); card.appendChild(ftr);

  if (!READ_ONLY){
    title.addEventListener('input', ()=>{ pin.title = title.value; scheduleAutoSave(); updateListPositionSummary(pinId); });
    ta.addEventListener('input', ()=>{ pin.text = ta.value; scheduleAutoSave(); });
    colorInput.addEventListener('input', ()=>{ pin.color = colorInput.value; updatePinSpriteColor(pinId); scheduleAutoSave(); });
    btnClose.onclick = ()=> closePinPopup(pinId);
    btnCenter.onclick = ()=> centerToPin(pin);
    btnChoose.onclick = ()=>{
      const input = document.createElement('input'); input.type='file'; input.accept='image/*';
      input.onchange = async ()=>{ if (!input.files || !input.files[0]) return; await uploadAndAttachImage(input.files[0], pin, {onAfter:()=>{
        const im = body.querySelector('img') || body.appendChild(document.createElement('img'));
        im.src = pin.imageUrl; im.onclick = ()=> openImageViewer(im.src);
      }}); };
      input.click();
    };
    btnPickDrive.onclick = ()=> chooseDriveImageForPin(pin, { onApplied: ()=>{
      const im = body.querySelector('img') || body.appendChild(document.createElement('img'));
      im.src = pin.imageUrl; im.onclick = ()=> openImageViewer(im.src);
    } });

    // D&D（カードへドロップで画像差し替え）
    body.addEventListener('dragover', (ev)=>{ ev.preventDefault(); card.style.boxShadow='0 0 0 2px #09f inset, 0 8px 22px rgba(0,0,0,0.3)'; });
    body.addEventListener('dragleave', ()=>{ card.style.boxShadow='0 8px 22px rgba(0,0,0,0.3)'; });
    body.addEventListener('drop', async (ev)=>{
      ev.preventDefault(); card.style.boxShadow='0 8px 22px rgba(0,0,0,0.3)';
      const f = ev.dataTransfer.files?.[0];
      if (f && f.type.startsWith('image/')) await uploadAndAttachImage(f, pin, {onAfter:()=>{
        const im = body.querySelector('img') || body.appendChild(document.createElement('img'));
        im.src = pin.imageUrl; im.onclick = ()=> openImageViewer(im.src);
      }});
    });
  } else {
    btnClose.onclick = ()=> closePinPopup(pinId);
    btnCenter.onclick = ()=> centerToPin(pin);
  }

  // ドラッグ移動
  let dragging=false, sx=0, sy=0, startL=0, startT=0;
  hdr.addEventListener('mousedown',(ev)=>{
    dragging=true; sx=ev.clientX; sy=ev.clientY;
    const rect = card.getBoundingClientRect();
    startL = rect.left - view.getBoundingClientRect().left;
    startT = rect.top  - view.getBoundingClientRect().top;
    ev.preventDefault();
  });
  window.addEventListener('mousemove',(ev)=>{
    if(!dragging) return;
    const dx = ev.clientX - sx, dy = ev.clientY - sy;
    let L = startL + dx, T = startT + dy;
    const vw=view.clientWidth, vh=view.clientHeight;
    const cr = card.getBoundingClientRect(); const cw=cr.width, ch=cr.height;
    L = Math.max(0, Math.min(vw - cw, L));
    T = Math.max(0, Math.min(vh - ch, T));
    card.style.left = L + 'px';
    card.style.top  = T + 'px';
    const p = PINS.find(p=>p.id===pinId); if(p) p.floatPos = { left:L, top:T };
    updateLeaderLines();
  });
  window.addEventListener('mouseup',()=>{ if(dragging){ dragging=false; 
  clampCardToViewport(card);
  if(!READ_ONLY) scheduleAutoSave(); } });

  return card;
}
function togglePinPopup(id){

  const rec = pinMap.get(id); if(!rec) return;
  if (rec.floatDom) { closePinPopup(id); return; }
  // Close others on mobile (single sheet behavior)
  if (IS_MOBILE){ closeAllPopups(); }

  const card = makeFloatCard(id);
  floatLayer.appendChild(card); rec.floatDom = card;

  // Mobile: turn the card into a bottom sheet
  if (IS_MOBILE){
    card.classList.add('sheet');
    // Ensure a visible grab handle exists
    const hdr = card.querySelector('header');
    if (hdr && !hdr.querySelector('.grab-handle')){
      const gh = document.createElement('div'); gh.className='grab-handle'; hdr.prepend(gh);
    }
    // Simple swipe-to-close on header drag (vertical)
    let tsY=0, dy=0;
    card.addEventListener('touchstart', (ev)=>{ tsY=ev.touches[0].clientY; dy=0; }, {passive:true});
    card.addEventListener('touchmove', (ev)=>{ dy = ev.touches[0].clientY - tsY; if (dy>0) card.style.transform=`translateY(${dy}px)`; }, {passive:true});
    card.addEventListener('touchend', ()=>{ if (dy>80){ closePinPopup(id); card.style.transform=''; } else { card.style.transform=''; } });
  } else {
    // Desktop: keep floating near the pin
    const pin = PINS.find(x=>x.id===id);
    const pWorld  = rec.node.position.clone();
    const sc      = projectToScreen(pWorld);
    const margin  = 14;
    const initLeft= Math.min(view.clientWidth - 240, Math.max(0, sc.x + margin));
    const initTop = Math.min(view.clientHeight - 160, Math.max(0, sc.y - 80));
    if (pin?.floatPos) { card.style.left = pin.floatPos.left+'px'; card.style.top = pin.floatPos.top+'px'; }
    else { card.style.left = initLeft+'px'; card.style.top = initTop+'px'; if (pin) pin.floatPos = { left:initLeft, top:initTop }; }
  }

  const line = document.createElementNS('http://www.w3.org/2000/svg','line');
  line.setAttribute('data-id', id); linesSvg.appendChild(line);
  rec.lineEl = line; updateLeaderLines();
  clampCardToViewport(card);
  
}


/* ===== Raycaster / クリック ===== */
const raycaster = new THREE.Raycaster(); const mouseNdc = new THREE.Vector2();
function addPinFromScreen(xClient, yClient){
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((xClient - rect.left)/rect.width)*2 - 1;
  const y = -((yClient - rect.top)/rect.height)*2 + 1;
  mouseNdc.set(x, y);
  let point=null;
  if (gltfRoot){ raycaster.setFromCamera(mouseNdc, camera); const hits = raycaster.intersectObject(gltfRoot, true); if (hits?.length) point = hits[0].point.clone(); }
  if (!point){ const planeY = controls.target.y; raycaster.setFromCamera(mouseNdc, camera); const dir = raycaster.ray.direction.clone(); const t = (planeY - raycaster.ray.origin.y) / dir.y; point = raycaster.ray.origin.clone().addScaledVector(dir, Math.max(t, 0.0)); }
  dbg.textContent = `hit= ${point.x.toFixed(3)}, ${point.y.toFixed(3)}, ${point.z.toFixed(3)}`;
  const pin = { id: crypto.randomUUID(), position:[point.x,point.y,point.z], title:'', text:'', imageDriveId:'', imageUrl:'', imageMime:'', floatPos:null, color:'#ee3333' };
  PINS.push(pin); redrawPins(); scheduleAutoSave(); selectPin(pin.id);
}
btnAddPin.onclick = ()=>{
  if (READ_ONLY) return;
  const rect = renderer.domElement.getBoundingClientRect();
  addPinFromScreen(rect.left+rect.width/2, rect.top+rect.height/2);
};
renderer.domElement.addEventListener('click',(ev)=>{
  if (!READ_ONLY && ev.shiftKey && !TOUCH_MODE) { addPinFromScreen(ev.clientX, ev.clientY); return; }
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
  const y = -((ev.clientY - rect.top)/rect.height)*2 + 1;
  mouseNdc.set(x, y); raycaster.setFromCamera(mouseNdc, camera);
  const sprites = []; for (const rec of pinMap.values()) sprites.push(rec.sprite);
  const hitsPins = raycaster.intersectObjects(sprites, true);
  if (hitsPins?.length) {
    const spr = hitsPins[0].object; const id = spr.userData.pinId;
    if (ev.ctrlKey || ev.metaKey) { for (const [pid] of pinMap) { if (pid !== id) closePinPopup(pid); } }
    togglePinPopup(id); selectPin(id);
  }
});

/* ===== ギズモ ===== */
gizmo = new ThreeTransformControls(camera, renderer.domElement);
gizmo.setMode('translate'); gizmo.size = 0.9; gizmo.visible = false; scene.add(gizmo);
gizmo.addEventListener('dragging-changed', (e)=>{ controls.enabled = !e.value; });
gizmo.addEventListener('objectChange', ()=>{
  if (!selectedPinId) return;
  const rec = pinMap.get(selectedPinId); if (!rec) return;
  const p = rec.node.position;
  const pin = PINS.find(pn=>pn.id===selectedPinId); if (pin){ pin.position = [p.x, p.y, p.z]; }
  updateListPositionSummary(selectedPinId); updateLeaderLines();
});
function selectPin(id){
  selectedPinId = id;
  const rec = pinMap.get(id);
  if (!rec) { detachGizmo(); return; }
  if (!READ_ONLY && moveModeEl.checked){ gizmo.attach(rec.node); gizmo.visible = true; }
  else { detachGizmo(); }
  syncDockMoveToggle();
}
function detachGizmo(){ gizmo.detach(); gizmo.visible = false; }
gizmo.addEventListener('mouseUp', ()=>{ scheduleAutoSave(); });
moveModeEl.onchange = ()=>{
  if (READ_ONLY) { moveModeEl.checked=false; detachGizmo(); return; }
  if (!moveModeEl.checked) detachGizmo();
  else if (selectedPinId){ const rec = pinMap.get(selectedPinId); if (rec){ gizmo.attach(rec.node); gizmo.visible = true; } }
  syncDockMoveToggle();
};
window.addEventListener('keydown',(e)=>{
  if (e.repeat) return;
  if (!READ_ONLY && (e.key==='g'||e.key==='G')){ moveModeEl.checked = !moveModeEl.checked; moveModeEl.onchange(); }
  else if (e.key==='Escape') { detachGizmo(); closeAllPopups(); if (!READ_ONLY) { moveModeEl.checked=false; syncDockMoveToggle(); } }
});

/* ===== Dock interactions ===== */
tabButtons.forEach(b=>{
  b.onclick = ()=>{
    tabButtons.forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    const tab = b.dataset.tab;
  // tabMove は削除
    tabMaterials.style.display = (tab==='materials')?'block':'none';
    tabCamera.style.display = (tab==='camera')?'block':'none';
  };
});

/* ===== Mobile UI: mini bar / bottom sheet / auto-hide header ===== */
const miniBar = document.getElementById('miniBar');
const miniLoad = document.getElementById('miniLoad');
const miniPin = document.getElementById('miniPin');
const miniShare = document.getElementById('miniShare');

function isMobile(){ return window.matchMedia('(max-width: 640px), (pointer: coarse)').matches; }
function showMiniBarIfMobile(){ miniBar.style.display = isMobile() ? 'flex' : 'none'; }
showMiniBarIfMobile();
window.addEventListener('resize', showMiniBarIfMobile);

/* ミニバーの動作（軽操作） */
miniLoad?.addEventListener('click', ()=>{
  // まずヘルプ（入力方法）→ すぐロードしたい場合は2度押しで btnLoad
  if (document.getElementById('helpModel')) btnHelpModel.click();
  else if (document.getElementById('btnLoad')) btnLoad.click();
});
miniPin?.addEventListener('click', ()=> btnAddPin?.click());
miniShare?.addEventListener('click', ()=> btnCopyReadonlyUrl?.click());

/* ボトムシート（dock）の開閉を FAB に一本化 */
const openSheet = ()=>{
  dock.classList.remove('collapsed');
  dock.style.display = 'block';
};
const closeSheet = ()=>{
  dock.classList.add('collapsed');
  dock.style.display = 'none';
};
dockFab?.addEventListener('click', ()=>{
  // mobile FAB

  if (dock.style.display === 'none' || dock.classList.contains('collapsed')) if (typeof openSheet==='function') openSheet();
  else if (typeof closeSheet==='function') closeSheet();
});
dock.addEventListener('click', (e)=>{
  /* noop: dockMin removed */ // 既存の「最小化」ボタンで閉じる
});

/* ページヘッダーのオートハイド（指を止めたら 1.5s で隠す） */
const pageHeader = document.querySelector('header');
let hideTimer=null;
function scheduleHideHeader(){
  if (!isMobile()) return;
  if (hideTimer) clearTimeout(hideTimer);
  hideTimer = setTimeout(()=> pageHeader.classList.add('compact'), 1500);
}
// 画面上端付近でヘッダー再表示
document.addEventListener('pointermove', (e)=>{
  if (!isMobile()) return;
  if (e.clientY < 24) pageHeader.classList.remove('compact');
  scheduleHideHeader();
  


});
document.addEventListener('pointerdown', scheduleHideHeader);
scheduleHideHeader();

// 初期状態でヘッダーを隠してスタート（モバイルのみ）
if (isMobile()) { pageHeader.classList.add('compact'); }

/* 目安のUI占有率（console 表示） */
function uiOccupancy(){
  const H = window.innerHeight;
  const headerVisible = !pageHeader.classList.contains('compact');
  const headerH = headerVisible ? pageHeader.offsetHeight : 0;
  const miniH = miniBar?.offsetHeight || 0;
  const fabH = document.getElementById('dockFab')?.offsetHeight || 0;
  const occ = ((headerH + miniH + fabH*0.5) / H) * 100; // FABは半分扱い
  console.log(`UI占有率 ≈ ${occ.toFixed(1)}%`);
}
window.addEventListener('resize', uiOccupancy);
setTimeout(uiOccupancy, 0);


function syncDockMoveToggle(){/* no-op: 移動タブ廃止に伴いUI同期を無効化 */ 
}
try{ document.getElementById('dockClose')?.addEventListener('click', closeDock); }catch(e){}
document.getElementById('toolInlineBtn')?.addEventListener('click', openDock);
/* ===== Camera tab ===== */
function setCameraMode(mode){
  cameraMode = mode;
  if (mode==='persp'){
    camera = cameraPersp;
    updateCameraAspect();
    fovRange.disabled = false;
    document.getElementById('rowFov').style.display = '';
    document.getElementById('rowZoom').style.display = 'none';
  } else {
    camera = cameraOrtho || makeOrtho(fitMaxDim*2.2);
    updateCameraAspect();
    fovRange.disabled = true;
    document.getElementById('rowFov').style.display = 'none';
    document.getElementById('rowZoom').style.display = '';
  }
  controls.object = camera;
  gizmo.camera = camera;
  controls.update();
}
projModeSel.onchange = ()=> setCameraMode(projModeSel.value);
fovRange.value = 60; fovVal.textContent = '60°';
fovRange.oninput = ()=>{
  const v = Number(fovRange.value)||60;
  fovVal.textContent = v+'°';
  if (cameraMode==='persp'){ camera.fov = v; camera.updateProjectionMatrix(); }
};
zoomRange.oninput = ()=>{
  const z = Number(zoomRange.value)||1;
  zoomVal.textContent = z.toFixed(2);
  if (cameraMode==='ortho'){ camera.zoom = z; camera.updateProjectionMatrix(); }
};
btnFrame.onclick = ()=> frameToObject();

/* === ビュー切替（修正版・水平＋指定回転）=== */
function setNamedView(name){
  const d = fitDist;
  const t = controls.target.clone();
  let base = new THREE.Vector3(0,0,d); // 正面基準

  // 基本方向
  switch(name){
    case 'front':  base.set( 0, 0,  d); break;
    case 'back':   base.set( 0, 0, -d); break;
    case 'left':   base.set( -d, 0,  0); break;
    case 'right':  base.set( d, 0,  0); break;
    case 'top':    base.set( 0,  d,  0); break;
    case 'bottom': base.set( 0, -d,  0); break;
  }

  // 鉛直軸まわりの回転（指定：前/後=+90°, 左/右=-90°）
  let rotDeg = 0;
  if (name==='front' || name==='back')  rotDeg =  +90;
  if (name==='left'  || name==='right') rotDeg =  -90;

  if (name!=='top' && name!=='bottom'){
    const r = THREE.MathUtils.degToRad(rotDeg);
    const c = Math.cos(r), s = Math.sin(r);
    const x = base.x * c + base.z * s;
    const z = -base.x * s + base.z * c;
    base.set(x, 0, z);            // 水平を維持（見下ろさない）
    camera.up.set(0,1,0);         // 上方向は常に世界Y
  }else{
    camera.up.set(0,1,0);
  }

  const toPos = t.clone().add(base.normalize().multiplyScalar(fitDist));
  animateCameraTo({
    fromPos: camera.position.clone(),
    toPos,
    fromTarget: controls.target.clone(),
    toTarget: t,
    duration: 320,
    ease: (k)=>1-Math.pow(1-k,3)
  });
}

// ボタン紐づけ
tabCamera.querySelectorAll('[data-view]').forEach(b=>{
  b.onclick = ()=> setNamedView(b.dataset.view);
});



/* 背景UI */
function syncBgUI(){
  applyBackgroundMode(bgModeSel.value || 'dark');
  applyBackgroundColor(bgColorEl.value || (bgModeSel.value==='light'?'#f2f2f2':'#222'));
}
bgModeSel.onchange = syncBgUI;
bgColorEl.oninput  = ()=> applyBackgroundColor(bgColorEl.value);

/* ===== Touch UI ===== */
function applyTouchUI(){
  touchModeEl.checked = TOUCH_MODE;
  hintDesktop.classList.toggle('hidden', TOUCH_MODE);
  hintTouch.classList.toggle('hidden', !TOUCH_MODE);
  touchHelp.textContent = TOUCH_MODE
    ? '1本指=回転 / 2本指=パン / ピンチ=ズーム / 長押しでピン追加'
    : 'Shift+クリックでピン追加 / マウス左=回転 / 右=パン / ホイール=ズーム';
}
touchModeEl.onchange = ()=>{ TOUCH_MODE = !!touchModeEl.checked; applyTouchUI(); };
applyTouchUI();

/* ===== Materials ===== */
function collectMaterials(root){
  const set = new Set();
  root.traverse(o=>{
    const mats = o.material ? (Array.isArray(o.material)? o.material : [o.material]) : null;
    if (!mats) return;
    mats.forEach(m=>{
      if (!set.has(m)) {
        set.add(m);
        const name = (m.name && m.name.trim()) || `Material_${materialList.length+1}`;
        materialList.push({ name, material: m });
        materialCache.set(m.uuid, { original: m.map || null, invertedCache: new Map() });
        const cfg = MATERIALS[name];
        if (cfg) applyMaterialConfig(m, cfg);
      }
    });
  });
}
function buildMaterialsUI(targetEl){
  targetEl.innerHTML='';
  if (!materialList.length){
    targetEl.innerHTML = `<div class="muted">GLBにマテリアルが見つかりませんでした。</div>`;
    return;
  }
  for (const {name, material} of materialList){
    const hasMap = !!material.map;
    const cfg = MATERIALS[name] || (MATERIALS[name]={ invert:false, opacity:material.opacity ?? 1, blackThreshold:0.05, doubleSided:false });

    const el=document.createElement('div'); el.className='mat';
    el.innerHTML = `
      <div class="name">${name}</div>
      <div class="row${hasMap?'':' disabled'}">
        <label><input type="checkbox" data-k="invert" ${cfg.invert&&hasMap?'checked':''} ${READ_ONLY?'disabled':''}> 色反転（黒を透過）</label>
        ${!hasMap?`<span class="muted">（テクスチャなし）</span>`:''}
      </div>
      <div class="row">
        <span class="muted">不透明度</span>
        <input type="range" data-k="opacity" min="0" max="1" step="0.01" value="${cfg.opacity}" ${READ_ONLY?'disabled':''}>
        <span class="muted" data-k="ov">${cfg.opacity.toFixed(2)}</span>
      </div>
      <div class="row${hasMap?'':' disabled'}">
        <span class="muted">黒しきい値</span>
        <input type="range" data-k="black" min="0" max="0.5" step="0.01" value="${cfg.blackThreshold}" ${READ_ONLY?'disabled':''}>
        <span class="muted" data-k="bv">${cfg.blackThreshold.toFixed(2)}</span>
      </div>
      <div class="row">
        <label><input type="checkbox" data-k="double" ${cfg.doubleSided?'checked':''} ${READ_ONLY?'disabled':''}> 両面表示（裏面も描画）</label>
      </div>
    `;

    if (!READ_ONLY){
      const chk = el.querySelector('input[data-k="invert"]');
      if (chk) chk.onchange = ()=>{ cfg.invert = chk.checked; applyMaterialConfig(material, cfg); scheduleAutoSave(); };
      const op = el.querySelector('input[data-k="opacity"]');
      const ov = el.querySelector('span[data-k="ov"]');
      op.oninput = ()=>{ cfg.opacity = Number(op.value); ov.textContent = cfg.opacity.toFixed(2); applyMaterialConfig(material, cfg); };
      op.onchange = ()=>{ scheduleAutoSave(); };
      const bt = el.querySelector('input[data-k="black"]');
      const bv = el.querySelector('span[data-k="bv"]');
      if (bt){ bt.oninput = ()=>{ cfg.blackThreshold = Number(bt.value); bv.textContent = cfg.blackThreshold.toFixed(2); if (cfg.invert) applyMaterialConfig(material, cfg); }; bt.onchange=()=>{ scheduleAutoSave(); }; }
      const db = el.querySelector('input[data-k="double"]');
      db.onchange = ()=>{ cfg.doubleSided = db.checked; applyMaterialConfig(material, cfg); scheduleAutoSave(); };
    }
    targetEl.appendChild(el);
  }
}
function applyMaterialConfig(mat, cfg){
  mat.opacity = (cfg.opacity!=null)? cfg.opacity : 1;
  mat.transparent = mat.opacity < 1 || cfg.invert;
  mat.side = cfg.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
  if (cfg.invert && mat.map){
    const cache = materialCache.get(mat.uuid);
    if (cache && cache.original==null) cache.original = mat.map;
    const tex = getInvertedTexture(mat, cfg.blackThreshold || 0.05);
    mat.map = tex;
    mat.alphaTest = Math.min(0.49, (cfg.blackThreshold||0.05)/1.2);
    mat.needsUpdate = true;
  } else {
    const cache = materialCache.get(mat.uuid);
    if (cache && cache.original){
      mat.map = cache.original;
      mat.alphaTest = 0;
      mat.needsUpdate = true;
    }
  }
}
function getInvertedTexture(mat, threshold){
  const cache = materialCache.get(mat.uuid);
  if (cache){
    const key = Number(threshold).toFixed(2);
    const hit = cache.invertedCache.get(key);
    if (hit) return hit;
  }
  const src = (materialCache.get(mat.uuid)?.original) || mat.map;
  const image = src?.image;
  if (!image) return src;
  const w = image.videoWidth || image.naturalWidth || image.width;
  const h = image.videoHeight || image.naturalHeight || image.height;
  const cvs = document.createElement('canvas'); cvs.width = w; cvs.height = h;
  const ctx = cvs.getContext('2d');
  try{ ctx.drawImage(image, 0, 0, w, h); }
  catch(e){ console.warn('テクスチャの描画に失敗（CORSの可能性）。元のテクスチャを使用します。', e); return src; }
  const img = ctx.getImageData(0,0,w,h);
  const d = img.data;
  const thr = Math.round(threshold * 255);
  for (let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
    const y = (r+g+b)/3|0;
    const inv = 255 - y;
    d[i]=d[i+1]=d[i+2]=inv;
    d[i+3] = (inv <= thr) ? 0 : a;
  }
  ctx.putImageData(img,0,0);
  const tex = new THREE.CanvasTexture(cvs);
  tex.flipY = src.flipY;
  tex.wrapS = src.wrapS; tex.wrapT = src.wrapT;
  tex.repeat.copy(src.repeat); tex.offset.copy(src.offset);
  if (src.center) tex.center.copy(src.center);
  tex.rotation = src.rotation || 0;
  if (cache){
    const key = Number(threshold).toFixed(2);
    cache.invertedCache.set(key, tex);
  }
  return tex;
}

/* ===== Undo / Redo（最低限） ===== */
let UNDO_STACK = [];
let REDO_STACK = [];
const MAX_HISTORY = 50;
function snapshotState(){ return JSON.parse(JSON.stringify({ PINS, MATERIALS })); }
function restoreState(snap, {silent=false}={}){
  if (!snap) return;
  closeAllPopups(); detachGizmo();
  PINS = Array.isArray(snap.PINS) ? snap.PINS : [];
  MATERIALS = (snap.MATERIALS && typeof snap.MATERIALS==='object') ? snap.MATERIALS : {};
  redrawPins();
  for (const {name, material} of materialList){ const cfg = MATERIALS[name]; if (cfg) applyMaterialConfig(material, cfg); }
  buildMaterialsUI(materialsDockEl);
  lastSavedJson = JSON.stringify({pins:PINS,materials:MATERIALS});
  if (!silent){ setSaveStatus('pending','変更あり（Undo/Redo）'); scheduleAutoSave(); }
  updateUndoRedoButtons();
}
function recordChange(){ try{ UNDO_STACK.push(snapshotState()); if (UNDO_STACK.length > MAX_HISTORY) UNDO_STACK.shift(); REDO_STACK.length = 0; updateUndoRedoButtons(); }catch(e){} }
function canUndo(){ return UNDO_STACK.length > 0; }
function canRedo(){ return REDO_STACK.length > 0; }
function doUndo(){ if (!canUndo()) return; REDO_STACK.push(snapshotState()); const prev = UNDO_STACK.pop(); restoreState(prev); updateUndoRedoButtons(); }
function doRedo(){ if (!canRedo()) return; UNDO_STACK.push(snapshotState()); const next = REDO_STACK.pop(); restoreState(next); updateUndoRedoButtons(); }
function updateUndoRedoButtons(){
  const u = document.getElementById('btnUndo');
  const r = document.getElementById('btnRedo');
  if (u) u.disabled = !canUndo();
  if (r) r.disabled = !canRedo();
}
function resetHistoryBaseline(){ UNDO_STACK.length = 0; REDO_STACK.length = 0; UNDO_STACK.push(snapshotState()); updateUndoRedoButtons(); }
document.getElementById('btnUndo')?.addEventListener('click', doUndo);
document.getElementById('btnRedo')?.addEventListener('click', doRedo);
window.addEventListener('keydown', (e)=>{
  const isMac = navigator.platform.toUpperCase().includes('MAC');
  const mod = isMac ? e.metaKey : e.ctrlKey;
  if (!mod) return;
  if (e.key.toLowerCase() === 'z' && !e.shiftKey){ e.preventDefault(); doUndo(); }
  else if ((e.key.toLowerCase() === 'z' && e.shiftKey) || (e.key.toLowerCase() === 'y')){ e.preventDefault(); doRedo(); }
});

/* ===== Save / Autosave ===== */
let autosaveTimer = null;
let lastSavedJson = '';
function setSaveStatus(state, msg=''){
  if (state==='ok') saveStatusEl.textContent=msg||'保存済み', saveStatusEl.className='save-ok';
  else if (state==='pending') saveStatusEl.textContent=msg||'保存中…', saveStatusEl.className='save-pending';
  else if (state==='fail') saveStatusEl.textContent=msg||'保存失敗', saveStatusEl.className='save-fail';
  else saveStatusEl.textContent=msg||'待機中', saveStatusEl.className='muted';
}
function scheduleAutoSave(){
  if (READ_ONLY) return;
  if (!autoSaveEl.checked) return;
  const json = JSON.stringify({ pins:PINS, materials:MATERIALS });
  if (json === lastSavedJson) return;
  if (autosaveTimer) clearTimeout(autosaveTimer);
  setSaveStatus('pending','自動保存待機中…');
  autosaveTimer = setTimeout(autoSaveNow, 1500);
}
async function ensureAutosaveTarget(glbId){
  if (!accessToken) return '';
  if (autosaveId) return autosaveId;
  const map = loadMap();
  if (map[glbId]) { autosaveId = map[glbId]; autosaveName='pins.json'; return autosaveId; }
  let parentId = folderIdInput.value.trim();
  if (!parentId && glbId){
    try{ const meta=await driveGetMetadata(glbId); if (meta.parents?.length) parentId = meta.parents[0]; }catch{}
  }
  if (parentId){
    const q = `name = 'pins.json' and mimeType = 'application/json' and '${parentId}' in parents and trashed = false`;
    try{
      const res = await driveListFiles({ q, pageSize: 5 });
      if (res.files?.length){
        autosaveId = res.files[0].id; autosaveName = res.files[0].name || 'pins.json';
        rememberAutosave(glbId, autosaveId);
        return autosaveId;
      }
    }catch(e){ console.warn('search pins.json failed', e); }
  }
  return '';
}
async function autoSaveNow(){
  autosaveTimer=null;
  try{
    const payload = { pins:PINS, materials:MATERIALS };
    const jsonBlob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
    const glbId = fileIdInput.value.trim();
    let parentId=folderIdInput.value.trim();
    if(!parentId && glbId && accessToken){
      try{ const meta=await driveGetMetadata(glbId); if(meta.parents?.length) parentId=meta.parents[0]; }catch{}
    }
    if (!autosaveId && accessToken){ await ensureAutosaveTarget(glbId); }
    setSaveStatus('pending','保存中…');
    if(autosaveId && accessToken){
      await driveUpdateFile({fileId:autosaveId, name:autosaveName, mimeType:'application/json', dataBlob:jsonBlob});
    }else{
      await ensureToken();
      const created=await driveCreateFile({name:'pins.json', mimeType:'application/json', parents:parentId?[parentId]:[], dataBlob:jsonBlob});
      autosaveId=created.id; autosaveName=created.name||'pins.json';
      if (glbId) rememberAutosave(glbId, autosaveId);
    }
    lastSavedJson = JSON.stringify(payload);
    const t=new Date(), hh=String(t.getHours()).padStart(2,'0'), mm=String(t.getMinutes()).padStart(2,'0'), ss=String(t.getSeconds()).padStart(2,'0');
    setSaveStatus('ok', `保存済み ${hh}:${mm}:${ss}`); scopeWarnEl.style.display='none';
    updatePinsInfo();
  }catch(e){ console.warn('autoSave failed', e); setSaveStatus('fail','オートセーブ失敗（権限？）'); scopeWarnEl.style.display='block'; }
}
function updatePinsInfo(){
  const loaded = loadedPinsId ? `読み込み: ${loadedPinsName||'(名称未取得)'} (${loadedPinsId})` : '読み込み: なし';
  const auto   = autosaveId   ? `オートセーブ: ${autosaveName} (${autosaveId})` : 'オートセーブ: pins.json（未作成）';
  pinsInfoEl.textContent = loaded + ' / ' + auto;
}

/* ===== Pins Picker & Image Picker ===== */
const openModal = (html)=>{ modalRoot.className='modal-overlay'; modalRoot.innerHTML=html; };
const closeModal = ()=>{ modalRoot.className='hidden'; modalRoot.innerHTML=''; };

/* ヘルプモーダル */
btnHelpModel?.addEventListener('click', ()=>{
  openModal(`
    <div class="modal">
      <header><strong>モデル（GLB/GLTF）の指定について</strong><div class="grow"></div><button id="helpClose1">閉じる</button></header>
      <div class="body">
        <p>Google Drive のファイルURL（例: https://drive.google.com/file/d/<b>FILE_ID</b>/view）から <b>FILE_ID</b> をコピーして『モデル』欄に入力し、<b>[読み込む]</b> を押してください。</p>
        <p>GLTF の場合は外部テクスチャを同一フォルダに配置してください。</p>
        <p>共有は『公開/限定』ボタンで切替できます（権限が必要）。</p>
      </div>
      <footer><button id="helpClose2">閉じる</button></footer>
    </div>
  `);
  document.addEventListener('click', (e)=>{ if(e.target?.id==='helpClose1') closeModal(); });
  document.addEventListener('click', (e)=>{ if(e.target?.id==='helpClose2') closeModal(); });
});
btnHelpPins?.addEventListener('click', ()=>{
  openModal(`
    <div class="modal">
      <header><strong>キャプション（pins.json）について</strong><div class="grow"></div><button id="helpClose3">閉じる</button></header>
      <div class="body">
        <p>ピン（位置・タイトル・本文・画像など）を保存する JSON ファイルです。未指定でも作業可能で、オートセーブONなら GLB と同じフォルダに自動作成されます。</p>
        <p>既存の pins.json を使う場合は fileId を『キャプション』欄に入力するか、[選択…] から選んでください。</p>
      </div>
      <footer><button id="helpClose4">閉じる</button></footer>
    </div>
  `);
  document.addEventListener('click', (e)=>{ if(e.target?.id==='helpClose3') closeModal(); });
  document.getElementById('helpClose4')?.addEventListener('click', (e)=>{ (closeModal) });
});

/* 画像アップロード共通 */
async function uploadAndAttachImage(file, pin, opts={}){
  try{
    await ensureToken();
    let parents=[]; const folderId=folderIdInput.value.trim();
    if (folderId) parents=[folderId]; else {
      const glbId=fileIdInput.value.trim();
      if (glbId){ const meta=await driveGetMetadata(glbId); if(meta.parents?.length) parents=[meta.parents[0]]; }
    }
    const up = await driveCreateFile({name:file.name,mimeType:file.type||'application/octet-stream',parents,dataBlob:file});
    pin.imageDriveId=up.id;
    pin.imageMime = file.type || '';
    const blob=await driveFetchBinary(up.id);
    if (pin.imageUrl) { try { URL.revokeObjectURL(pin.imageUrl); } catch(e){} }
    pin.imageUrl=URL.createObjectURL(blob);
    redrawPins();
    scheduleAutoSave();
    if (typeof opts.onAfter === 'function') opts.onAfter();
  } catch (e2) {
    scopeWarnEl.style.display='block';
    console.error(e2);
    alert('画像アップロードに失敗しました。権限（drive.file）とフォルダIDをご確認ください。');
  }
}

/* 画像選択（Drive） */
async function chooseDriveImageForPin(pin, opts={}){
  try{
    await ensureToken();
    const glbId=fileIdInput.value.trim();
    let parentId=folderIdInput.value.trim();
    if(!parentId && glbId){ const meta=await driveGetMetadata(glbId); if(meta.parents?.length) parentId=meta.parents[0]; }
    openModal(`
      <div class="modal">
        <header>
          <strong>画像を選択（GLBと同じフォルダ）</strong>
          <div class="grow"></div>
          <input id="imgQuery" placeholder="名前でフィルタ（例：scan）" style="padding:6px 8px;border:1px solid #ddd;border-radius:8px;min-width:200px">
          <button id="imgSearchAll">ドライブ全体から検索</button>
          <button id="imgClose">閉じる</button>
        </header>
        <div class="body"><div class="grid" id="imgGrid"><div>読み込み中…</div></div></div>
        <footer><span class="muted">画像（image/*）のみ表示。最新順。</span></footer>
      </div>
    `);
    const gridEl = document.getElementById('imgGrid');
    document.getElementById('imgClose')?.addEventListener('click', (e)=>{ (closeModal) });
    function cardHTML(f){
      const t = new Date(f.modifiedTime||Date.now()).toLocaleDateString();
      const thumb = f.thumbnailLink ? f.thumbnailLink.replace(/=s220/,'=s400') : '';
      return `<div class="card">
        <img src="${thumb||''}" alt="${(f.name||'').replace(/"/g,'&quot;')}" onerror="this.style.visibility='hidden'">
        <div class="title">${f.name||'(名称なし)'}</div>
        <div class="meta">${t}</div>
        <button data-pick="${f.id}">この画像を使う</button>
      </div>`;
    }
    async function renderGrid(files){
      if (!files?.length){ gridEl.innerHTML = `<div>候補がありません</div>`; return; }
      gridEl.innerHTML = files.map(cardHTML).join('');
      gridEl.querySelectorAll('[data-pick]').forEach(btn=>{
        btn.onclick = async ()=>{
          const id = btn.getAttribute('data-pick');
          const file = files.find(x=>x.id===id);
          closeModal();
          if (file){
            pin.imageDriveId = file.id;
            pin.imageMime    = file.mimeType || '';
            const blob = await driveFetchBinary(file.id);
            if (pin.imageUrl) { try { URL.revokeObjectURL(pin.imageUrl); } catch(e){} }
            pin.imageUrl = URL.createObjectURL(blob);
            redrawPins();
            scheduleAutoSave();
            if (typeof opts.onApplied === 'function') opts.onApplied();
          }
        };
      });
    }
    async function loadFolder(){
      try{
        let q = `mimeType contains 'image/' and trashed = false`;
        if (parentId) q += ` and '${parentId}' in parents`;
        const res = await driveListFiles({ q, pageSize: 100 });
        await renderGrid(res.files||[]);
      }catch(e){ gridEl.innerHTML = `<div>検索に失敗しました</div>`; }
    }
    await loadFolder();
    document.getElementById('imgSearchAll')?.addEventListener('click', async (e)=>{
      try{
        const query = (document.getElementById('imgQuery')?.value || '').trim();
        let q = `mimeType contains 'image/' and trashed = false`;
        if (query) q += ` and name contains '${query.replace(/'/g,"\\'")}'`;
        const res = await driveListFiles({ q, pageSize: 200 });
        await renderGrid(res.files||[]);
      }catch(e){ gridEl.innerHTML = `<div>全体検索に失敗しました</div>`; }
    });
  }catch(e){ console.error(e); alert('画像の検索に失敗しました（権限をご確認ください）'); }
}

/* ===== 共有エラー診断 / 共有UI ===== */
async function explainShareError(fileId, err){
  console.warn('share-toggle failed', err);
  try{
    const meta = await driveGetMetadata(
      fileId,
      'id,name,owners,driveId,capabilities(canShare,canEdit,canCopy,canComment),permissions'
    );
    const caps = meta.capabilities||{};
    const onDrive = !!meta.driveId;
    let reasons = [];
    if (!caps.canShare) reasons.push('このファイルの共有設定は変更できない（capabilities.canShare=false）');
    if (!caps.canEdit)  reasons.push('あなたは編集権限がない可能性（capabilities.canEdit=false）');
    if (onDrive)        reasons.push('共有ドライブ：組織ポリシー制限の可能性');
    if (!reasons.length) reasons.push('スコープ不足か管理者ポリシーの可能性');
    alert(
      `共有設定の変更に失敗しました。\n`+
      `ファイル名: ${meta.name||'(不明)'}\n\n`+
      `診断:\n - `+reasons.join('\n - ')+"\n\n"+
      `ヒント:\n1) 共有ドライブは役割が必要\n2) 組織でリンク共有禁止の可能性\n3) DriveのUIで手動変更も試してください`
    );
  }catch(_){
    alert('共有設定の変更に失敗しました。DriveのUIで共有設定をご確認ください。');
  }
}
function copyText(text, okMsg='コピーしました'){
  if (navigator.clipboard && window.isSecureContext){
    navigator.clipboard.writeText(text).then(()=> alert(okMsg)).catch(()=> fallbackCopy(text, okMsg));
  } else { fallbackCopy(text, okMsg); }
}
function fallbackCopy(text, okMsg){
  const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
  ta.select(); try{ document.execCommand('copy'); alert(okMsg); } finally{ document.body.removeChild(ta); }
}

/* サインインゲートのボタン */
btnGateSignIn?.addEventListener('click', async ()=>{
  try{
    statusEl.textContent='サインイン中…';
    await requestTokenInteractive(ALL_SCOPES);   // クリック直下
    statusEl.textContent='サインイン完了';
    hideSignInGate();
    scopeWarnEl.style.display = 'none';
    if (extractDriveId(fileIdInput.value)) { btnLoad.click(); }
  }catch(e){
    console.error(e);
    statusEl.textContent='サインイン失敗';
    alert('サインインに失敗しました。Safari/Chromeのポップアップ許可をご確認ください。');
  }
});




/* ===== Header actions ===== */
/* ヘッダーの「Googleにサインイン」 */
btnAuth.onclick = async ()=>{
  try{
    statusEl.textContent='サインイン中…';
    await requestTokenInteractive(ALL_SCOPES);   // クリック直下
    statusEl.textContent='サインイン完了';
    hideSignInGate();
    scopeWarnEl.style.display='none';
  }catch(e){
    console.error(e);
    alert('Googleサインインに失敗しました。設定/ポップアップ/拡張のブロックをご確認ください。');
    statusEl.textContent='サインイン失敗';
  }
};

btnLoad.onclick = async ()=>{
  const glbId = extractDriveId(fileIdInput.value);
  const manualPinsId = extractDriveId(pinsIdInput.value);
  if(!glbId){ alert('GLBの fileId / 共有リンクを入力してください'); return; }

  // ★ここでサインインチェック（未サインインなら中央ゲート表示 → いったん処理中断）
  const ok = await ensureSignedInIfNeeded();
  if (!ok) return;

  try{
    statusEl.textContent='GLB読込中…';
    await loadGLBFromDrive(glbId);

    // 読み込み時の状態初期化
    PINS=[]; MATERIALS={}; redrawPins(); lastSavedJson='';
    loadedPinsId=''; loadedPinsName=''; autosaveId=''; autosaveName='pins.json';

    // オートセーブ作成候補の確保
    if (!READ_ONLY && accessToken){ await ensureAutosaveTarget(glbId); }

    // pins.json の候補（明示指定→既存オートセーブ）
    let targetPinsId = manualPinsId || autosaveId || '';

    if (targetPinsId){
      statusEl.textContent='pins 読込中…';
      const pblob = await driveFetchBinary(targetPinsId);
      const text  = await pblob.text();
      let data=null; try{ data=JSON.parse(text); }catch{}
      if(Array.isArray(data)){
        PINS=data.map(p=>({...p, position:safePos(p.position), color:p.color||'#ee3333'}));
        MATERIALS={};
      } else if(data && typeof data==='object'){
        PINS = Array.isArray(data.pins)? data.pins.map(p=>({...p, position:safePos(p.position), color:p.color||'#ee3333'})) : [];
        MATERIALS = (data.materials && typeof data.materials==='object') ? data.materials : {};
      }
      loadedPinsId = targetPinsId;
      if (accessToken){ try{ const m=await driveGetMetadata(loadedPinsId); loadedPinsName=m.name||''; }catch{} }
      redrawPins();
      for (const {name, material} of materialList){ const cfg = MATERIALS[name]; if (cfg) applyMaterialConfig(material, cfg); }
      lastSavedJson = JSON.stringify({pins:PINS,materials:MATERIALS});
      setSaveStatus('ok','読み込み完了');
    } else {
      lastSavedJson = JSON.stringify({pins:PINS,materials:MATERIALS});
      setSaveStatus('muted','新規セッション');
    }

    buildMaterialsUI(materialsDockEl);
    resetHistoryBaseline();
    syncDockMoveToggle();

    updatePinsInfo();
    refreshShareButtons();

    // カメラ/背景UIの同期
    projModeSel.value = cameraMode;
    fovRange.value = Math.round(camera.fov||60);
    fovVal.textContent = (camera.fov||60).toFixed(0)+'°';
    zoomRange.value = (camera.zoom||1);
    zoomVal.textContent = (camera.zoom||1).toFixed(2);
    syncBgUI();
  }catch(e){
    console.error(e);
    alert('読み込みに失敗しました。権限と fileId を確認してください。');
    statusEl.textContent='エラー';
  }
};


btnSavePins.onclick = async ()=>{
  if (READ_ONLY){ alert('閲覧専用モードでは保存できません'); return; }
  try{
    await ensureToken(); scopeWarnEl.style.display='none';
    const glbId=fileIdInput.value.trim();
    const payload={pins:PINS,materials:MATERIALS};
    const json=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
    let parentId=folderIdInput.value.trim();
    if(!parentId && glbId){
      const meta=await driveGetMetadata(glbId);
      if(meta.parents?.length) parentId=meta.parents[0];
    }
    const now=new Date();
    const def=`pins_${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}.json`;
    const name=prompt('保存ファイル名を入力してください（例：'+def+'）', def);
    if(!name) return;
    const created=await driveCreateFile({name, mimeType:'application/json', parents:parentId?[parentId]:[], dataBlob:json});
    alert(`保存しました: ${name}\nfileId: ${created.id}`);
    updatePinsInfo();
    refreshShareButtons();
  }catch(e){ scopeWarnEl.style.display='block'; console.error(e); alert('保存に失敗しました。権限（drive.file）とフォルダIDをご確認ください。'); setSaveStatus('fail','手動保存失敗'); }
};
autoSaveEl.onchange = ()=>{ if (READ_ONLY) return; if (autoSaveEl.checked) scheduleAutoSave(); else setSaveStatus('muted','オートセーブOFF'); };

/* ==== 仕様変更：URL未入力→GLBと同階層のJSONを一覧 ==== */
btnPickPins.onclick = async ()=>{
  try{
    await ensureToken();
    const glbId = extractDriveId(fileIdInput.value);
    if(!glbId){
      alert('先にGLBを読み込んでください');
      return;
    }
    const meta = await driveGetMetadata(glbId);
    const parentId = (meta.parents && meta.parents[0]) || '';

    openModal(`
      <div class="modal">
        <header>
          <strong>キャプションファイルを選択（同フォルダ）</strong>
          <div class="grow"></div>
          <button id="pinsClose">閉じる</button>
        </header>
        <div class="body">
          <div class="list" id="pinsList"><div class="rowi">読み込み中…</div></div>
        </div>
        <footer>
          <button id="pinsUseAutosave">新規（オートセーブに任せる）</button>
        </footer>
      </div>
    `);
    document.getElementById('pinsClose')?.addEventListener('click', (e)=>{ (closeModal) });
    const listEl = document.getElementById('pinsList');

    try{
      const q = `'${parentId}' in parents and mimeType = 'application/json' and trashed = false`;
      const res = await driveListFiles({ q, pageSize: 200, orderBy: 'modifiedTime desc' });
      const all = res.files || [];
      const pinsLike = all.filter(f => /(^|[^a-z])pins.*\.json$/i.test(f.name));
      const others   = all.filter(f => !/(^|[^a-z])pins.*\.json$/i.test(f.name) && /\.json$/i.test(f.name));
      const files = [...pinsLike, ...others];

      if (!files.length){
        listEl.innerHTML = `<div class="rowi">同じフォルダに .json が見つかりませんでした</div>`;
      } else {
        listEl.innerHTML = files.map(f=>{
          const t = new Date(f.modifiedTime||Date.now()).toLocaleString();
          return `<div class="rowi">
            <div class="name">${f.name}</div>
            <div class="meta">${t}</div>
            <div><button data-pick="${f.id}">これを使う</button></div>
          </div>`;
        }).join('');

        listEl.querySelectorAll('[data-pick]').forEach(btn=>{
          btn.onclick = async ()=>{
            const id = btn.getAttribute('data-pick');
            pinsIdInput.value = id;
            closeModal();
            try{
              statusEl.textContent='pins 読込中…';
              const pblob = await driveFetchBinary(id);
              const text  = await pblob.text();
              let data=null; try{ data=JSON.parse(text); }catch{}
              if(Array.isArray(data)){
                PINS = data.map(p=>({...p, position:safePos(p.position), color:p.color||'#ee3333'}));
                MATERIALS = {};
              } else if(data && typeof data==='object'){
                PINS = Array.isArray(data.pins) ? data.pins.map(p=>({...p, position:safePos(p.position), color:p.color||'#ee3333'})) : [];
                MATERIALS = (data.materials && typeof data.materials==='object') ? data.materials : {};
              }
              loadedPinsId = id;
              try{ const mm = await driveGetMetadata(id); loadedPinsName = mm.name || ''; }catch{}
              redrawPins();
              for (const {name, material} of materialList){
                const cfg = MATERIALS[name]; if (cfg) applyMaterialConfig(material, cfg);
              }
              lastSavedJson = JSON.stringify({pins:PINS,materials:MATERIALS});
              setSaveStatus('ok','読み込み完了');
              updatePinsInfo(); refreshShareButtons();
            }catch(e){
              console.error(e);
              alert('読み込みに失敗しました');
            }
          };
        });
      }
    }catch(e){
      console.error(e);
      listEl.innerHTML = `<div class="rowi">取得に失敗しました</div>`;
    }

    document.getElementById('pinsUseAutosave')?.addEventListener('click', (e)=>{
  pinsIdInput.value = '';
  closeModal();
});
  }catch(e){
    console.error(e);
    alert('サインインが必要です');
  }
};
btnClearPins.onclick = ()=>{ pinsIdInput.value=''; loadedPinsId=''; loadedPinsName=''; updatePinsInfo(); refreshShareButtons(); };
btnCopyReadonlyUrl.onclick = ()=>{
  const glb = extractDriveId(fileIdInput.value);
  const pins = extractDriveId(pinsIdInput.value) || loadedPinsId || autosaveId || '';
  if (!glb){ alert('まずGLBのfileIdを設定してください'); return; }
  const url = new URL(window.location.href);
  url.searchParams.set('fileId', glb);
  if (pins) url.searchParams.set('pinsId', pins);
  url.searchParams.set('mode', 'read');
  copyText(url.toString(), '閲覧専用URLをコピーしました（限定ファイルは閲覧者の権限が必要です）');
};
btnToggleGlbPublic.onclick = async ()=>{
  const glb = extractDriveId(fileIdInput.value);
  if (!glb){ alert('GLBのfileIdが未設定です'); return; }
  try{
    await ensureToken();
    const isPub = await driveIsPublic(glb);
    await driveSetPublic(glb, !isPub);
    alert(`GLBを ${!isPub?'公開（リンクを知っている全員が閲覧可）':'限定'} にしました`);
    refreshShareButtons();
  }catch(e){ await explainShareError(glb, e); }
};
btnTogglePinsPublic.onclick = async ()=>{
  const pid = extractDriveId(pinsIdInput.value) || loadedPinsId || autosaveId;
  if (!pid){ alert('pins.json が未指定です'); return; }
  try{
    await ensureToken();
    const isPub = await driveIsPublic(pid);
    await driveSetPublic(pid, !isPub);
    alert(`pins.jsonを ${!isPub?'公開（リンクを知っている全員が閲覧可）':'限定'} にしました`);
    refreshShareButtons();
  }catch(e){ await explainShareError(pid, e); }
};
async function refreshShareButtons(){
  btnToggleGlbPublic.textContent = '限定';
  btnTogglePinsPublic.textContent= '限定';
  btnTogglePinsPublic.disabled = !(pinsIdInput.value.trim() || loadedPinsId || autosaveId);
  if (!accessToken) return;
  try{
    const glb = fileIdInput.value.trim();
    if (glb){
      const pub = await driveIsPublic(glb);
      btnToggleGlbPublic.textContent = pub ? '公開' : '限定';
    }
  }catch{}
  try{
    const pid = pinsIdInput.value.trim() || loadedPinsId || autosaveId;
    if (pid){
      const pub = await driveIsPublic(pid);
      btnTogglePinsPublic.textContent = pub ? '公開' : '限定';
    }
  }catch{}
}

/* ===== READ-ONLY mode (URL ?mode=read) ===== */

function applyReadOnlyUI(){
  if (!READ_ONLY) return;
  btnSavePins.style.display = 'none';
  btnAddPin.style.display = 'none';
  pillMove.style.display = 'none';
  pillAutosave.style.display = 'none';
  dock.style.display = 'none';
  dockFab.style.display = 'none'; // ★モバイルのツールボタンも非表示
}


(function bootFromUrl(){
  const sp = new URLSearchParams(location.search);
  const fRaw = sp.get('fileId') || sp.get('glb') || sp.get('model') || sp.get('file')  || sp.get('url')  || '';
  const pRaw = sp.get('pinsId') || sp.get('pins') || '';
  const fId = fRaw ? extractDriveId(fRaw) : '';
  const pId = pRaw ? extractDriveId(pRaw) : '';
  if (fId) fileIdInput.value = fId;
  if (pId) pinsIdInput.value = pId;
  const mode = sp.get('mode');
  READ_ONLY = (mode === 'read');
  TOUCH_MODE = TOUCH_MODE || (sp.get('touch') === '1');
  applyTouchUI();
  applyReadOnlyUI();
if (fId) {
  (async ()=>{
    const ok = await ensureSignedInIfNeeded();
    if (!ok) return;   // ゲートを出したら、サインイン完了まで待機
    btnLoad.click();   // サインイン済みなら自動ロード
  })();
}

})();

/* ===== 画像拡大ビュー（ズーム＆ドラッグ） ===== */
function openImageViewer(src){
  const ov = document.createElement('div'); ov.className='zoom-overlay';
  const img = document.createElement('img'); img.className='zoom-img'; img.src = src;
  const btn = document.createElement('button'); btn.className='zoom-close'; btn.textContent='閉じる';
  btn.onclick = ()=> document.body.removeChild(ov);
  ov.appendChild(img); document.body.appendChild(ov); document.body.appendChild(btn);

  let scale = 1, ox = 0, oy = 0, dragging=false, sx=0, sy=0, tx=0, ty=0;
  function apply(){ img.style.transform = `translate(${ox}px, ${oy}px) scale(${scale})`; }
  ov.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = img.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    const ds = (e.deltaY<0)? 1.1 : 0.9;
    const newScale = Math.min(8, Math.max(0.2, scale * ds));
    // ズーム中心を保つ
    ox = e.clientX - (px * newScale/scale + rect.left - ox);
    oy = e.clientY - (py * newScale/scale + rect.top  - oy);
    scale = newScale; apply();
  }, {passive:false});
  ov.addEventListener('mousedown', (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY; tx=ox; ty=oy; ov.style.cursor='grabbing'; });
  window.addEventListener('mousemove', (e)=>{ if(!dragging) return; ox = tx + (e.clientX - sx); oy = ty + (e.clientY - sy); apply(); });
  window.addEventListener('mouseup', ()=>{ dragging=false; ov.style.cursor='grab'; });
  ov.addEventListener('dblclick', ()=>{ scale=1; ox=oy=0; apply(); });
  ov.addEventListener('click', (e)=>{ if (e.target===ov) { document.body.removeChild(ov); btn.remove(); } });
}

/* ===== グローバルD&D：選択中（or 最後に開いた）ピンに画像を割り当て ===== */
document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
document.addEventListener('drop', async (e)=>{
  if (READ_ONLY) return;
  e.preventDefault();
  const f = e.dataTransfer.files?.[0];
  if (!f || !f.type.startsWith('image/')) return;
  const pin = PINS.find(p=>p.id===selectedPinId) || PINS[PINS.length-1];
  if (!pin){ alert('先にピンを1つ作成してください'); return; }
  await uploadAndAttachImage(f, pin);
});

/* ==== 初期背景反映 ==== */
applyBackgroundMode('dark');
applyBackgroundColor('#222222');

// Sync desktop open-dock button visibility on boot
(function(){
  const openBtn = document.getElementById('btnOpenDock');
  if (openBtn){
    const dockEl = document.getElementById('editorDock');
    const hidden = !dockEl || dockEl.classList.contains('collapsed') || getComputedStyle(dockEl).display === 'none';
    if (hidden){ openBtn.classList.remove('d-none'); } else { openBtn.classList.add('d-none'); }
  }
})();

/* === Caption Bottom Sheet logic (single-sheet rule) === */
(function(){
  const cap = document.getElementById('capSheet');
  if (!cap) return;
  const capHandle = cap.querySelector('.cap-handle');
  const capHeader = cap.querySelector('.cap-header');
  const capClose  = document.getElementById('capClose');
  const capTitle  = document.getElementById('capTitle');
  const capText   = document.getElementById('capText');
  const capColor  = document.getElementById('capColor');
  const capPick   = document.getElementById('capPickImage');
  const capImgRow = document.getElementById('capImageRow');
  const capImg    = document.getElementById('capImage');

  function openSheet(data={}){
    capTitle.value = data.title || '';
    capText.value  = data.text  || '';
    capColor.value = data.color || '#ee3333';
    if (data.image){ capImg.src = data.image; capImgRow.hidden = false; }
    else { capImgRow.hidden = true; }
    cap.dataset.snap = 'peek';
    cap.hidden = false;
    cap.setAttribute('open','');
    cap.setAttribute('aria-hidden','false');
  }
  function closeSheet(){
    cap.removeAttribute('open');
    cap.setAttribute('aria-hidden','true');
    setTimeout(()=>{ cap.hidden = true; }, 160);
  }
  window.openCaptionSheet  = openSheet;
  window.closeCaptionSheet = closeSheet;
  capClose?.addEventListener('click', closeSheet);

  // drag on handle/header only
  function attachDrag(el){
    let startY=0, startSnap='peek', dragging=false;
    const order = ['peek','half','full'];
    function next(dir){
      let i = order.indexOf(startSnap);
      i = Math.max(0, Math.min(order.length-1, i - dir));
      return order[i];
    }
    function onDown(ev){ dragging=true; startY = ev.touches? ev.touches[0].clientY : ev.clientY; startSnap = cap.dataset.snap || 'peek'; ev.preventDefault(); }
    function onMove(ev){
      if (!dragging) return;
      const y = ev.touches? ev.touches[0].clientY : ev.clientY;
      const dy = y - startY;
      const dir = (dy < -10) ? -1 : (dy > 10 ? +1 : 0);
      if (dir){ cap.dataset.snap = next(dir); }
    }
    function onUp(ev){
      if (!dragging) return;
      dragging=false;
      const endY = ev.changedTouches? ev.changedTouches[0].clientY : ev.clientY;
      if ((cap.dataset.snap||'peek')==='peek' && endY - startY > 80){ closeSheet(); }
    }
    el.addEventListener('mousedown', onDown); el.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('mousemove', onMove, {passive:false}); window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp);  window.addEventListener('touchend', onUp);
  }
  attachDrag(capHandle); attachDrag(capHeader);
})();


/* Moved inline JS from external scripts */

/* === Caption Bottom Sheet logic (single-sheet rule) === */
(function(){
  const cap = document.getElementById('capSheet');
  if (!cap) return;
  const capHandle = cap.querySelector('.cap-handle');
  const capHeader = cap.querySelector('.cap-header');
  const capClose  = document.getElementById('capClose');
  const capTitle  = document.getElementById('capTitle');
  const capText   = document.getElementById('capText');
  const capColor  = document.getElementById('capColor');
  const capPick   = document.getElementById('capPickImage');
  const capImgRow = document.getElementById('capImageRow');
  const capImg    = document.getElementById('capImage');

  function openSheet(data={}){
    capTitle.value = data.title || '';
    capText.value  = data.text  || '';
    capColor.value = data.color || '#ee3333';
    if (data.image){ capImg.src = data.image; capImgRow.hidden = false; }
    else { capImgRow.hidden = true; }
    cap.dataset.snap = 'peek';
    cap.hidden = false;
    cap.setAttribute('open','');
    cap.setAttribute('aria-hidden','false');
  }
  function closeSheet(){
    cap.removeAttribute('open');
    cap.setAttribute('aria-hidden','true');
    setTimeout(()=>{ cap.hidden = true; }, 160);
  }
  window.openCaptionSheet  = openSheet;
  window.closeCaptionSheet = closeSheet;
  capClose?.addEventListener('click', closeSheet);

  // drag on handle/header only
  function attachDrag(el){
    let startY=0, startSnap='peek', dragging=false;
    const order = ['peek','half','full'];
    function next(dir){
      let i = order.indexOf(startSnap);
      i = Math.max(0, Math.min(order.length-1, i - dir));
      return order[i];
    }
    function onDown(ev){ dragging=true; startY = ev.touches? ev.touches[0].clientY : ev.clientY; startSnap = cap.dataset.snap || 'peek'; ev.preventDefault(); }
    function onMove(ev){
      if (!dragging) return;
      const y = ev.touches? ev.touches[0].clientY : ev.clientY;
      const dy = y - startY;
      const dir = (dy < -10) ? -1 : (dy > 10 ? +1 : 0);
      if (dir){ cap.dataset.snap = next(dir); }
    }
    function onUp(ev){
      if (!dragging) return;
      dragging=false;
      const endY = ev.changedTouches? ev.changedTouches[0].clientY : ev.clientY;
      if ((cap.dataset.snap||'peek')==='peek' && endY - startY > 80){ closeSheet(); }
    }
    el.addEventListener('mousedown', onDown); el.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('mousemove', onMove, {passive:false}); window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp);  window.addEventListener('touchend', onUp);
  }
  attachDrag(capHandle); attachDrag(capHeader);
})();



/* === Caption Bottom Sheet logic (single-sheet rule) === */
(function(){
  const cap = document.getElementById('capSheet');
  if (!cap) return;
  const capHandle = cap.querySelector('.cap-handle');
  const capHeader = cap.querySelector('.cap-header');
  const capClose  = document.getElementById('capClose');
  const capTitle  = document.getElementById('capTitle');
  const capText   = document.getElementById('capText');
  const capColor  = document.getElementById('capColor');
  const capPick   = document.getElementById('capPickImage');
  const capImgRow = document.getElementById('capImageRow');
  const capImg    = document.getElementById('capImage');

  function openSheet(data={}){
    capTitle.value = data.title || '';
    capText.value  = data.text  || '';
    capColor.value = data.color || '#ee3333';
    if (data.image){ capImg.src = data.image; capImgRow.hidden = false; }
    else { capImgRow.hidden = true; }
    cap.dataset.snap = 'peek';
    cap.hidden = false;
    cap.setAttribute('open','');
    cap.setAttribute('aria-hidden','false');
  }
  function closeSheet(){
    cap.removeAttribute('open');
    cap.setAttribute('aria-hidden','true');
    setTimeout(()=>{ cap.hidden = true; }, 160);
  }
  window.openCaptionSheet  = openSheet;
  window.closeCaptionSheet = closeSheet;
  capClose?.addEventListener('click', closeSheet);

  // drag on handle/header only
  function attachDrag(el){
    let startY=0, startSnap='peek', dragging=false;
    const order = ['peek','half','full'];
    function next(dir){
      let i = order.indexOf(startSnap);
      i = Math.max(0, Math.min(order.length-1, i - dir));
      return order[i];
    }
    function onDown(ev){ dragging=true; startY = ev.touches? ev.touches[0].clientY : ev.clientY; startSnap = cap.dataset.snap || 'peek'; ev.preventDefault(); }
    function onMove(ev){
      if (!dragging) return;
      const y = ev.touches? ev.touches[0].clientY : ev.clientY;
      const dy = y - startY;
      const dir = (dy < -10) ? -1 : (dy > 10 ? +1 : 0);
      if (dir){ cap.dataset.snap = next(dir); }
    }
    function onUp(ev){
      if (!dragging) return;
      dragging=false;
      const endY = ev.changedTouches? ev.changedTouches[0].clientY : ev.clientY;
      if ((cap.dataset.snap||'peek')==='peek' && endY - startY > 80){ closeSheet(); }
    }
    el.addEventListener('mousedown', onDown); el.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('mousemove', onMove, {passive:false}); window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp);  window.addEventListener('touchend', onUp);
  }
  attachDrag(capHandle); attachDrag(capHeader);
})();




// === Workspace inline tool button opens dock (PC) ===
document.getElementById('toolInlineBtn')?.addEventListener('click', ()=>{
  const d = document.getElementById('editorDock');
  if (!d) return;
  d.classList.remove('collapsed');
  d.style.display = 'block';
});

// === Mobile: model load sheet ===
(()=>{
  const loadFab = document.getElementById('loadFab');
  const loadSheet = document.getElementById('loadSheet');
  const loadHandle = document.getElementById('loadHandle');
  const loadClose = document.getElementById('loadClose');
  const loadInput = document.getElementById('loadInput');
  const loadStart = document.getElementById('loadStart');

  function openLoadSheet(){
    if (!loadSheet) return;
    loadSheet.dataset.snap = 'half';
    loadSheet.hidden = false;
    loadSheet.setAttribute('open','');
    loadSheet.setAttribute('aria-hidden','false');
    setTimeout(()=> loadInput?.focus(), 50);
  }
  function closeLoadSheet(){
    if (!loadSheet) return;
    loadSheet.removeAttribute('open');
    loadSheet.setAttribute('aria-hidden','true');
    setTimeout(()=>{ loadSheet.hidden = true; }, 160);
  }
  function toLoadUrl(val){
    const s = (val||'').trim();
    if (!s) return '';
    if (s.includes('://')) return s;
    return 'https://drive.google.com/uc?id=' + encodeURIComponent(s);
  }
  loadFab?.addEventListener('click', openLoadSheet);
  loadClose?.addEventListener('click', closeLoadSheet);
  // simple handle drag (header only)
  (function(){
    let startY=0, startSnap='half', dragging=false;
    const order = ['peek','half','full'];
    function next(dir){ let i=order.indexOf(startSnap); i=Math.max(0,Math.min(order.length-1, i-dir)); return order[i]; }
    function onDown(ev){ dragging=true; startY = ev.touches? ev.touches[0].clientY : ev.clientY; startSnap = loadSheet.dataset.snap||'half'; ev.preventDefault(); }
    function onMove(ev){ if(!dragging) return; const y=ev.touches? ev.touches[0].clientY : ev.clientY; const dy=y-startY; const dir=(dy<-10)?-1:((dy>10)?+1:0); if(dir){ loadSheet.dataset.snap = next(dir); } }
    function onUp(ev){ if(!dragging) return; dragging=false; const endY = ev.changedTouches? ev.changedTouches[0].clientY : ev.clientY; if((loadSheet.dataset.snap||'peek')==='peek' && endY-startY>80){ closeLoadSheet(); } }
    loadHandle?.addEventListener('mousedown', onDown); loadHandle?.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('mousemove', onMove, {passive:false}); window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp); window.addEventListener('touchend', onUp);
  })();
  loadStart?.addEventListener('click', ()=>{
    const url = toLoadUrl(loadInput?.value||'');
    if(!url){ alert('URLかfileIDを入力してください'); return; }
    document.getElementById('fileId')?.focus();
    const fileIdBox = document.getElementById('fileId');
    if (fileIdBox){ fileIdBox.value = url.includes('googleusercontent.com') ? url : url; }
    document.getElementById('btnLoad')?.click();
    closeLoadSheet();
  });
})();

</script>
</body>
</html>