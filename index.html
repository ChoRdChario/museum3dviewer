<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LociMyu</title>
  <link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="28" fill="%230b0f14"/><text x="32" y="39" font-size="28" text-anchor="middle" fill="%2353b7ff" font-family="Arial">L</text></svg>'>
  <style>
    :root{ --bg:#0b0f14; --panel:#121922; --text:#e6edf3; --accent:#53b7ff; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.3);}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    .app{display:grid;grid-template-rows:auto 1fr;height:100vh}
    header{display:flex;gap:.75rem;align-items:center;padding:10px 12px;background:linear-gradient(180deg,#0e1520,#0b0f14);border-bottom:1px solid #1e2837}
    .pill{background:rgba(255,255,255,.06);padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.08);font-weight:700}
    input[type=text], select, textarea{background:#0f1722;border:1px solid #203049;color:var(--text);border-radius:10px;padding:8px 10px;min-width:240px}
    button{background:#152133;color:var(--text);border:1px solid #223146;border-radius:10px;padding:8px 12px;cursor:pointer}
    button[disabled]{opacity:.5;cursor:not-allowed}
    button:hover{background:#1a2b45}
    .accent{border-color:#2c82c9}
    .main{display:grid;grid-template-columns:360px 1fr 420px;gap:10px;padding:10px;height:calc(100vh - 58px)}
    body.wide #leftToolbox, body.wide #rightCaption{display:none}
    body.wide .main{grid-template-columns:1fr}
    .panel{background:#121922;border:1px solid #1e2837;border-radius:var(--radius);overflow:hidden;display:flex;flex-direction:column;min-height:0}
    .panel h3{margin:0;padding:10px 12px;border-bottom:1px solid #203049;background:#0f1722;font-size:.95rem;font-weight:600}
    .panel .body{padding:10px;overflow:auto}
    #viewer{position:relative}
    #viewerCanvas{display:block;width:100%;height:100%;background:#0a0f16;border-radius:var(--radius)}
    #connector{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    #connector line{stroke:#7cc4ff;stroke-width:2;stroke-opacity:.9;filter:url(#dropshadow)}
    #connector circle{fill:#7cc4ff;opacity:.9}
    .hud{position:absolute;left:10px;bottom:10px;display:flex;gap:8px}
    .chip{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px}
    .spinner{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg, rgba(10,15,22,.75), rgba(10,15,22,.75));backdrop-filter: blur(2px);}
    .spinner[hidden]{display:none}
    .lds{width:64px;height:64px;border-radius:50%;border:6px solid rgba(255,255,255,.12);border-top-color:var(--accent);animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .signin-gate{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 600px at 50% 15%, rgba(83,183,255,.08), transparent 60%), linear-gradient(180deg,#0a0f16,#05070b);z-index:20}
    .card{width:min(560px,92vw);background:#0c1118;border:1px solid #1d2a3d;border-radius:24px;box-shadow:var(--shadow);padding:20px}
    .card h1{margin:4px 0 8px;font-size:1.35rem}
    .card p{color:#c2d0e2;opacity:.9}
    .list{display:flex;flex-direction:column;gap:8px}
    .list .row{display:flex;align-items:center;justify-content:space-between;gap:8px;background:#0f1722;border:1px solid #203049;border-radius:12px;padding:10px;cursor:pointer}
    .row .title{font-weight:600}
    .row .meta{color:#a9b8cf;font-size:.85rem}
    .row:hover{background:#132035}
    .small{font-size:.85rem;color:#a9b8cf}
    .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .field{display:flex;gap:8px;align-items:center;margin:8px 0}
    .field label{min-width:120px;color:#a9b8cf}
    input[type="range"]{width:160px}
    .viewgrid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
    .thumbs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .thumb{position:relative}
    .thumb img{width:72px;height:72px;object-fit:cover;border-radius:10px;border:1px solid #223146;display:block}
    .thumb .del{position:absolute;top:-6px;right:-6px;width:20px;height:20px;border-radius:50%;background:#1e2a3b;border:1px solid #334966;color:#e8f0ff;line-height:18px;text-align:center;font-weight:700;cursor:pointer}
    .thumb .del:hover{background:#2a3b55}
    #viewerPreview{position:absolute;top:10px;right:10px;max-height:60%;border:1px solid #203049;border-radius:8px;background:#0a0f16cc;backdrop-filter: blur(2px);display:grid;grid-template-rows:auto 1fr auto;gap:0;resize:both;overflow:hidden;min-width:260px;min-height:200px}
    #viewerPreview.hidden{display:none}
    #previewControls{position:sticky;top:0;background:#0a0f16f0;border-bottom:1px solid #203049;padding:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;z-index:1}
    #previewWrap{position:relative;overflow:auto}
    #previewInner{transform-origin: top left;}
    #previewInner img{display:block;max-width:none;max-height:none;border-radius:0}
    #viewerPreview .cap{border-top:1px solid #203049;background:#0a0f16f0;display:grid;grid-template-rows:auto auto;gap:4px;padding:6px 8px}
    #capTitleLine{font-weight:700}
    #capBodyLine{font-size:.85rem;color:#c9d7ea;max-height:8em;overflow:auto}
    body.viewonly #pinTools{display:none}
    body.viewonly #btnSavePin,
    body.viewonly #btnDeletePin,
    body.viewonly #btnAttach,
    body.viewonly #btnPickFromFolder,
    body.viewonly #autosaveTip,
    body.viewonly #listNew,
    body.viewonly #listDelete { display:none; }
    @media (max-width:1100px){
      .main{grid-template-columns:1fr; grid-template-rows: 360px 1fr 480px}
    }
  /* ===== M3D UI vNext (namespaced) ===== */
.m3d-ui-vnext #rightCaption{ display:none !important; }
@media (max-width: 900px){
  .m3d-ui-vnext #leftToolbox, 
  .m3d-ui-vnext #rightCaption{ display:none !important; }
}

/* Overlay caption layer (desktop) */
#m3d-caption-layer{
  position:absolute; inset:0;
  pointer-events:none; z-index: 1200;
}
#m3d-caption-layer .m3d-capwin{
  position:absolute; min-width:220px; max-width:340px;
  background:#0b132b; color:#d6e4ff; border:1px solid #1f2a44; border-radius:12px;
  box-shadow:0 8px 28px rgba(0,0,0,.35);
  pointer-events:auto; user-select:none; overflow:hidden;
}
.m3d-capwin__titlebar{
  cursor:move; padding:8px 12px; font-weight:600; background:#16223a;
  display:flex; align-items:center; gap:8px;
}
.m3d-capwin__close{
  margin-left:auto; background:transparent; border:none; color:#aac4ff; font-size:16px; cursor:pointer;
}
.m3d-capwin__body{ padding:10px 12px; }
.m3d-capwin__img{ display:block; max-width:240px; max-height:180px; width:auto; height:auto; border-radius:8px; margin:6px 0; }
.m3d-capwin__meta{ font-size:12px; opacity:.8; }
.m3d-capwin__actions{ display:flex; gap:8px; margin-top:8px; }

/* Mobile caption panel (single) */
#m3d-mobile-caption{
  display:none;
  position:relative;
  background:#0b132b; color:#d6e4ff; border-top:1px solid #1f2a44;
  padding:10px 12px; z-index:1100;
}
@media (max-width: 900px){
  #m3d-mobile-caption{ display:block; }
}
#m3d-mobile-caption .m3d-cap__img{
  max-width:50vw; max-height:40vh; width:auto; height:auto; border-radius:8px; display:block;
}
#m3d-mobile-caption .m3d-cap__placeholder{
  border:1px dashed #345; border-radius:10px; color:#9aa;
  min-height:80px; display:flex; align-items:center; justify-content:center; margin:6px 0;
}

/* Ensure viewer container is a positioning context for overlay */
.m3d-ui-vnext #viewer{ position:relative; }

/* vNext: right caption panel split (desktop) */
@media (min-width: 901px){
  #rightCaption .body{
    display:grid; grid-template-rows: 7fr 3fr; gap:10px;
  }
  #m3d-caplist{ overflow:auto; }
  #m3d-capeditor{ overflow:auto; }
}

</style>

  <!-- ES Modules -->
  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.157.0/examples/jsm/"
    } }
  </script>
  <!-- HEIC fallback -->
  <script src="https://unpkg.com/heic2any@0.0.5/dist/heic2any.min.js"></script>
</head>
<body>
<div class="app">
  <header>
    <span class="pill">LociMyu</span>
    <div class="toolbar" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <input id="inputGLB" type="text" placeholder="GLB fileId or share URL" />
      <input id="inputSheet" type="text" placeholder="SpreadsheetId or share URLÔºàÁ©∫„Å™„ÇâËá™Âãï‰ΩúÊàêÔºâ" />
      <button id="btnLoad" class="accent" disabled>GLB„ÇíË™≠„ÅøËæº„ÇÄ</button>
      <button id="btnViewOnly">Èñ≤Ë¶ß„É™„É≥„ÇØ„ÇíÁîüÊàê</button>
      <button id="btnWide">üì∫ „Éì„É•„Éº„Ç¢Êã°Â§ß</button>
      <span id="statusLabel" class="chip">„Çµ„Ç§„É≥„Ç§„É≥ÂæÖ„Å°‚Ä¶</span>
    </div>
  </header>

  <div class="main">
    <!-- Â∑¶Ôºö„ÉÑ„Éº„É´ -->
    <section class="panel" id="leftToolbox">
      <h3>„ÉÑ„Éº„É´„Éú„ÉÉ„ÇØ„ÇπÔºà„Éû„ÉÜ„É™„Ç¢„É´ & „Ç´„É°„É© & „Éî„É≥Ôºâ</h3>
      <div class="body">
        <div id="pinTools">
          <div class="small">Shift + „ÇØ„É™„ÉÉ„ÇØ „Åß„Éî„É≥„ÇíÈÖçÁΩÆÔºàÁ∑®ÈõÜ„É¢„Éº„Éâ„ÅÆ„ÅøÔºâ</div>
          <div class="flex" style="margin-top:6px;margin-bottom:6px">
            <button id="btnAddPin" disabled>Ôºã „Éî„É≥ËøΩÂä†„É¢„Éº„Éâ</button>
            <button id="btnGizmo" disabled>„ÇÆ„Ç∫„É¢: OFF</button>
            <button id="btnUndo" disabled>Ctrl+Z</button>
            <button id="btnTogglePins" disabled>„Éî„É≥Ë°®Á§∫: ON</button>
          </div>
          <div class="flex" style="align-items:center;flex-wrap:nowrap">
            <div class="small">„Éî„É≥Ëâ≤:</div>
            <div id="colorPresets" class="flex" style="flex-wrap:nowrap"></div>
          </div>
          <hr style="border-color:#203049;border-width:1px 0;margin:12px 0">
        </div>

        <div class="small" style="margin:4px 0 6px">„Éû„ÉÜ„É™„Ç¢„É´Á∑®ÈõÜÔºà„Ç≠„É£„Éó„Ç∑„Éß„É≥„Ç∑„Éº„Éà„Åî„Å®„Å´‰øùÂ≠òÔºâ</div>
        <div class="field"><label>ÂØæË±°</label>
          <select id="matSelect"><option value="__all__">ÔºàÂÖ®„Éû„ÉÜ„É™„Ç¢„É´ÔºöÁ∑®ÈõÜ‰∏çÂèØÔºâ</option></select>
        </div>
        <div class="field"><label>Unlit</label><input id="matUnlit" type="checkbox"><span class="small">ÊòéÊöó„Å™„Åó</span></div>
        <div class="field"><label>Ë£èÈù¢ÊèèÁîª</label><input id="matDoubleSided" type="checkbox"></div>
        <div class="field"><label>‰∏çÈÄèÊòéÂ∫¶</label><input id="matOpacity" type="range" min="0" max="1" step="0.01" value="1"><span id="matOpacityVal" class="small">1.00</span></div>
        <div class="field"><label>„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÂèçËª¢</label><input id="matInvert" type="checkbox"></div>
        <div class="field"><label>ÁôΩ‚ÜíÈÄèÊòé</label><input id="matWhiteTransparent" type="checkbox"></div>
        <div class="field"><label>ÈñæÂÄ§ÔºàŒ±TestÔºâ</label><input id="matThreshold" type="range" min="0" max="1" step="0.01" value="0"><span id="matThresholdVal" class="small">0.00</span></div>

        <hr style="border-color:#203049;border-width:1px 0;margin:12px 0">

        <div class="small" style="margin:4px 0 6px">„Éì„É•„ÉºÔºà„Ç≠„É£„Éó„Ç∑„Éß„É≥„Ç∑„Éº„Éà„Åî„Å®„Å´‰øùÂ≠òÔºâ</div>
        <div class="viewgrid" style="margin-bottom:8px">
          <button id="viewFront">ÂâçÈù¢</button>
          <button id="viewBack">ËÉåÈù¢</button>
          <button id="viewLeft">Â∑¶Èù¢</button>
          <button id="viewRight">Âè≥Èù¢</button>
          <button id="viewTop">‰∏äÈù¢</button>
          <button id="viewBottom">‰∏ãÈù¢</button>
        </div>
        <div class="field"><label>Âπ≥Ë°åÊäïÂΩ±</label><input id="projOrtho" type="checkbox"><span class="small">ON: Orthographic</span></div>
        <div class="field"><label>ËÉåÊôØËâ≤</label><input id="bgColor" type="color" value="#0a0f16"></div>
      </div>
    </section>

    <!-- ‰∏≠Â§ÆÔºö„Éì„É•„Éº„Ç¢ -->
    <section class="panel" id="viewer">
      <div class="spinner" id="loading" hidden><div class="lds"></div></div>
      <canvas id="viewerCanvas"></canvas>
      <svg id="connector">
        <defs><filter id="dropshadow" x="-20%" y="-20%" width="140%"><feDropShadow dx="0" dy="0" stdDeviation="2" flood-color="#001a33" flood-opacity="0.9"/></filter></defs>
        <line id="connLine" x1="0" y1="0" x2="0" y2="0" style="display:none"/>
        <circle id="connDot" r="3" cx="0" cy="0" style="display:none"/>
      </svg>

      <div id="viewerPreview" class="hidden">
        <button id="previewClose" aria-label="Èñâ„Åò„Çã" style="position:absolute;right:8px;top:8px;z-index:3;background:#162234;border:1px solid #24324b;color:#e6edf3;border-radius:10px;padding:6px 10px;cursor:pointer">Èñâ„Åò„Çã</button>
        <div id="previewControls">
          <span class="small">ÂÄçÁéá</span>
          <input id="previewZoom" type="range" min="0.1" max="3" step="0.05" value="1">
          <span id="previewZoomVal" class="small">1.00√ó</span>
          <button id="previewReset">„É™„Çª„ÉÉ„Éà</button>
          <span id="previewErr" class="small" style="margin-left:auto;color:#ffb4b4;display:none">ÁîªÂÉè„ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü</span>
        </div>
        <div id="previewWrap" style="position:relative"><div id="previewInner"><img id="previewImg" alt="preview"/></div><div id="previewMsg" class="small" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#9fb3c8;display:none;text-align:center;pointer-events:none">ÁîªÂÉè„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì</div></div>
        <div class="cap">
          <div id="capTitleLine"></div>
          <div id="capBodyLine"></div>
        </div>
      </div>

      <div class="hud"><div class="chip" id="modeLabel">Orbit</div></div>
    </section>

    <!-- Âè≥Ôºö„Ç≠„É£„Éó„Ç∑„Éß„É≥ -->
    <section class="panel" id="rightCaption">
      <h3>„Ç≠„É£„Éó„Ç∑„Éß„É≥</h3>
      <div class="body">
        <div class="flex" style="justify-content:space-between;align-items:center;margin-bottom:6px">
          <div class="flex" style="gap:8px;align-items:center">
            <div class="small">„Éî„É≥‰∏ÄË¶ß</div>
            <button id="btnColorFilter">Ëâ≤„ÅßÁµû„ÇäËæº„Åø ‚ñæ</button>
          </div>
          <div class="flex" style="gap:6px;align-items:center">
            <select id="listSelect" disabled></select>
            <button id="listNew" disabled>Êñ∞Ë¶è</button>
            <button id="listDelete" disabled>ÂâäÈô§</button>
          </div>
        </div>

        <div id="colorFilterPanel" class="panel body" style="display:none;margin-bottom:8px;padding:8px">
          <div class="small" style="margin-bottom:6px">Ë°®Á§∫„Åô„ÇãËâ≤„ÇíÈÅ∏ÊäûÔºàË§áÊï∞ÂèØÔºâ</div>
          <div id="colorFilterList"></div>
          <div class="flex" style="justify-content:flex-end;margin-top:8px">
            <button id="btnFilterAll">„Åô„Åπ„Å¶</button>
            <button id="btnFilterNone">„Å™„Åó</button>
            <button id="btnFilterClose">Èñâ„Åò„Çã</button>
          </div>
        </div>

        <div id="pinsList" class="list" style="margin:8px 0 14px"></div>
        <div id="noSelection">„Éî„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>

        <div id="editor" class="hidden">
          <div class="field" style="width:100%"><label>„Çø„Ç§„Éà„É´</label><input id="capTitle" type="text" placeholder="„Çø„Ç§„Éà„É´" style="flex:1"/></div>
          <div class="field" style="width:100%"><label>Êú¨Êñá</label><textarea id="capBody" rows="6" placeholder="„Ç≠„É£„Éó„Ç∑„Éß„É≥Êú¨Êñá" style="flex:1"></textarea></div>

          <div class="flex">
            <input id="imgLocal" type="file" accept="image/*,.heic,.HEIC" style="display:none"/>
            <button id="btnAttach" class="accent" disabled>ÁîªÂÉè„ÇíÊ∑ª‰ªò„Åó„Å¶Drive„Å´‰øùÂ≠ò</button>
            <button id="btnPickFromFolder" class="accent" disabled>Drive„Åã„Çâ‰øùÂ≠ò</button>
          </div>

          <div class="thumbs" id="thumbs"></div>

          <div class="flex" style="justify-content:space-between;margin-top:8px;margin-bottom:8px">
            <button id="btnSavePin" class="accent" disabled>‰øùÂ≠òÔºàSheetsÔºâ</button>
            <button id="btnDeletePin" style="border-color:#5a1f26;color:#ffb4b4" disabled>„Éî„É≥ÂâäÈô§</button>
            <span class="small" id="autosaveTip">ÂÖ•Âäõ„ÅØÊï∞ÁßíÂæå„Å´Ëá™Âãï‰øùÂ≠ò</span>
          </div>
        </div>
      </div>
    </section>
  </div>
</div>

<!-- DriveÁîªÂÉè„Éî„ÉÉ„Ç´„Éº -->
<div id="pickerModal" class="signin-gate" style="display:none;background:rgba(0,0,0,.55)">
  <div class="card" style="width:min(90vw,980px);max-height:80vh;overflow:hidden">
    <h1 style="margin:0 0 6px">Drive„Åã„Çâ‰øùÂ≠ò</h1>
    <div class="flex" style="justify-content:flex-end;margin-bottom:8px">
      <button id="btnPickerReload">ÂÜçË™≠„ÅøËæº„Åø</button>
      <button id="btnPickerClose">Èñâ„Åò„Çã</button>
    </div>
    <div id="pickerGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;overflow:auto;max-height:60vh"></div>
  </div>
</div>

<!-- „Çµ„Ç§„É≥„Ç§„É≥„Ç≤„Éº„Éà -->
<div class="signin-gate" id="gate">
  <div class="card">
    <h1>Google„Å´„Çµ„Ç§„É≥„Ç§„É≥</h1>
    <p>Êú¨„ÉÑ„Éº„É´„ÅØ Google Drive / Google Sheets „Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇÂÖà„Å´„Çµ„Ç§„É≥„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
    <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
      <button id="btnSignIn" class="accent" style="font-weight:700">üîê Sign in with Google</button>
      <span class="small" style="opacity:.8">OAuth2 (Drive.file / Sheets)</span>
    </div>
  </div>
</div>

<!-- Google SDK -->
<script>
  window.__flags = { gapi:false, gis:false };
  function onGapi(){ window.__flags.gapi = true; }
  function onGis(){  window.__flags.gis  = true; }
</script>
<script async defer src="https://accounts.google.com/gsi/client" onload="onGis()"></script>
<script async defer src="https://apis.google.com/js/api.js" onload="onGapi()"></script>

<script type="module">
/* ===== Three.js imports ===== */
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';

/* ================== iOS Detection & constants ================== */
const IS_IOS = /iP(hone|ad|od)/.test(navigator.platform) ||
               (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
const ORTHO_MARGIN = IS_IOS ? 1.6 : 1.8;

/* ================== Google Auth ================== */
const CLIENT_ID = '595200751510-ncahnf7edci6b9925becn5to49r6cguv.apps.googleusercontent.com';
const API_KEY   = 'AIzaSyCUnTCr5yWUWPdEXST9bKP1LpgawU5rIbI';
const DISCOVERY_DOCS = [
  'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest',
  'https://www.googleapis.com/discovery/v1/apis/sheets/v4/rest'
];
const SCOPES = [
  'https://www.googleapis.com/auth/drive.file',
  'https://www.googleapis.com/auth/drive.readonly',
  'https://www.googleapis.com/auth/drive.metadata.readonly',
  'https://www.googleapis.com/auth/spreadsheets'
].join(' ');

let tokenClient = null;
let accessToken = null;
let gapiReady = false;
let gisReady  = false;

async function ensureGapiClient() {
  if (gapiReady) return;
  if (!(window.gapi && gapi && gapi.load)) {
    await new Promise(r => {
      const t = setInterval(() => {
        if (window.gapi && gapi && gapi.load) { clearInterval(t); r(); }
      }, 50);
    });
  }
  await new Promise((resolve) => gapi.load('client', resolve));
  await gapi.client.init({ discoveryDocs: DISCOVERY_DOCS });
  gapiReady = true;
}
async function ensureGIS() {
  if (gisReady) return;
  if (!(window.google && google.accounts && google.accounts.oauth2)) {
    await new Promise(r => {
      const t = setInterval(() => {
        if (window.google && google.accounts && google.accounts.oauth2) { clearInterval(t); r(); }
      }, 50);
    });
  }
  gisReady = true;
}
async function ensureTokenClient() {
  await ensureGIS();
  if (tokenClient) return tokenClient;
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: (resp) => {
      if (resp && resp.access_token) {
        accessToken = resp.access_token;
        document.getElementById('gate').style.display = 'none';
        const viewOnly = new URLSearchParams(location.search).get('view') === '1';
        document.getElementById('statusLabel').textContent = viewOnly ? 'Èñ≤Ë¶ß„É¢„Éº„Éâ' : 'Ready';
        ['btnLoad','btnTogglePins','projOrtho','listSelect'].forEach(id=> document.getElementById(id).removeAttribute('disabled'));
        if(!viewOnly){
          ['btnAddPin','btnGizmo','btnUndo','btnSavePin','btnDeletePin','btnAttach','btnPickFromFolder','listNew','listDelete']
            .forEach(id=> document.getElementById(id).removeAttribute('disabled'));
        }
        enforceViewOnlyMode();

        const qs = new URLSearchParams(location.search);
        const fid = qs.get('fileId') || '';
        const sid = qs.get('sheetId') || '';
        if(fid) el.inputGLB.value = fid;
        if(sid) el.inputSheet.value = sid;
      }
    }
  });
  return tokenClient;
}
async function startSignIn() {
  try {
    el.statusLabel.textContent = '„Çµ„Ç§„É≥„Ç§„É≥Âá¶ÁêÜ‰∏≠‚Ä¶';
    await ensureTokenClient();
    tokenClient.requestAccessToken({ prompt: 'consent' });
  } catch (e) {
    console.error(e);
    alert('„Çµ„Ç§„É≥„Ç§„É≥„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÁä∂ÊÖã„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ');
  }
}

/* ================== Elements / State ================== */
const el = {
  gate: document.getElementById('gate'),
  statusLabel: document.getElementById('statusLabel'),
  inputGLB: document.getElementById('inputGLB'),
  inputSheet: document.getElementById('inputSheet'),
  btnLoad: document.getElementById('btnLoad'),
  btnViewOnly: document.getElementById('btnViewOnly'),
  btnWide: document.getElementById('btnWide'),
  loading: document.getElementById('loading'),
  viewerCanvas: document.getElementById('viewerCanvas'),
  viewerPreview: document.getElementById('viewerPreview'),
  previewWrap: document.getElementById('previewWrap'),
  previewInner: document.getElementById('previewInner'),
  previewImg: document.getElementById('previewImg'),
  previewZoom: document.getElementById('previewZoom'),
  previewZoomVal: document.getElementById('previewZoomVal'),
  previewReset: document.getElementById('previewReset'),
  previewErr: document.getElementById('previewErr'),
  capTitleLine: document.getElementById('capTitleLine'),
  capBodyLine: document.getElementById('capBodyLine'),
  pinsList: document.getElementById('pinsList'),
  rightNoSel: document.getElementById('noSelection'),
  rightEditor: document.getElementById('editor'),
  capTitle: document.getElementById('capTitle'),
  capBody: document.getElementById('capBody'),
  btnSavePin: document.getElementById('btnSavePin'),
  btnDeletePin: document.getElementById('btnDeletePin'),
  btnAddPin: document.getElementById('btnAddPin'),
  btnGizmo: document.getElementById('btnGizmo'),
  btnTogglePins: document.getElementById('btnTogglePins'),
  btnUndo: document.getElementById('btnUndo'),
  modeLabel: document.getElementById('modeLabel'),
  btnSignIn: document.getElementById('btnSignIn'),
  colorPresets: document.getElementById('colorPresets'),
  btnColorFilter: document.getElementById('btnColorFilter'),
  colorFilterPanel: document.getElementById('colorFilterPanel'),
  colorFilterList: document.getElementById('colorFilterList'),
  btnFilterAll: document.getElementById('btnFilterAll'),
  btnFilterNone: document.getElementById('btnFilterNone'),
  btnFilterClose: document.getElementById('btnFilterClose'),
  imgLocal: document.getElementById('imgLocal'),
  btnAttach: document.getElementById('btnAttach'),
  btnPickFromFolder: document.getElementById('btnPickFromFolder'),
  thumbs: document.getElementById('thumbs'),
  matSelect: document.getElementById('matSelect'),
  matUnlit: document.getElementById('matUnlit'),
  matDoubleSided: document.getElementById('matDoubleSided'),
  matOpacity: document.getElementById('matOpacity'),
  matOpacityVal: document.getElementById('matOpacityVal'),
  matInvert: document.getElementById('matInvert'),
  matWhiteTransparent: document.getElementById('matWhiteTransparent'),
  matThreshold: document.getElementById('matThreshold'),
  matThresholdVal: document.getElementById('matThresholdVal'),
  viewFront: document.getElementById('viewFront'),
  viewBack: document.getElementById('viewBack'),
  viewLeft: document.getElementById('viewLeft'),
  viewRight: document.getElementById('viewRight'),
  viewTop: document.getElementById('viewTop'),
  viewBottom: document.getElementById('viewBottom'),
  projOrtho: document.getElementById('projOrtho'),
  bgColor: document.getElementById('bgColor'),
  connector: document.getElementById('connector'),
  connLine: document.getElementById('connLine'),
  connDot: document.getElementById('connDot'),
  pickerModal: document.getElementById('pickerModal'),
  pickerGrid: document.getElementById('pickerGrid'),
  btnPickerReload: document.getElementById('btnPickerReload'),
  btnPickerClose: document.getElementById('btnPickerClose'),
  listSelect: document.getElementById('listSelect'),
  listNew: document.getElementById('listNew'),
  listDelete: document.getElementById('listDelete'),
};
const viewOnly = new URLSearchParams(location.search).get('view') === '1';

/* ================== Viewer State ================== */
let renderer, scene, camera, controls, tcontrols, pinGroup, loader, currentModel=null;
let perspCam, orthoCam; let usingOrtho=false;
let raycaster = new THREE.Raycaster(), pointer = new THREE.Vector2();
let addPinMode=false, currentColor='#ff6b6b';
let pins=[], selectedPinId=null, undoStack=[];
let glbParents=[], glbMetaCache=null;

/* materials (per-material state persisted) */
let materials=[];
const materialKeyByMaterial = new Map();   // Material -> key
const materialByKey = new Map();           // key -> Material
const matOriginals=new WeakMap();
const matState = new Map();                // key -> state
const imageBlobCache = new Map();
let filterColors = new Set();
let activeSheet = { sheetId:null, title:'pins' };

const debounce = (fn,ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
const debouncedSave = debounce(()=> upsertPinToSheet(), 500);
const PRESET_COLORS = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#ef476f','#b5179e','#4361ee','#4cc9f0','#ff9f1c'];

function toast(msg){ el.statusLabel.textContent=msg; setTimeout(()=> el.statusLabel.textContent= viewOnly ? 'Èñ≤Ë¶ß„É¢„Éº„Éâ' : 'Ready', 1800); }
function ensureArray(x){ return Array.isArray(x)?x:[]; }
function normalizeHex(c){ const t = new THREE.Color(c); return '#' + t.getHexString(); }
function enforceViewOnlyMode(){
  if (!viewOnly) return;
  document.body.classList.add('viewonly');
  el.capTitle.readOnly = true; el.capBody.readOnly  = true;
}

/* ========= HEIC helpers ========= */
function loadScriptOnce(src){
  return new Promise((resolve,reject)=>{
    const s=document.createElement('script'); s.src=src; s.async=true; s.onload=resolve; s.onerror=reject;
    document.head.appendChild(s);
  });
}
async function ensureHeic2any(){
  if(typeof window.heic2any === 'function') return true;
  try{ await loadScriptOnce('https://cdn.jsdelivr.net/npm/heic2any@0.0.5/dist/heic2any.min.js'); }catch{}
  if(typeof window.heic2any === 'function') return true;
  try{ await loadScriptOnce('https://unpkg.com/heic2any@0.0.5/dist/heic2any.min.js'); }catch{}
  return (typeof window.heic2any === 'function');
}
function upscaleThumbnailUrl(u, size=2048){
  if(!u) return u;
  try{
    const url = new URL(u);
    url.search = url.search.replace(/(\bs=)(\d+)/, `$1${size}`);
    url.pathname = url.pathname.replace(/=s(\d+)/, `=s${size}`);
    if(!/(\bs=)/.test(url.search) && !/=s\d+/.test(url.pathname)){
      url.searchParams.set('s', String(size));
    }
    return url.toString();
  }catch{ return u.replace(/=s(\d+)/, `=s${size}`); }
}

/* ========= UI wire ========= */
document.getElementById('btnSignIn').addEventListener('click', startSignIn);
const _pc = document.getElementById('previewClose'); if(_pc){ _pc.addEventListener('click', ()=>{ el.viewerPreview.classList.add('hidden'); }); }
(async () => { ensureGIS().catch(()=>{}); ensureGapiClient().catch(()=>{}); })();

/* ========= Viewer ========= */
let rendererLoopId=null;
function viewerInit(){
  renderer = new THREE.WebGLRenderer({
    canvas: el.viewerCanvas,
    antialias: !IS_IOS,                 // iOS„ÅØAA„Ç™„Éï„ÅßÂÆâÂÆöÊÄß
    powerPreference: 'low-power',
    preserveDrawingBuffer: false
  });
  const cap = IS_IOS ? 1 : 1.5;         // iOS„ÅØDPR=1Âõ∫ÂÆö„ÄÅ‰ªñ„ÅØ1.5‰∏äÈôê
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, cap));

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0f16);
  perspCam = new THREE.PerspectiveCamera(60, 2, 0.1, 5000);
  perspCam.position.set(2.8,1.6,3.6);
  orthoCam = new THREE.OrthographicCamera(-2,2,2,-2, -5000, 5000);
  camera = perspCam; usingOrtho=false;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x223355, 0.6); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3,5,4); scene.add(dir);

  buildControls();

  pinGroup = new THREE.Group(); scene.add(pinGroup);
  loader = new GLTFLoader();

  window.addEventListener('resize', resize, { passive:true });
  el.viewerCanvas.addEventListener('pointerdown', onPointerDown, { passive:false });
  el.projOrtho.addEventListener('change', ()=> { toggleProjection(el.projOrtho.checked); debouncedSaveMaterials(); });
  resize();
  const loop = ()=>{ renderer.render(scene,camera); updateConnector(); rendererLoopId=requestAnimationFrame(loop); };
  loop();
}
function buildControls(){
  if(controls){ controls.dispose(); }
  controls = new OrbitControls(camera, el.viewerCanvas);
  controls.target.set(0,0,0); controls.update();
  controls.addEventListener('change', updateConnector);
  if(tcontrols){ scene.remove(tcontrols); if(tcontrols && typeof tcontrols.dispose==='function'){ tcontrols.dispose(); } }
  tcontrols = new TransformControls(camera, el.viewerCanvas);
  tcontrols.setSize(0.9); tcontrols.setSpace('world');
  tcontrols.addEventListener('dragging-changed', e=>{ controls.enabled = !e.value; });
  tcontrols.addEventListener('change', ()=>{
    if(!selectedPinId || !tcontrols.object || !tcontrols.visible) return;
    const p=pins.find(x=>x.id===selectedPinId); if(!p) return;
    p.pos.copy(tcontrols.object.position);
    renderNow(); debouncedSave();
  });
  scene.add(tcontrols); tcontrols.visible=false; tcontrols.enabled=false;
}
function resize(){
  const w = el.viewerCanvas.clientWidth || el.viewerCanvas.parentElement.clientWidth;
  const h = el.viewerCanvas.clientHeight || el.viewerCanvas.parentElement.clientHeight;
  renderer.setSize(w,h,false);
  if(camera.isPerspectiveCamera){
    camera.aspect = w/h;
  }else{ fitOrthoFrustum(); }
  camera.updateProjectionMatrix(); updateConnector();
}
function renderNow(){ renderer.render(scene,camera); updateConnector(); }
function sceneBounds(){
  if(!currentModel){ return { center:new THREE.Vector3(0,0,0), radius: 2 }; }
  const box = new THREE.Box3().setFromObject(currentModel);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const radius = Math.max(size.x,size.y,size.z)/2 || 1;
  return { center, radius: radius*1.2 };
}
function focusOrigin(){
  const { radius } = sceneBounds();
  const dist = Math.max(radius*2.2, 1.5);
  const dirv = new THREE.Vector3(1,0.6,1).normalize();
  const origin = new THREE.Vector3(0,0,0);
  camera.position.copy(origin.clone().addScaledVector(dirv, dist));
  controls.target.copy(origin);
  if(camera.isOrthographicCamera) fitOrthoFrustum();
  controls.update(); updateConnector();
}
function fitOrthoFrustum(){
  const { radius } = sceneBounds();
  const w = el.viewerCanvas.clientWidth || 1;
  const h = el.viewerCanvas.clientHeight || 1;
  const aspect = w/h;
  const size = radius*ORTHO_MARGIN;
  orthoCam.left = -size*aspect;
  orthoCam.right = size*aspect;
  orthoCam.top = size;
  orthoCam.bottom = -size;
  orthoCam.updateProjectionMatrix();
}
function toggleProjection(useOrtho){
  usingOrtho = !!useOrtho;
  const origin = new THREE.Vector3(0,0,0);
  const dir = camera.position.clone().sub(controls.target).normalize();
  const dist = camera.position.distanceTo(controls.target);
  if(usingOrtho){
    fitOrthoFrustum();
    orthoCam.position.copy(origin.clone().addScaledVector(dir, dist));
    camera = orthoCam;
  }else{
    perspCam.position.copy(origin.clone().addScaledVector(dir, Math.max(dist, 0.1)));
    camera = perspCam;
  }
  buildControls();
  renderNow();
}

/* ========= Pins & Connector ========= */
function addUndo(u){ undoStack.push(u); }
function createPin(pos,color){
  if(viewOnly) return;
  const id=`p_${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
  const pin={id,pos:pos.clone(),color:normalizeHex(color||'#ff6b6b'),title:'',body:'',images:[],mesh:null};
  pins.push(pin);
  filterColors.add(pin.color);
  placePinMesh(pin);
  refreshPinsList();
  buildColorFilter();
  selectPin(id);
  addUndo({type:'add',id});
  upsertPinToSheet();
}
function placePinMesh(pin){
  if(pin.mesh){ pinGroup.remove(pin.mesh); pin.mesh.geometry.dispose(); pin.mesh.material.dispose(); pin.mesh=null; }
  const geo=new THREE.SphereGeometry(0.006,16,16);
  const mat=new THREE.MeshBasicMaterial({color:new THREE.Color(pin.color)});
  const mesh=new THREE.Mesh(geo,mat);
  mesh.position.copy(pin.pos); mesh.userData.pinId=pin.id;
  pin.mesh=mesh; pinGroup.add(mesh);
  applyPinVisibilityFilter();
}
function selectPin(id,{fly}={}){
  selectedPinId=id;
  const p=pins.find(x=>x.id===id);
  if(!p){ el.rightEditor.classList.add('hidden'); el.rightNoSel.classList.remove('hidden'); updateViewerPreviewForPin(null); return; }
  el.rightNoSel.classList.add('hidden'); el.rightEditor.classList.remove('hidden');
  el.capTitle.value = p.title || '';
  el.capBody.value  = p.body  || '';
  renderThumbs(p);
  updateViewerPreviewForPin(p);
  if(fly){ const {x,y,z}=p.pos; controls.target.set(0,0,0); camera.position.lerp(new THREE.Vector3(x,y,z).addScaledVector(new THREE.Vector3(1,0.6,1).normalize(), 0.6), 0.0); controls.update(); }
  if(tcontrols.visible && p.mesh){ tcontrols.attach(p.mesh); }
  updateConnector();
}
function onPointerDown(e){
  if(!currentModel) return;
  el.viewerCanvas.style.cursor = (addPinMode || e.shiftKey) && !viewOnly ? 'crosshair' : 'default';

  const rect=el.viewerCanvas.getBoundingClientRect();
  pointer.x=((e.clientX-rect.left)/rect.width)*2-1;
  pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(pointer,camera);

  const hitsPins = raycaster.intersectObjects(pinGroup.children,false);
  if(hitsPins.length){ selectPin(hitsPins[0].object.userData.pinId, {fly:true}); return; }

  if((e.shiftKey || addPinMode) && !viewOnly){
    const hitModel = currentModel? raycaster.intersectObject(currentModel,true): [];
    if(hitModel.length){
      const pt = hitModel[0].point.clone();
      createPin(pt,currentColor);
      if(addPinMode){ addPinMode=false; el.btnAddPin.textContent='Ôºã „Éî„É≥ËøΩÂä†„É¢„Éº„Éâ'; el.modeLabel.textContent='Orbit'; el.viewerCanvas.style.cursor='default'; }
      return;
    }
  }
}
function updateConnector(){
  const p = pins.find(x=>x.id===selectedPinId);
  if(!p || !p.mesh || el.viewerPreview.classList.contains('hidden') || !pinGroup.visible || !p.mesh.visible){
    el.connLine.style.display = 'none'; el.connDot.style.display = 'none'; return;
  }
  const v = p.pos.clone().project(camera);
  const rect = el.viewerCanvas.getBoundingClientRect();
  const x = (v.x + 1) / 2 * rect.width;
  const y = (1 - (v.y + 1) / 2) * rect.height;
  const rectPrev = el.viewerPreview.getBoundingClientRect();
  const bx = (rectPrev.left - rect.left);
  const by = (rectPrev.top - rect.top) + rectPrev.height/2;
  const svg = el.connector;
  svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
  el.connLine.setAttribute('x1', x); el.connLine.setAttribute('y1', y);
  el.connLine.setAttribute('x2', bx); el.connLine.setAttribute('y2', by);
  el.connLine.style.display = 'block';
  el.connDot.setAttribute('cx', x); el.connDot.setAttribute('cy', y);
  el.connDot.style.display = 'block';
}

/* ========= Preview ========= */
let previewZoom = 1.0;
function applyPreviewZoom(){ el.previewInner.style.transform = `scale(${previewZoom})`; }
el.previewZoom.addEventListener('input', ()=>{ previewZoom = parseFloat(el.previewZoom.value)||1; el.previewZoomVal.textContent = previewZoom.toFixed(2) + '√ó'; applyPreviewZoom(); });
el.previewReset.addEventListener('click', ()=>{ previewZoom = 1; el.previewZoom.value = 1; el.previewZoomVal.textContent = '1.00√ó'; applyPreviewZoom(); });

async function setPreview(ref, p){
  try{
    const msg = document.getElementById('previewMsg'); if(msg) msg.style.display='none';
    if(ref){
    el.previewErr.style.display='none';
    const src = await resolveImageObjectURL(ref, {preferThumb:false});
    el.previewImg.src = src;
    el.previewImg.onerror = ()=>{ el.previewErr.style.display='inline'; };
    el.capTitleLine.textContent = (p && p.title) ? p.title : '';
    el.capBodyLine.textContent  = (p && p.body)  ? p.body  : '';
    el.viewerPreview.classList.remove('hidden');
    applyPreviewZoom(); updateConnector();
    }
    else {
      const msg = document.getElementById('previewMsg');
      if(msg){ msg.textContent = 'ÁîªÂÉè„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì'; msg.style.display = 'block'; }
      const img = document.getElementById('previewImg'); if(img){ img.removeAttribute('src'); }
      el.capTitleLine.textContent = (p && p.title) ? p.title : '';
      el.capBodyLine.textContent  = (p && p.body)  ? p.body  : '';
      el.viewerPreview.classList.remove('hidden');
      applyPreviewZoom(); updateConnector();
    }
  }
  catch(e){
    console.warn('preview failed', e);
    el.previewErr.style.display='inline';
    el.viewerPreview.classList.remove('hidden');
  }
}
function updateViewerPreviewForPin(p){ setPreview(p && p.images && p.images[0] ? p.images[0] : null, p); }

/* ========= Image resolve & Drive ========= */
function parseImageRef(ref){
  if(typeof ref === 'string' && /^(blob:|data:|https?:)/i.test(ref)){ return { kind:'url', url: ref }; }
  if(typeof ref === 'string' && ref.startsWith('drive:')){
    const [, rest] = ref.split(':'); const [id, mime] = rest.split('|');
    return { kind:'drive', id, mime: mime||null };
  }
  if(typeof ref === 'string'){
    const id = extractDriveFileId(ref);
    if(id){ return { kind:'drive', id, mime:null }; }
  }
  return { kind:'url', url: String(ref) };
}
async function resolveImageObjectURL(ref, {preferThumb=false}={}){
  const key = typeof ref==='string'?ref:JSON.stringify(ref);
  if(imageBlobCache.has(key)) return imageBlobCache.get(key);

  const info = parseImageRef(ref);
  let outUrl;

  if(info.kind === 'url'){ imageBlobCache.set(key, info.url); return info.url; }

  const meta = await driveFileMeta(info.id);
  const isHeic = isHeicMimeOrExt(meta.mimeType, meta.fileExtension);

  if(isHeic){
    const ok = await ensureHeic2any();
    if(ok){
      const blob = await driveFileFetchBlob(meta.id);
      const jpegBlob = await window.heic2any({ blob, toType:'image/jpeg', quality:1.0 });
      const jpg = Array.isArray(jpegBlob) ? jpegBlob[0] : jpegBlob;
      outUrl = URL.createObjectURL(jpg);
    }else if(meta.hasThumbnail && meta.thumbnailLink){
      const hi = upscaleThumbnailUrl(meta.thumbnailLink, 2048);
      const sep = hi.includes('?') ? '&' : '?';
      outUrl = hi + sep + 'access_token=' + encodeURIComponent(accessToken);
    }else{
      throw new Error('HEIC preview unavailable (no heic2any & no thumbnailLink)');
    }
  }else{
    if(preferThumb && meta.hasThumbnail && meta.thumbnailLink){
      const hi = upscaleThumbnailUrl(meta.thumbnailLink, 1024);
      const sep = hi.includes('?') ? '&' : '?';
      outUrl = hi + sep + 'access_token=' + encodeURIComponent(accessToken);
    }else{
      const blob = await driveFileFetchBlob(meta.id);
      outUrl = URL.createObjectURL(blob);
    }
  }

  imageBlobCache.set(key, outUrl);
  return outUrl;
}
async function driveFileMeta(fileId){
  const meta = await gapi.client.drive.files.get({
    fileId, fields:'id,name,mimeType,fileExtension,hasThumbnail,thumbnailLink,parents',
    supportsAllDrives:true
  });
  return meta.result;
}
async function driveFileFetchBlob(fileId, retry=1){
  const dlUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media&supportsAllDrives=true`;
  const res = await fetch(dlUrl, { headers:{ Authorization:`Bearer ${accessToken}` } });
  if(res.status === 401 && retry>0){
    try{ tokenClient && tokenClient.requestAccessToken({ prompt:'' }); }catch{}
    return driveFileFetchBlob(fileId, retry-1);
  }
  if(!res.ok) throw new Error('image fetch failed '+res.status);
  return await res.blob();
}
function isHeicMimeOrExt(mime, ext){ return /heic|heif/i.test(mime||'') || /heic|heif/i.test(ext||''); }


function extractDriveFileId(input){
  try{
    if(!input) return '';
    let s = String(input).trim();
    // URL patterns first
    let m = s.match(/\bfile\/d\/([A-Za-z0-9_-]{20,})/); if(m && m[1]) return m[1];
    m = s.match(/[?&]id=([A-Za-z0-9_-]{20,})/); if(m && m[1]) return m[1];
    // bare-like
    s = s.split(/[\s\u3000]+/)[0];
    s = s.replace(/^[^A-Za-z0-9_-]+|[^A-Za-z0-9_-]+$/g, '');
    if(/^[A-Za-z0-9_-]{30,}$/.test(s)) return s; // Drive IDs are typically >=30 chars
    return '';
  }catch(e){ return ''; }
}
function extractSpreadsheetId(input){
  try{
    if(!input) return '';
    let s = String(input).trim();
    if(/^[A-Za-z0-9_-]{20,}$/.test(s)) return s;
    let m = s.match(/spreadsheets\/d\/([A-Za-z0-9_-]{10,})/); if(m && m[1]) return m[1];
    m = s.match(/[?&]id=([A-Za-z0-9_-]{10,})/); if(m && m[1]) return m[1];
    s = s.split(/[\s\u3000]+/)[0];
    s = s.replace(/^[^A-Za-z0-9_-]+|[^A-Za-z0-9_-]+$/g, '');
    return /^[A-Za-z0-9_-]{10,}$/.test(s) ? s : '';
  }catch(e){ return ''; }
}
function makeDriveRef(id, mime){ return `drive:${id}|${mime||''}`; }

/* ========= Materials ========= */
function ensureMatRecord(m){
  if(matOriginals.has(m)) return;
  matOriginals.set(m, {
    color: (m.color ? m.color.clone() : new THREE.Color(0xffffff)),
    map: m.map || null,
    alphaMap: m.alphaMap || null,
    transparent: !!m.transparent,
    opacity: (m.opacity ?? 1),
    alphaTest: (m.alphaTest ?? 0),
    side: m.side ?? THREE.FrontSide,
    depthWrite: m.depthWrite,
    depthTest: m.depthTest,
    blending: m.blending,
    toneMapped: m.toneMapped,
    wasUnlit: false,
    unlitMat: null
  });
}
function objectPath(node) {
  const names = [];
  let cur = node;
  while (cur && cur.parent) {
    names.push(cur.name && cur.name.trim() ? cur.name : '_' + ((cur.uuid && cur.uuid.slice ? cur.uuid.slice(0,8) : '') || 'node'));
    cur = cur.parent;
  }
  names.reverse();
  return names.join('/');
}
function indexMaterialsByKey(){
  materialKeyByMaterial.clear();
  materialByKey.clear();
  if (!currentModel) return;
  currentModel.traverse(obj=>{
    if (!obj.material) return;
    const basePath = objectPath(obj);
    if (Array.isArray(obj.material)) {
      obj.material.forEach((m, idx)=>{
        const key = `${basePath}#${idx}`;
        materialKeyByMaterial.set(m, key);
        materialByKey.set(key, m);
        ensureMatRecord(m);
        if(!matState.has(key)){
          matState.set(key, { unlit:false, doubleSided:(m.side===THREE.DoubleSide), opacity:(m.opacity??1), invertRGB:false, whiteToAlpha:false, alphaTest:(m.alphaTest??0) });
        }
      });
    } else {
      const key = `${basePath}#0`;
      materialKeyByMaterial.set(obj.material, key);
      materialByKey.set(key, obj.material);
      const m = obj.material; ensureMatRecord(m);
      if(!matState.has(key)){
        matState.set(key, { unlit:false, doubleSided:(m.side===THREE.DoubleSide), opacity:(m.opacity??1), invertRGB:false, whiteToAlpha:false, alphaTest:(m.alphaTest??0) });
      }
    }
  });
}
function collectMaterials(){
  materials=[]; 
  const set = new Set();
  if(!currentModel) return;

  indexMaterialsByKey();
  currentModel.traverse(obj=>{
    const m=obj.material;
    if(Array.isArray(m)){ m.forEach(mm=>{ if(mm && !set.has(mm)){ set.add(mm); materials.push(mm); ensureMatRecord(mm); } }); }
    else if(m){ if(!set.has(m)){ set.add(m); materials.push(m); ensureMatRecord(m); } }
  });

  el.matSelect.innerHTML = '<option value="__all__">ÔºàÂÖ®„Éû„ÉÜ„É™„Ç¢„É´ÔºöÁ∑®ÈõÜ‰∏çÂèØÔºâ</option>';
  materials.forEach((m,idx)=>{
    const key = materialKeyByMaterial.get(m);
    if(!key) return;
    const name = (m.name && m.name.trim()) ? m.name : `Material_${idx}`;
    const opt=document.createElement('option'); 
    opt.value=key;
    opt.textContent=name;
    el.matSelect.appendChild(opt);
    if(!matState.has(key)){
      matState.set(key, {
        unlit:false,
        doubleSided:(m.side===THREE.DoubleSide),
        opacity:(m.opacity??1),
        invertRGB:false,
        whiteToAlpha:false,
        alphaTest:(m.alphaTest??0)
      });
    }
  });

  if(el.matSelect.options.length>1){
    el.matSelect.value = el.matSelect.options[1].value;
  }else{
    el.matSelect.value = '__all__';
  }
  applyMaterialUIFromSelection();
}
function getSelectedOriginalMaterial(){
  const val=el.matSelect.value;
  if(val==='__all__') return null;
  return materialByKey.get(val) || null;
}
function applyMaterialUIFromSelection(){
  const key = el.matSelect.value;
  const disable = (key === '__all__');
  ['matUnlit','matDoubleSided','matOpacity','matInvert','matWhiteTransparent','matThreshold']
    .forEach(id=>{ document.getElementById(id).disabled = disable || viewOnly; });
  if(disable) return;
  const st = matState.get(key) || { unlit:false,doubleSided:false,opacity:1,invertRGB:false,whiteToAlpha:false,alphaTest:0 };
  el.matUnlit.checked = !!st.unlit;
  el.matDoubleSided.checked = !!st.doubleSided;
  el.matOpacity.value = String(st.opacity ?? 1);
  el.matOpacityVal.textContent = (Number(st.opacity ?? 1)).toFixed(2);
  el.matInvert.checked = !!st.invertRGB;
  el.matWhiteTransparent.checked = !!st.whiteToAlpha;
  el.matThreshold.value = String(st.alphaTest ?? 0);
  el.matThresholdVal.textContent = (Number(st.alphaTest ?? 0)).toFixed(2);
}
el.matSelect.addEventListener('change', ()=> applyMaterialUIFromSelection());

async function applyMaterialFromUIToSelected(){
  const orig = getSelectedOriginalMaterial();
  if(!orig) return;
  const key = materialKeyByMaterial.get(orig);
  const st = matState.get(key) || {};
  st.unlit = !!el.matUnlit.checked;
  st.doubleSided = !!el.matDoubleSided.checked;
  st.opacity = Number(el.matOpacity.value ?? 1);
  st.invertRGB = !!el.matInvert.checked;
  st.whiteToAlpha = !!el.matWhiteTransparent.checked;
  st.alphaTest = Number(el.matThreshold.value ?? 0);
  matState.set(key, st);
  await applyStateToMaterial(orig, st);
  renderNow();
  debouncedSaveMaterials();
}
['change','input'].forEach(ev=>{
  ['matUnlit','matDoubleSided','matOpacity','matInvert','matWhiteTransparent','matThreshold']
    .forEach(id=> document.getElementById(id).addEventListener(ev, ()=> applyMaterialFromUIToSelected()));
});
el.matOpacity.addEventListener('input', ()=> el.matOpacityVal.textContent = parseFloat(el.matOpacity.value).toFixed(2));
el.matThreshold.addEventListener('input', ()=> el.matThresholdVal.textContent = parseFloat(el.matThreshold.value).toFixed(2));

function getActiveMaterialFor(originalM){
  const rec = matOriginals.get(originalM);
  return (rec && rec.wasUnlit && rec.unlitMat) ? rec.unlitMat : originalM;
}
function copyTextureParams(from, to){
  to.wrapS = from.wrapS; to.wrapT = from.wrapT;
  to.repeat.copy(from.repeat); to.offset.copy(from.offset);
  to.center.copy(from.center); to.rotation = from.rotation;
  to.flipY = from.flipY;
  to.magFilter = from.magFilter; to.minFilter = from.minFilter;
  to.generateMipmaps = from.generateMipmaps;
  to.anisotropy = from.anisotropy;
  to.colorSpace = from.colorSpace ?? THREE.SRGBColorSpace;
}
async function processTextureToCanvasTextureFromOriginal(originalTex, { invertRGB=false, alphaFromWhite=false, threshold=0 }){
  if(!originalTex || !originalTex.image) return null;
  const image = originalTex.image;
  const w = image.width || image.videoWidth || 0;
  const h = image.height || image.videoHeight || 0;
  if(!w || !h) return null;
  const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  try{ ctx.drawImage(image, 0, 0, w, h); }
  catch(e){ try{ const bmp = await createImageBitmap(image); ctx.drawImage(bmp,0,0,w,h); } catch(e2){ return null; } }
  const img = ctx.getImageData(0,0,w,h); const data = img.data;
  for(let i=0;i<data.length;i+=4){
    let r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
    if(invertRGB){ r=255-r; g=255-g; b=255-b; }
    let alpha=a;
    if(alphaFromWhite){
      const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
      let alf = 1 - L;
      if(threshold>0){ alf = (alf >= threshold) ? alf : 0; }
      alpha = Math.round(Math.min(1,Math.max(0,alf))*255);
    }
    data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=alpha;
  }
  ctx.putImageData(img,0,0);
  const ctex = new THREE.CanvasTexture(canvas);
  copyTextureParams(originalTex, ctex);
  ctex.needsUpdate = true;
  return ctex;
}
async function applyStateToMaterial(origM, st){
  ensureMatRecord(origM);
  const rec = matOriginals.get(origM);

  if(st.unlit && !rec.wasUnlit){
    const active = getActiveMaterialFor(origM);
    const um = new THREE.MeshBasicMaterial();
    um.color = (active.color ? active.color.clone() : rec.color.clone());
    um.map = active.map || rec.map || null;
    um.transparent = active.transparent;
    um.opacity = active.opacity;
    um.alphaTest = active.alphaTest;
    um.side = active.side;
    um.depthWrite = active.depthWrite;
    um.depthTest = active.depthTest;
    um.blending = active.blending;
    um.toneMapped = false;
    rec.unlitMat = um; rec.wasUnlit = true;
    currentModel.traverse(obj=>{
      const m=obj.material;
      if(m===origM || m===active){ obj.material = um; }
      else if(Array.isArray(m)){ obj.material = m.map(x=> (x===origM||x===active)? um : x ); }
    });
  }else if(!st.unlit && rec.wasUnlit){
    currentModel.traverse(obj=>{
      const m=obj.material;
      if(m===rec.unlitMat){ obj.material = origM; }
      else if(Array.isArray(m)){ obj.material = m.map(x=> (x===rec.unlitMat)? origM : x ); }
    });
    rec.wasUnlit = false;
  }

  const mat = getActiveMaterialFor(origM);
  mat.side = st.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
  const willTransparent = (st.whiteToAlpha || (st.opacity < 1.0));
  mat.transparent = willTransparent;
  mat.opacity = st.opacity ?? 1;
  mat.alphaTest = st.alphaTest ?? 0;
  mat.depthWrite = !mat.transparent || (mat.alphaTest>0);

  if((st.invertRGB || st.whiteToAlpha) && matOriginals.get(origM).map){
    try{
      const processed = await processTextureToCanvasTextureFromOriginal(matOriginals.get(origM).map, { invertRGB: st.invertRGB, alphaFromWhite: st.whiteToAlpha, threshold: st.alphaTest||0 });
      if(processed){ mat.map = processed; mat.map.needsUpdate = true; }
    }catch(e){ console.warn('texture process failed', e); }
  }else{
    const rec0 = matOriginals.get(origM);
    mat.map = rec0.map || null;
    if(mat.map) mat.map.needsUpdate = true;
  }
  if(!mat.color && matOriginals.get(origM).color){ mat.color = matOriginals.get(origM).color.clone(); }
  if(mat.color) mat.color.needsUpdate = true;
  mat.needsUpdate = true;
}

/* ========= Camera views ========= */
el.viewFront.addEventListener('click', ()=> { setNamedView('front'); debouncedSaveMaterials(); });
el.viewBack.addEventListener('click',  ()=> { setNamedView('back');  debouncedSaveMaterials(); });
el.viewLeft.addEventListener('click',  ()=> { setNamedView('left');  debouncedSaveMaterials(); });
el.viewRight.addEventListener('click', ()=> { setNamedView('right'); debouncedSaveMaterials(); });
el.viewTop.addEventListener('click',   ()=> { setNamedView('top');   debouncedSaveMaterials(); });
el.viewBottom.addEventListener('click',()=> { setNamedView('bottom');debouncedSaveMaterials(); });

function setNamedView(name){
  const { radius } = sceneBounds();
  const d = Math.max(radius*2.2, 1.5);
  let dir = new THREE.Vector3(d,0,0);
  switch(name){
    case 'front': dir.set(d,0,0); break;
    case 'back':  dir.set(-d,0,0); break;
    case 'left':  dir.set(0,0,-d); break;
    case 'right': dir.set(0,0,d); break;
    case 'top':   dir.set(0,d,0); break;
    case 'bottom':dir.set(0,-d,0); break;
  }
  const origin = new THREE.Vector3(0,0,0);
  camera.position.copy(origin.clone().add(dir));
  controls.target.copy(origin);
  if(camera.isOrthographicCamera) fitOrthoFrustum();
  controls.update(); renderNow();
}

/* ========= SheetsÔºöÂêåÈöéÂ±§„Åß‰ΩúÊàê/Ê§úÁ¥¢ ========= */
async function findOrCreateSpreadsheetInGlbFolder(glbMeta){
  if (!glbMeta || !glbMeta.id) throw new Error('GLB„É°„Çø„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
  const parents = glbMeta.parents || [];
  let found = null;
  for (const parent of (parents.length ? parents : ['root'])) {
    const q = [
      `'${parent}' in parents`,
      `mimeType='application/vnd.google-apps.spreadsheet'`,
      `trashed=false`,
      `appProperties has { key='lociFor'  and value='${glbMeta.id }' }`
    ].join(' and ');
    const resp = await gapi.client.drive.files.list({
      q, fields: 'files(id,name)',
      includeItemsFromAllDrives: true, supportsAllDrives: true, pageSize: 10,
    });
    if ((resp.result && resp.result.files && resp.result.files.length)) { found = resp.result.files[0]; break; }
  }
  if (found) return found.id;

  const name = `LociMyu - ${glbMeta.name}`;
  const create = await gapi.client.drive.files.create({
    resource: {
      name,
      mimeType: 'application/vnd.google-apps.spreadsheet',
      parents: (parents && parents.length) ? parents : undefined,
      appProperties: { lociFor: glbMeta.id },
    },
    fields: 'id',
    supportsAllDrives: true
  });
  const spreadsheetId = create.result.id;

  await gapi.client.sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    resource: {
      requests: [
        { updateSpreadsheetProperties: { properties: { title: name }, fields: 'title' } },
        { addSheet: { properties: { title: 'pins' } } }
      ]
    }
  });
  await gapi.client.sheets.spreadsheets.values.update({
    spreadsheetId, range: 'pins!A1',
    valueInputOption:'RAW',
    resource:{ values: [[ 'pin_id','title','body','x','y','z','color','images','updated_at' ]] }
  });
  return spreadsheetId;
}

/* ========= MetaÔºàK/LÂàóÔºâ ‰øùÂ≠ò„ÉªÂæ©ÂÖÉ ========= */
const META_MARKER_RANGE = ()=> `${activeSheet.title}!K1`;
const META_MAT_KEY_RANGE = ()=> `${activeSheet.title}!K2:L2`;
const META_VIEW_KEY_RANGE = ()=> `${activeSheet.title}!K3:L3`;

function safeParseJSON(s, fallback){ try{ return s ? JSON.parse(s) : fallback; }catch{ return fallback; } }

async function loadSheetMeta(spreadsheetId){
  try{
    const get = await gapi.client.sheets.spreadsheets.values.batchGet({
      spreadsheetId,
      ranges: [ META_MARKER_RANGE(), META_MAT_KEY_RANGE(), META_VIEW_KEY_RANGE() ]
    });
    const vals = (get.result.valueRanges || []).map(v=>v.values||[]);
    const matJson = ((vals[1] && vals[1][0]) ? vals[1][0][1] : undefined) || '';
    const viewJson = ((vals[2] && vals[2][0]) ? vals[2][0][1] : undefined) || '';
    const m = safeParseJSON(matJson, null);
    const materials = normalizeMaterialsJSON(m);
    const viewer = safeParseJSON(viewJson, { version:1, bgColor:'#0a0f16', projection:'perspective' });
    return { materials, viewer };
  }catch(e){
    console.warn('loadSheetMeta failed', e);
    return { materials:{version:2,byKey:{}}, viewer:{version:1,bgColor:'#0a0f16',projection:'perspective'} };
  }
}
function normalizeMaterialsJSON(m){
  if(!m) return { version:2, byKey:{} };
  if(m.version===2 && m.byKey) return m;
  if(Array.isArray(m.items)){
    const byKey = {};
    m.items.forEach(it=>{
      if(!it || !it.key) return;
      byKey[it.key] = {
        unlit: !!it.unlit,
        doubleSided: !!it.doubleSided,
        opacity: Number(it.opacity ?? 1),
        invertRGB: !!it.invertRGB,
        whiteToAlpha: !!it.whiteToAlpha,
        alphaTest: Number(it.alphaTest ?? 0)
      };
    });
    return { version:2, byKey };
  }
  return { version:2, byKey:{} };
}
async function saveSheetMeta(spreadsheetId, { materials, viewer }){
  if(viewOnly) return;
  const data = [
    { range: META_MARKER_RANGE(), values: [[ 'LOCI_META_V1' ]] },
    { range: META_MAT_KEY_RANGE(), values: [[ 'materials_json', JSON.stringify(materials) ]] },
    { range: META_VIEW_KEY_RANGE(), values: [[ 'viewer_json', JSON.stringify(viewer) ]] },
  ];
  await gapi.client.sheets.spreadsheets.values.batchUpdate({
    spreadsheetId,
    valueInputOption:'RAW',
    data
  });
}
function serializeMaterialsForSheet(){
  const byKey = {};
  for(const [key, st] of matState){
    if(materialByKey.has(key)){
      byKey[key] = {
        unlit: !!st.unlit,
        doubleSided: !!st.doubleSided,
        opacity: Number(st.opacity ?? 1),
        invertRGB: !!st.invertRGB,
        whiteToAlpha: !!st.whiteToAlpha,
        alphaTest: Number(st.alphaTest ?? 0)
      };
    }
  }
  return { version:2, byKey };
}
function serializeViewerPrefs(){
  return {
    version: 1,
    bgColor: el.bgColor.value || '#0a0f16',
    projection: usingOrtho ? 'orthographic' : 'perspective'
  };
}
async function applyMaterialsFromSheet(materialsData){
  if(!materialsData || !materialsData.byKey) return;
  for(const [key, st] of Object.entries(materialsData.byKey)){
    matState.set(key, { ...st });
  }
  for(const [key, st] of matState){
    const mat = materialByKey.get(key);
    if(!mat) continue;
    await applyStateToMaterial(mat, st);
  }
  applyMaterialUIFromSelection();
  renderNow();
}
async function applyViewerPrefs(viewerData){
  if(!viewerData) return;
  if(viewerData.bgColor){
    el.bgColor.value = viewerData.bgColor;
    scene.background = new THREE.Color(viewerData.bgColor);
  }
  if(viewerData.projection){
    const wantOrtho = (viewerData.projection === 'orthographic');
    el.projOrtho.checked = wantOrtho;
    toggleProjection(wantOrtho);
  }
  renderNow();
}
const debouncedSaveMaterials = debounce(async ()=>{
  if(viewOnly) return;
  const spreadsheetId = extractSpreadsheetId(el.inputSheet.value.trim());
  if (!spreadsheetId || !activeSheet.sheetId) return;
  const materialsData = serializeMaterialsForSheet();
  const viewerData = serializeViewerPrefs();
  try{ await saveSheetMeta(spreadsheetId, { materials: materialsData, viewer: viewerData }); }
  catch(e){ console.warn('saveSheetMeta failed', e); }
}, 600);
el.bgColor.addEventListener('input', ()=>{ scene.background = new THREE.Color(el.bgColor.value); renderNow(); debouncedSaveMaterials(); });

/* ========= Thumbs / Preview ========= */
function renderThumbs(p){
  const thumbs=el.thumbs; thumbs.innerHTML='';
  ensureArray(p.images).forEach(async (ref, idx)=>{
    const wrap=document.createElement('div'); wrap.className='thumb'; thumbs.appendChild(wrap);
    const img=document.createElement('img'); img.alt = 'thumb';
    const del=document.createElement('div'); del.className='del'; del.textContent='√ó'; del.title='„Åì„ÅÆÁîªÂÉè„Çí„Ç≠„É£„Éó„Ç∑„Éß„É≥„Åã„ÇâÂ§ñ„Åô';
    del.addEventListener('click', (ev)=>{
      if(viewOnly) return;
      ev.stopPropagation(); const wasPreview = (el.previewImg.src && el.previewImg.src === img.src);
      p.images.splice(idx,1); renderThumbs(p);
      if(wasPreview){ const next = p.images[0] || null; setPreview(next, p); }
      upsertPinToSheet();
    });
    wrap.appendChild(img); wrap.appendChild(del);
    try{
      const src = await resolveImageObjectURL(ref, {preferThumb:true});
      img.src = src;
      img.addEventListener('click', async ()=>{ setPreview(ref, p); });
    }catch{
      wrap.classList.add('error'); wrap.title = 'ÁîªÂÉè„ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü';
    }
  });
}

/* ========= Caption bindings ========= */
document.getElementById('btnSavePin').addEventListener('click', ()=> upsertPinToSheet());
el.capTitle.addEventListener('input', ()=>{ const p=pins.find(x=>x.id===selectedPinId); if(p){ p.title=el.capTitle.value; refreshPinsList(); upsertPinToSheet(); updateViewerPreviewForPin(p); } });
el.capBody.addEventListener('input',  ()=>{ const p=pins.find(x=>x.id===selectedPinId); if(p){ p.body=el.capBody.value; upsertPinToSheet(); updateViewerPreviewForPin(p); } });

/* ========= Pin color presets ========= */
const PRESET_LIST = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#ef476f','#b5179e','#4361ee','#4cc9f0','#ff9f1c'];
function buildColorPresets(){
  const holder = el.colorPresets; holder.innerHTML='';
  PRESET_LIST.forEach(c=>{
    const b=document.createElement('button');
    b.style.width='18px'; b.style.height='18px';
    b.style.borderRadius='999px'; b.style.border='2px solid #223146';
    b.style.background=c; b.title=c;
    b.addEventListener('click',()=>{
      currentColor=c;
      const pId=selectedPinId;
      if(pId){
        const p=pins.find(x=>x.id===pId);
        p.color=normalizeHex(c);
        placePinMesh(p);
        refreshPinsList();
        filterColors.add(p.color); // Êñ∞Ëâ≤„ÇíÂàùÊúüË°®Á§∫
        buildColorFilter();
        debouncedSave();
      }
    });
    holder.appendChild(b);
  });
}
buildColorPresets();

function uniquePinColors(){ const set = new Set(); pins.forEach(p=> set.add(normalizeHex(p.color))); return Array.from(set); }
function buildColorFilter(){
  const list = el.colorFilterList; list.innerHTML='';
  const colors = uniquePinColors().sort();
  if(colors.length===0){ list.innerHTML = '<div class="small">„Éî„É≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>'; return; }
  colors.forEach(c=>{
    const row = document.createElement('label'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.margin='4px 0';
    const sw = document.createElement('span'); sw.style.width='14px'; sw.style.height='14px'; sw.style.borderRadius='50%'; sw.style.border='2px solid #223146'; sw.style.display='inline-block'; sw.style.background=c;
    const cb = document.createElement('input'); cb.type='checkbox'; cb.value=c; cb.checked = (filterColors.size===0 || filterColors.has(c));
    const name = document.createElement('span'); name.textContent = c; name.className='small';
    row.appendChild(cb); row.appendChild(sw); row.appendChild(name);
    cb.addEventListener('change', ()=>{
      if(cb.checked) filterColors.add(c); else filterColors.delete(c);
      if(filterColors.size===0){ colors.forEach(k=> filterColors.add(k)); }
      applyPinVisibilityFilter();
    });
    list.appendChild(row);
  });
  if(filterColors.size===0){ colors.forEach(k=> filterColors.add(k)); }
  applyPinVisibilityFilter();
}
function pinPassesFilter(p){ if(filterColors.size===0) return true; return filterColors.has(normalizeHex(p.color)); }
function applyPinVisibilityFilter(){
  pins.forEach(p=>{ if(p.mesh){ p.mesh.visible = pinPassesFilter(p); } });
  refreshPinsList(); renderNow();
}
el.btnColorFilter.addEventListener('click', ()=>{
  el.colorFilterPanel.style.display = (el.colorFilterPanel.style.display==='none' || !el.colorFilterPanel.style.display) ? 'block' : 'none';
});
document.getElementById('btnFilterAll').addEventListener('click', ()=>{ filterColors.clear(); uniquePinColors().forEach(c=> filterColors.add(c)); buildColorFilter(); });
document.getElementById('btnFilterNone').addEventListener('click', ()=>{ filterColors.clear(); applyPinVisibilityFilter(); buildColorFilter(); });
document.getElementById('btnFilterClose').addEventListener('click', ()=> el.colorFilterPanel.style.display='none');

function refreshPinsList(){
  el.pinsList.innerHTML='';
  pins.filter(pinPassesFilter).forEach(p=>{
    const row=document.createElement('div'); row.className='row'; row.dataset.id=p.id;
    const left=document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='8px';
    const dot=document.createElement('div'); dot.style.width='10px'; dot.style.height='10px'; dot.style.borderRadius='999px'; dot.style.background=p.color;
    const title=document.createElement('div'); title.className='title'; title.textContent=p.title||'(ÁÑ°È°å)';
    const meta=document.createElement('div'); meta.className='meta'; meta.textContent=`x:${p.pos.x.toFixed(2)} y:${p.pos.y.toFixed(2)} z:${p.pos.z.toFixed(2)}`;
    left.appendChild(dot); left.appendChild(title);
    row.appendChild(left); row.appendChild(meta);
    row.addEventListener('click',()=>selectPin(p.id,{fly:true}));
    el.pinsList.appendChild(row);
  });
}

/* ========= Load/Save pins ========= */
function rebuildPinsScene(){
  pinGroup.children.slice().forEach(ch=> pinGroup.remove(ch));
  pins.forEach(p=> placePinMesh(p));
  if(tcontrols.visible && selectedPinId){
    const p=pins.find(x=>x.id===selectedPinId);
    if((p && p.mesh)) tcontrols.attach(p.mesh); else tcontrols.detach();
  }
  renderNow();
}
async function loadPinsFromActiveSheet(spreadsheetId){
  pins=[]; selectedPinId=null; el.rightEditor.classList.add('hidden'); el.rightNoSel.classList.remove('hidden');
  try{
    const resp = await gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId, range: `${activeSheet.title}!A2:I`
    });
    const rows = resp.result.values || [];
    rows.forEach(r=>{
      const [pid, title, body, x, y, z, color, imagesJson] = r;
      const p = {
        id: pid || `p_${Math.random().toString(36).slice(2)}`,
        title: title || '',
        body: body || '',
        pos: new THREE.Vector3(parseFloat(x)||0, parseFloat(y)||0, parseFloat(z)||0),
        color: normalizeHex(color || '#ff6b6b'),
        images: [],
        mesh: null
      };
      try{ p.images = JSON.parse(imagesJson||'[]'); }catch{ p.images = []; }
      pins.push(p);
    });
    rebuildPinsScene();
    refreshPinsList();
    buildColorFilter();

    const meta = await loadSheetMeta(spreadsheetId);
    await applyMaterialsFromSheet(meta.materials);
    await applyViewerPrefs(meta.viewer);
    applyMaterialUIFromSelection();
  }catch(e){ console.error('loadPinsFromActiveSheet failed', e); }
}
async function upsertPinToSheet(){
  if(viewOnly) return;
  const spreadsheetId = extractSpreadsheetId(el.inputSheet.value.trim()); if(!spreadsheetId) return;
  const p = pins.find(x=>x.id===selectedPinId) || pins[pins.length-1]; if(!p) return;
  try{
    const col = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId, range: `${activeSheet.title}!A:A` });
    const rows = col.result.values || [];
    let rowIndex = -1;
    for(let i=0;i<rows.length;i++){ if(rows[i][0]===p.id){ rowIndex=i; break; } }
    const values = [[ p.id, p.title||'', p.body||'', p.pos.x, p.pos.y, p.pos.z, p.color, JSON.stringify(ensureArray(p.images)), new Date().toISOString() ]];
    if(rowIndex>=0){
      const range = `${activeSheet.title}!A${rowIndex+1}:I${rowIndex+1}`;
      await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId, range, valueInputOption:'RAW', resource:{ values } });
    }else{
      await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId, range: `${activeSheet.title}!A1`, valueInputOption:'RAW', resource:{ values } });
    }
  }catch(e){ console.error(e); }
}
async function deletePinFromActiveSheet(spreadsheetId, pinId){
  const col = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId, range: `${activeSheet.title}!A:A` });
  const rows = col.result.values || [];
  let rowIndex = -1;
  for(let i=0;i<rows.length;i++){ if(rows[i][0]===pinId){ rowIndex=i; break; } }
  if(rowIndex<0) return;
  await gapi.client.sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    resource:{
      requests:[{ deleteDimension:{
        range:{ sheetId: activeSheet.sheetId, dimension:'ROWS', startIndex:rowIndex, endIndex:rowIndex+1 }
      }}]
    }
  });
}

/* ========= Attach / Upload ========= */
el.btnAttach.addEventListener('click', async ()=>{
  if(viewOnly) return;
  const fileInput = el.imgLocal;
  fileInput.value = '';
  fileInput.onchange = async ()=>{
    const file = (fileInput.files && fileInput.files[0]);
    const p = pins.find(x=>x.id===selectedPinId);
    if(!file || !p){ return; }
    try{
      const blob = await toUploadableBlob(file);
      const uploaded = await driveMultipartUpload(blob, sanitizeName(file.name), glbParents);
      const ref = makeDriveRef(uploaded.id, blob.type || 'image/jpeg');
      p.images = ensureArray(p.images); p.images.push(ref);
      renderThumbs(p);
      setPreview(ref, p);
      toast('ÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü');
      upsertPinToSheet();
    }catch(err){ console.error(err); alert('ÁîªÂÉè„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'); }
  };
  fileInput.click();
});
function sanitizeName(n){ return n.replace(/[^\p{Letter}\p{Number}\s._-]+/gu,'_'); }
async function toUploadableBlob(file){
  const ext = (file.name.split('.').pop()||'').toLowerCase();
  if(ext==='heic' || ext==='heif'){
    const ok = await ensureHeic2any();
    if(!ok) throw new Error('heic2any unavailable');
    const jpegBlob = await window.heic2any({ blob:file, toType:'image/jpeg', quality:0.95 });
    return Array.isArray(jpegBlob) ? jpegBlob[0] : jpegBlob;
  }
  return file;
}
async function driveMultipartUpload(blob, name, parents){
  const meta = { name, parents: parents && parents.length ? parents : undefined };
  const boundary = '-------loci' + Math.random().toString(36).slice(2);
  const bufMeta = new TextEncoder().encode(`\r\n--${boundary}\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(meta)}\r\n\r\n--${boundary}\r\nContent-Type: ${blob.type || 'application/octet-stream'}\r\n\r\n`);
  const bufTail = new TextEncoder().encode(`\r\n--${boundary}--`);
  const stream = new Blob([ bufMeta, blob, bufTail ], { type: 'multipart/related; boundary='+boundary });
  const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&supportsAllDrives=true', {
    method: 'POST',
    headers: { 'Authorization': 'Bearer ' + accessToken },
    body: stream
  });
  if(!res.ok) throw new Error('Drive upload failed ' + res.status);
  return await res.json();
}

/* ========= Folder Picker ========= */
el.btnPickFromFolder.addEventListener('click', openPickerModal);
el.btnPickerClose.addEventListener('click', ()=> el.pickerModal.style.display='none');
el.btnPickerReload.addEventListener('click', loadFolderImages);

async function openPickerModal(){
  if(!glbParents || !glbParents.length){ alert('GLB„ÅÆË¶™„Éï„Ç©„É´„ÉÄ„Åå‰∏çÊòé„Åß„Åô„ÄÇÂÖà„Å´GLB„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ'); return; }
  await loadFolderImages();
  el.pickerModal.style.display='grid';
}
async function loadFolderImages(){
  if(!accessToken){ alert('ÂÖà„Å´„Çµ„Ç§„É≥„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ'); return; }
  el.pickerGrid.innerHTML = '<div class="small">Ë™≠„ÅøËæº„Åø‰∏≠‚Ä¶</div>';
  const cells = [];
  try{
    for(const parent of glbParents){
      const q = `'${parent}' in parents and trashed=false and (mimeType contains 'image/')`;
      const resp = await gapi.client.drive.files.list({
        q, pageSize: 200,
        fields: 'files(id,name,mimeType,fileExtension,hasThumbnail,thumbnailLink)',
        includeItemsFromAllDrives: true,
        supportsAllDrives: true
      });
      const files = resp.result.files || [];
      for(const f of files){
        const id = f.id;
        const mime = f.mimeType || '';
        const isHeic = isHeicMimeOrExt(mime, f.fileExtension);
        const ref = makeDriveRef(id, mime);
        const cell = document.createElement('div'); cell.style.background='#0c1118'; cell.style.border='1px solid #223146'; cell.style.borderRadius='12px'; cell.style.padding='8px'; cell.style.cursor='pointer'; cell.style.display='flex'; cell.style.flexDirection='column'; cell.style.gap='6px';
        const img = document.createElement('img'); img.alt = f.name; img.style.width='100%'; img.style.height='110px'; img.style.objectFit='cover'; img.style.borderRadius='8px';
        const tag = document.createElement('div'); tag.className='small'; tag.textContent = isHeic ? 'HEIC/HEIF (Â§âÊèõ/„Çµ„É†„ÉçË°®Á§∫)' : (mime||'image');
        const cap = document.createElement('div'); cap.textContent = f.name; cap.className='small';

        let usedFallback = false;
        if(f.hasThumbnail && f.thumbnailLink){
          const hi = upscaleThumbnailUrl(f.thumbnailLink, isHeic? 1024 : 512);
          const sep = hi.includes('?') ? '&' : '?';
          img.src = hi + sep + 'access_token=' + encodeURIComponent(accessToken);
          img.onerror = async ()=>{
            usedFallback = true;
            try{
              const url = await resolveImageObjectURL(ref, {preferThumb:true});
              img.src = url;
            }catch{ cell.style.opacity='.5'; cell.style.pointerEvents='none'; }
          };
        }else{
          try{
            const url = await resolveImageObjectURL(ref, {preferThumb:true});
            img.src = url;
          }catch{ cell.style.opacity='.5'; cell.style.pointerEvents='none'; }
        }

        img.onerror = ()=>{ if(!usedFallback){ cell.style.opacity='.5'; cell.style.pointerEvents='none'; } };
        cell.appendChild(img); cell.appendChild(cap); cell.appendChild(tag);
        cell.addEventListener('click', ()=>{ if(cell.style.pointerEvents==='none') return; chooseFolderImage(ref); });
        cells.push(cell);
      }
    }
    el.pickerGrid.innerHTML='';
    if(!cells.length){
      el.pickerGrid.innerHTML = '<div class="small">„Éï„Ç©„É´„ÉÄ„Å´ÁîªÂÉè„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</div>';
    }else{
      cells.forEach(c=> el.pickerGrid.appendChild(c));
    }
  }catch(e){
    console.error(e);
    el.pickerGrid.innerHTML = '<div class="small">Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ</div>';
  }
}
function chooseFolderImage(ref){
  el.pickerModal.style.display='none';
  const p = pins.find(x=>x.id===selectedPinId);
  if(!p){ alert('ÂÖà„Å´„Éî„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ'); return; }
  p.images = ensureArray(p.images); p.images.push(ref);
  renderThumbs(p);
  setPreview(ref, p);
  upsertPinToSheet();
}

/* ========= Caption Lists ========= */
async function refreshCaptionLists(spreadsheetId){
  const resp = await gapi.client.sheets.spreadsheets.get({
    spreadsheetId,
    fields: 'sheets(properties(sheetId,title,index))'
  });
  const sheets = (resp.result.sheets || []).map(s => s.properties);
  el.listSelect.innerHTML = '';
  sheets.forEach(p => {
    const o = document.createElement('option');
    o.value = String(p.sheetId);
    o.textContent = p.title;
    el.listSelect.appendChild(o);
  });
  let pick = sheets.find(s => s.title === 'pins') || sheets[0];
  if (!activeSheet.sheetId) {
    if (pick){ activeSheet = { sheetId: pick.sheetId, title: pick.title }; }
  } else {
    const same = sheets.find(s => s.sheetId === activeSheet.sheetId);
    if (!same) {
      pick = sheets.find(s => s.title === 'pins') || sheets[0];
      if (pick){ activeSheet = { sheetId: pick.sheetId, title: pick.title }; }
    } else {
      activeSheet.title = same.title;
    }
  }
  if (activeSheet.sheetId){ el.listSelect.value = String(activeSheet.sheetId); }
  if(!viewOnly){ ['listNew','listDelete'].forEach(id=>document.getElementById(id).disabled=false); }
}
el.listSelect.addEventListener('change', async (e)=>{
  const spreadsheetId = extractSpreadsheetId(el.inputSheet.value.trim());
  if(!spreadsheetId) return;
  const sheetId = Number(e.target.value);
  const title = e.target.options[e.target.selectedIndex].textContent;
  activeSheet = { sheetId, title };
  await loadPinsFromActiveSheet(spreadsheetId);
  toast(`„Ç≠„É£„Éó„Ç∑„Éß„É≥„É™„Çπ„Éà„ÇíÂàáÊõø: ${title}`);
});
el.listNew.addEventListener('click', async ()=>{
  if(viewOnly) return;
  const spreadsheetId = extractSpreadsheetId(el.inputSheet.value.trim());
  if(!spreadsheetId) return;
  const title = prompt('Êñ∞„Åó„ÅÑ„Ç≠„É£„Éó„Ç∑„Éß„É≥„É™„Çπ„ÉàÂêç„ÇíÂÖ•Âäõ', `pins_${Date.now().toString().slice(-5)}`);
  if(!title) return;
  const add = await gapi.client.sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    resource:{ requests:[ { addSheet:{ properties:{ title } } } ] }
  });
  const newSheetId = add.result.replies[0].addSheet.properties.sheetId;
  await gapi.client.sheets.spreadsheets.values.update({
    spreadsheetId, range: `${title}!A1`,
    valueInputOption:'RAW',
    resource:{ values: [[ 'pin_id','title','body','x','y','z','color','images','updated_at' ]] }
  });
  await refreshCaptionLists(spreadsheetId);
  activeSheet = { sheetId: newSheetId, title };
  el.listSelect.value = String(newSheetId);
  pins = []; selectedPinId = null; rebuildPinsScene(); refreshPinsList();

  await saveSheetMeta(spreadsheetId, {
    materials: {version:2, byKey:{}},
    viewer: {version:1, bgColor: el.bgColor.value || '#0a0f16', projection: usingOrtho ? 'orthographic' : 'perspective' }
  });

  toast(`Êñ∞„Åó„ÅÑ„É™„Çπ„Éà„Çí‰ΩúÊàê: ${title}`);
});
el.listDelete.addEventListener('click', async ()=>{
  if(viewOnly) return;
  const spreadsheetId = extractSpreadsheetId(el.inputSheet.value.trim());
  if(!spreadsheetId || !activeSheet.sheetId) return;
  const g = await gapi.client.sheets.spreadsheets.get({ spreadsheetId, fields: 'sheets(properties(sheetId))' });
  const count = (g.result.sheets||[]).length;
  if(count <= 1){ alert('ÊúÄÂæå„ÅÆ„Ç∑„Éº„Éà„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì'); return; }
  if(!confirm(`„Ç≠„É£„Éó„Ç∑„Éß„É≥„É™„Çπ„Éà„Äå${activeSheet.title}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) return;
  await gapi.client.sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    resource:{ requests:[ { deleteSheet:{ sheetId: activeSheet.sheetId } } ] }
  });
  await refreshCaptionLists(spreadsheetId);
  await loadPinsFromActiveSheet(spreadsheetId);
  toast('„É™„Çπ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
});

/* ========= Buttons ========= */
el.btnLoad.addEventListener('click', async ()=>{
  const raw = el.inputGLB.value.trim();
  const fid = extractDriveFileId(raw);
  if(!fid){
    alert('GLB„ÅÆ FileId/URL „ÇíÊ≠£„Åó„ÅèÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n\n„Éí„É≥„Éà: ÂÖ±ÊúâURL„ÅÆ„Åæ„ÅæË≤º‰ªò„ÅßOK„Åß„Åô„ÄÇIDÂçò‰Ωì„ÅÆÂ†¥Âêà„ÅØ30ÊñáÂ≠ó‰ª•‰∏ä„Åß„ÄÅÊú´Â∞æ„Åå _ „ÅßÁµÇ„Çè„Å£„Å¶„ÅÑ„Å™„ÅÑÂÆåÂÖ®„Å™ID„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
    return;
  }
  el.inputGLB.value = fid;
  await loadGLBByFileId(fid);
});
el.btnViewOnly.addEventListener('click', ()=>{
  const fid = extractDriveFileId(el.inputGLB.value.trim());
  const sid = extractSpreadsheetId(el.inputSheet.value.trim());
  const url = new URL(location.href);
  if (fid) url.searchParams.set('fileId', fid);
  if (sid) url.searchParams.set('sheetId', sid);
  url.searchParams.set('view', '1');
  navigator.clipboard.writeText(url.toString());
  toast('Èñ≤Ë¶ß„É™„É≥„ÇØ„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
});
el.btnWide.addEventListener('click', ()=>{
  document.body.classList.toggle('wide');
  el.btnWide.textContent = document.body.classList.contains('wide') ? 'üìã „Éë„Éç„É´Ë°®Á§∫' : 'üì∫ „Éì„É•„Éº„Ç¢Êã°Â§ß';
  setTimeout(()=>{ resize(); updateConnector(); }, 50);
});
el.btnTogglePins.addEventListener('click', ()=>{
  pinGroup.visible = !pinGroup.visible;
  el.btnTogglePins.textContent = '„Éî„É≥Ë°®Á§∫: ' + (pinGroup.visible? 'ON' : 'OFF');
  applyPinVisibilityFilter(); renderNow();
});
el.btnAddPin.addEventListener('click', ()=>{
  if(viewOnly) return;
  addPinMode = !addPinMode;
  el.viewerCanvas.style.cursor = addPinMode ? 'crosshair' : 'default';
  el.modeLabel.textContent = addPinMode ? 'AddPin' : 'Orbit';
  el.btnAddPin.textContent = addPinMode ? 'Ôºã „Éî„É≥ËøΩÂä†: ON' : 'Ôºã „Éî„É≥ËøΩÂä†„É¢„Éº„Éâ';
});
el.btnGizmo.addEventListener('click', ()=>{
  if(viewOnly) return;
  const enable = !tcontrols.visible;
  tcontrols.visible = enable; tcontrols.enabled = enable;
  el.btnGizmo.textContent = '„ÇÆ„Ç∫„É¢: ' + (enable ? 'ON' : 'OFF');
  const p = pins.find(x=>x.id===selectedPinId);
  if(enable && p && p.mesh){ tcontrols.attach(p.mesh); }
  else{ tcontrols.detach(); }
});
el.btnUndo.addEventListener('click', ()=>{
  if(viewOnly) return;
  const last = undoStack.pop(); if(!last) return;
  if(last.type==='add'){ const idx = pins.findIndex(p=>p.id===last.id); if(idx>=0){ const pin = pins[idx]; if(pin.mesh) pinGroup.remove(pin.mesh); pins.splice(idx,1); refreshPinsList(); renderNow(); upsertPinToSheet(); } }
});
el.btnDeletePin.addEventListener('click', async ()=>{
  if(viewOnly) return;
  const p = pins.find(x=>x.id===selectedPinId); if(!p) return;
  const spreadsheetId = extractSpreadsheetId(el.inputSheet.value.trim());
  if(p.mesh) pinGroup.remove(p.mesh);
  pins = pins.filter(x=>x.id!==p.id);
  selectedPinId = null;
  refreshPinsList(); updateViewerPreviewForPin(null); el.rightEditor.classList.add('hidden'); el.rightNoSel.classList.remove('hidden');
  renderNow();
  if(spreadsheetId){ try{ await deletePinFromActiveSheet(spreadsheetId, p.id); }catch(e){ console.error(e); } }
});


/* ========= GLB Load from URL ========= */
async function loadGLBFromURL(url, opts={}){
  try{
    if(!loader) loader = new GLTFLoader();
    // cleanup previous model
    if(currentModel){
      try{
        scene.remove(currentModel);
        currentModel.traverse(obj=>{
          if(obj.geometry) obj.geometry.dispose();
          if(obj.material){
            const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
            mats.forEach(m=>{
              try{
                if(m.map) m.map.dispose();
                if(m.normalMap) m.normalMap.dispose();
                if(m.roughnessMap) m.roughnessMap.dispose();
                if(m.metalnessMap) m.metalnessMap.dispose();
                if(m.aoMap) m.aoMap.dispose();
                if(m.emissiveMap) m.emissiveMap.dispose();
                m.dispose && m.dispose();
              }catch(_){}
            });
          }
        });
      }catch(_){}
      currentModel = null;
    }
    const gltf = await loader.loadAsync(url);
    const root = gltf.scene || (gltf.scenes && gltf.scenes[0]);
    if(!root) throw new Error('GLB has no scene');
    currentModel = root;
    scene.add(root);
    // reset pins group above model if needed
    if(pinGroup) scene.add(pinGroup);
    // collect materials/UI refresh
    try{ collectMaterials(); }catch(_){}
    try{ focusOrigin(); }catch(_){}
    try{ if(window.M3DUI && typeof window.M3DUI.modelLoaded==='function') window.M3DUI.modelLoaded(); }catch(_){}
    return root;
  }catch(e){
    console.error('loadGLBFromURL failed', e);
    throw e;
  }
}

/* ========= GLB Load (LOW-MEM for iOS) ========= */


async function loadGLBByFileId(fileId){
  try{
    const tokenObj = (window.gapi && gapi.client && gapi.client.getToken && gapi.client.getToken()) || null;
    const token = (tokenObj && tokenObj.access_token) || window.accessToken || '';
    if(!token){ alert('„Çµ„Ç§„É≥„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ'); return; }

    // 1) Fetch Drive metadata (need parents to locate spreadsheet)
    let meta = null;
    try{
      const r = await gapi.client.drive.files.get({
        fileId, fields: 'id,name,mimeType,parents', supportsAllDrives: true
      });
      meta = r.result;
    }catch(e){
      console.warn('meta fetch failed (non-fatal)', e);
    }

    // 2) Download GLB binary with Bearer
    const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?alt=media&supportsAllDrives=true`;
    const res = await fetch(url, { headers: { 'Authorization': 'Bearer ' + token } });
    if(!res.ok){
      const txt = await res.text().catch(()=>'');
      throw new Error('GLB download failed: ' + res.status + ' ' + txt + '\n\nID„ÅåÊ≠£„Åó„ÅÑ„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂÖ±ÊúâURL„ÅÆ„Ç≥„Éî„Éö„ÄÅ„Åæ„Åü„ÅØ30ÊñáÂ≠ó‰ª•‰∏ä„ÅÆÂÆåÂÖ®„Å™FileId„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
    }
    const blob = await res.blob();
    const objUrl = URL.createObjectURL(blob);
    try{
      await loadGLBFromURL(objUrl, {name: (meta && meta.name) || 'model.glb'});
    }finally{
      URL.revokeObjectURL(objUrl);
    }

    // 3) Spreadsheet„ÇíÁ¢∫ÂÆö„Åó„Å¶„Éî„É≥Ë™≠„ÅøËæº„Åø
    try{
      const spreadsheetId = await findOrCreateSpreadsheetInGlbFolder(meta || {id:fileId, name:'model'});
      if (spreadsheetId){
        if (el && el.inputSheet) el.inputSheet.value = spreadsheetId;
        await loadPinsFromActiveSheet(spreadsheetId);
      }
    }catch(e){
      console.warn('pin spreadsheet resolve failed', e);
    }
  }catch(e){
    console.error('loadGLBByFileId failed', e);
    alert('GLB„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + (e && e.message ? e.message : e));
  }
}



/* ========= Save viewer prefs ========= */
['viewFront','viewBack','viewLeft','viewRight','viewTop','viewBottom'].forEach(id=>{
  document.getElementById(id).addEventListener('click', ()=> debouncedSaveMaterials());
});

/* ========= Entry ========= */
function buildColorPresetsOnce(){
  el.colorPresets.innerHTML='';
  PRESET_COLORS.forEach(c=>{
    const b=document.createElement('button');
    b.style.width='18px'; b.style.height='18px';
    b.style.borderRadius='999px'; b.style.border='2px solid #223146';
    b.style.background=c; b.title=c;
    b.addEventListener('click',()=>{
      currentColor=c;
      if(selectedPinId){
        const p=pins.find(x=>x.id===selectedPinId);
        p.color=normalizeHex(c);
        placePinMesh(p);
        refreshPinsList();
        filterColors.add(p.color);
        buildColorFilter();
        debouncedSave();
      }
    });
    el.colorPresets.appendChild(b);
  });
}
buildColorPresetsOnce();

function viewerInitWrap(){ viewerInit(); }
viewerInitWrap();

</script>
<!-- M3D vNext UI containers -->
<div id="m3d-caption-layer" aria-label="caption overlay layer" hidden></div>
<div id="m3d-mobile-caption" aria-label="mobile caption panel" hidden>
  <div class="m3d-cap__title" id="m3d-mcap-title"></div>
  <div class="m3d-cap__imgwrap">
    <img id="m3d-mcap-img" class="m3d-cap__img" alt="caption image" />
    <div id="m3d-mcap-ph" class="m3d-cap__placeholder">ÁîªÂÉè„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì</div>
  </div>
  <div class="m3d-cap__body" id="m3d-mcap-body"></div>
  <div class="m3d-cap__actions" id="m3d-mcap-actions"></div>
</div>
<script>
(function(){
  if (window.M3DUI && window.M3DUI.__ready) return;

  function $(id){ return document.getElementById(id); }
  function isMobile(){
    try{ return window.matchMedia("(max-width: 900px)").matches; }
    catch(e){ return (window.innerWidth||1024) <= 900; }
  }

  var state = { desktopWindows:{}, activePin:null };

  function ensureRoot(){
    document.body.classList.add('m3d-ui-vnext');
    var overlay = $("m3d-caption-layer");
    var mcap    = $("m3d-mobile-caption");
    var viewer  = $("viewer");
    // keep hidden until first use
    /* if (overlay) overlay.hidden = false;
    if (mcap)    mcap.hidden = false; */
    if (viewer){
      if (getComputedStyle(viewer).position === 'static'){ viewer.style.position = 'relative'; }
      // ensure overlay is a child of #viewer for proper absolute positioning
      if (overlay && overlay.parentElement !== viewer){ viewer.appendChild(overlay); }
      // on mobile, place mobile caption just after viewer
      if (isMobile() && mcap && mcap.parentElement !== viewer.parentElement){
        viewer.parentElement.insertBefore(mcap, viewer.nextSibling);
      }
    }
  }

  function makeDraggable(handle, target){
    var sx=0, sy=0, ox=0, oy=0, dragging=false;
    handle.addEventListener('mousedown', function(e){
      dragging=true; sx=e.clientX; sy=e.clientY;
      var r = target.getBoundingClientRect(); ox=r.left + window.scrollX; oy=r.top + window.scrollY;
      e.preventDefault();
    });
    document.addEventListener('mousemove', function(e){
      if(!dragging) return;
      var dx=e.clientX-sx, dy=e.clientY-sy;
      target.style.left = (ox+dx) + 'px';
      target.style.top  = (oy+dy) + 'px';
    });
    document.addEventListener('mouseup', function(){ dragging=false; });
  }

  function createCapWindow(pin){
    try{ if(!(window.M3DUI && window.M3DUI.__modelReady)) return null; }catch(_){ return null; }
    var overlay = $("m3d-caption-layer");
    if(!overlay) return null;
    overlay.hidden = false;
    var div = document.createElement('div');
    div.className = 'm3d-capwin';
    div.style.left = (24 + Math.floor(Math.random()*60)) + 'px';
    div.style.top  = (24 + Math.floor(Math.random()*40)) + 'px';

    var bar = document.createElement('div'); bar.className = 'm3d-capwin__titlebar';
    var title = document.createElement('div'); title.textContent = (pin && pin.title) ? pin.title : '„Ç≠„É£„Éó„Ç∑„Éß„É≥';
    var btnX = document.createElement('button'); btnX.className='m3d-capwin__close'; btnX.textContent='‚úï';
    btnX.addEventListener('click', function(){ if(div.parentElement) div.parentElement.removeChild(div); });
    bar.appendChild(title); bar.appendChild(btnX);
    div.appendChild(bar);

    var body = document.createElement('div'); body.className='m3d-capwin__body';
    if(pin && pin.img){
      var img = document.createElement('img'); img.className='m3d-capwin__img'; img.src=pin.img; img.alt='caption image';
      body.appendChild(img);
      var act = document.createElement('div'); act.className='m3d-capwin__actions';
      var a = document.createElement('a'); a.href=pin.img; a.target='_blank'; a.rel='noopener'; a.textContent='ÂÖÉÁîªÂÉè„ÇíÈñã„Åè';
      act.appendChild(a); body.appendChild(act);
    }else{
      var ph = document.createElement('div'); ph.className='m3d-cap__placeholder'; ph.textContent='ÁîªÂÉè„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì';
      body.appendChild(ph);
    }
    var meta = document.createElement('div'); meta.className='m3d-capwin__meta'; meta.textContent = (pin && pin.id) ? ('#'+pin.id) : '';
    body.appendChild(meta);
    var text = document.createElement('div'); text.textContent = (pin && pin.body) ? pin.body : '';
    body.appendChild(text);

    div.appendChild(body);
    overlay.appendChild(div);
    makeDraggable(bar, div);
    return div;
  }

  function showMobileCaption(pin){
    var panel = $("m3d-mobile-caption"); if(!panel) return;
    var t=$("m3d-mcap-title"), b=$("m3d-mcap-body"), img=$("m3d-mcap-img"), ph=$("m3d-mcap-ph"), acts=$("m3d-mcap-actions");
    t.textContent = (pin && pin.title) ? pin.title : '„Ç≠„É£„Éó„Ç∑„Éß„É≥';
    b.textContent = (pin && pin.body)  ? pin.body  : '';
    acts.innerHTML = '';
    if(pin && pin.img){
      img.src = pin.img; img.style.display='block'; ph.style.display='none';
      var a = document.createElement('a'); a.href=pin.img; a.target='_blank'; a.rel='noopener'; a.textContent='ÂÖÉÁîªÂÉè„ÇíÈñã„Åè';
      acts.appendChild(a);
    }else{
      img.removeAttribute('src'); img.style.display='none'; ph.style.display='flex';
    }
    try{
      var viewer=$("viewer");
      if(viewer){
        var vw = viewer.clientWidth || window.innerWidth || 360;
        var vh = viewer.clientHeight|| Math.max(320, Math.floor((window.innerHeight||640)*0.6));
        img.style.maxWidth  = Math.round(vw*0.5) + 'px';
        img.style.maxHeight = Math.round(vh*0.4) + 'px';
      }
    }catch(_){}
  }

  function readCurrentPinFromLegacy(){
    var imgEl = document.getElementById('previewImg');
    var title = (document.getElementById('capTitleLine')||{}).textContent || '';
    var body  = (document.getElementById('capBodyLine')||{}).textContent || '';
    var id    = (window.currentPin && window.currentPin.id) || '';
    var src   = (imgEl && imgEl.src) || '';
    var hasImg= !!(imgEl && imgEl.naturalWidth);
    return { id:id||'', title:title||'', body:body||'', img: hasImg ? src : '' };
  }

  function onPinSelected(pinLike){
    var pin = pinLike || readCurrentPinFromLegacy();
    state.activePin = pin;
    if (isMobile()){ showMobileCaption(pin); }
    else { createCapWindow(pin); }
  }

  window.M3DUI = { __ready:true, onPinSelected:onPinSelected, showMobileCaption:showMobileCaption, createCapWindow:createCapWindow };

  document.addEventListener('DOMContentLoaded', function(){
    ensureRoot();
    if (typeof window.selectPin === 'function'){
      var orig = window.selectPin;
      window.selectPin = function(){
        try{ orig.apply(this, arguments); }catch(e){ console.warn(e); }
        try{ if(window.M3DUI && window.M3DUI.onPinSelected) window.M3DUI.onPinSelected(); }catch(e){ console.warn(e); }
      };
    }
    });window.addEventListener('resize', function(){
    try{ if (isMobile() && state.activePin) showMobileCaption(state.activePin); }catch(_){}
  });
})();
</script>
<script>

document.addEventListener('DOMContentLoaded', function(){
  try{
    var rc = document.getElementById('rightCaption');
    if(!rc) return;
    var body = rc.querySelector('.body') || rc;
    if(!document.getElementById('m3d-caplist')){
      var list = document.createElement('div'); list.id='m3d-caplist'; body.insertBefore(list, body.firstChild);
    }
    if(!document.getElementById('m3d-capeditor')){
      var ed = document.createElement('div'); ed.id='m3d-capeditor'; body.appendChild(ed);
    }
    // Move known editor block to bottom if exists
    var editor = document.getElementById('editor');
    if(editor && editor.parentElement !== document.getElementById('m3d-capeditor')){
      document.getElementById('m3d-capeditor').appendChild(editor);
    }
    // Move known preview out of right pane (overlay/mobile handles viewing)
    var prev = document.getElementById('viewerPreview');
    if(prev && prev.parentElement === body){
      // leave it where it is or let overlay handle; no action
    }
    // Heuristic: move non-editor controls to list
    var caplist = document.getElementById('m3d-caplist');
    Array.from(body.children).forEach(function(node){
      var id = node.id||'';
      if(id==='m3d-caplist' || id==='m3d-capeditor' || id==='editor') return;
      if(node === caplist || node === document.getElementById('m3d-capeditor')) return;
      // keep tabs/headers at top of list
      if(caplist && node.parentElement===body){
        caplist.appendChild(node);
      }
    });
  }catch(e){ console.warn('right panel split failed', e); }
});

</script>

<script>
(function(){
  if(!window.M3DUI) return;
  window.M3DUI.__modelReady = false;
  window.M3DUI.modelLoaded = function(){
    window.M3DUI.__modelReady = true;
    try{
      var p = window.M3DUI.__pendingPin;
      if(p){
        window.M3DUI.__pendingPin = null;
        if (window.matchMedia && window.matchMedia('(max-width: 900px)').matches){
          window.M3DUI.showMobileCaption(p);
          var mcapEl=document.getElementById('m3d-mobile-caption'); if(mcapEl) mcapEl.hidden=false;
        }else{
          window.M3DUI.createCapWindow(p);
          var overlayEl=document.getElementById('m3d-caption-layer'); if(overlayEl) overlayEl.hidden=false;
        }
      }
    }catch(_){}
  };
  function wrapSuccess(fnName){
    try{
      var fn = window[fnName];
      if(typeof fn !== 'function') return;
      window[fnName] = async function(){
        var res = await fn.apply(this, arguments);
        try{ window.M3DUI.modelLoaded(); }catch(_){}
        return res;
      };
    }catch(_){}
  }
  wrapSuccess('loadGLBFromURL');
  wrapSuccess('loadGLBByFileId');
  if(typeof window.M3DUI.onPinSelected === 'function'){
    var orig = window.M3DUI.onPinSelected;
    window.M3DUI.onPinSelected = function(pinLike){
      try{
        if(!window.M3DUI.__modelReady){
          window.M3DUI.__pendingPin = pinLike;
          return;
        }
      }catch(_){}
      return orig.apply(this, arguments);
    };
  }
})();
</script>


<!-- === vNext Phase2 bundle (clean E) === -->
<script>
(function(){
  function vnextEnabled(){
    try{
      const sp = new URLSearchParams(location.search);
      if (sp.has('vnext')) localStorage.setItem('m3d_vnext', sp.get('vnext'));
      return sp.get('vnext')==='1' || localStorage.getItem('m3d_vnext')==='1';
    }catch(e){ return false; }
  }
  if (!vnextEnabled()) return;

  class LocimyuUI extends HTMLElement {
    constructor(){
      super();
      this.attachShadow({mode:'open'});
      const css = `
        :root{ --ui-bg:#fff; --ui-border:rgba(0,0,0,.08); --glass:rgba(255,255,255,.96); }
        :host{ all: initial; }
        .chip{ position: fixed; left:12px; bottom:12px; padding:8px 12px; border-radius:999px;
               background:#222; color:#fff; border:1px solid #444; font:13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
               cursor:pointer; opacity:.92; box-shadow:0 2px 8px rgba(0,0,0,.25); user-select:none; z-index:4; }
        .panel{ position: fixed; right:12px; bottom:56px; width:320px; max-height:46vh; overflow:auto; padding:10px; border-radius:12px;
               background:rgba(0,0,0,.78); color:#fff; font:12px/1.5 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
               display:none; box-shadow:0 10px 24px rgba(0,0,0,.35); -webkit-backdrop-filter: blur(2px); backdrop-filter: blur(2px); z-index:3; }
        .panel h3{ margin:0 0 6px; font-size:12px; opacity:.85; }
        .list{ list-style:none; margin:0; padding:0; display:grid; gap:4px; }
        .list li.error{ color:#ff9a9a; }
        .overlay{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; z-index:2;
                 -webkit-backdrop-filter: blur(1px); backdrop-filter: blur(1px); }
        .center{ position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
                 text-align:center; color:#fff; font:14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        .spinner{ width:48px; height:48px; border:4px solid rgba(255,255,255,.3); border-top-color:#fff; border-radius:50%;
                 animation:spin 1s linear infinite; margin:0 auto 10px; }
        @keyframes spin{ to{ transform: rotate(360deg); } }

        .rightpane{ position: fixed; top:0; right:0; width:360px; height:100vh; background:rgba(16,16,16,.04);
                    border-left:1px solid var(--ui-border); display:flex; flex-direction:column; gap:8px; padding:12px; box-sizing:border-box; z-index:1; }
        .caplist{ flex:1; overflow:auto; background:var(--ui-bg); border-radius:10px; box-shadow:0 1px 2px rgba(0,0,0,.05); }
        .capeditor{ height:28%; min-height:140px; background:var(--ui-bg); border-radius:10px; box-shadow:0 1px 2px rgba(0,0,0,.05); }
        @media (max-width: 900px){ .rightpane{ display:none; } }

        .mobilebar{ position: fixed; left:0; right:0; bottom:0; height:56px; background:var(--glass);
                    border-top:1px solid var(--ui-border); display:flex; align-items:center; gap:8px; padding:0 8px; box-sizing:border-box; z-index:2; }
        .mb-btn{ appearance:none; border:1px solid var(--ui-border); background:#fff; border-radius:10px; padding:6px 10px; font:13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        .mb-btn:active{ transform:translateY(1px); }
        .mobilepanel{ position: fixed; left:0; right:0; bottom:56px; background:var(--glass); border-top:1px solid var(--ui-border);
                      max-height:55vh; display:none; z-index:2; box-shadow:0 -10px 24px rgba(0,0,0,.12); }
        .mobilepanel .h{ display:flex; align-items:center; gap:8px; padding:10px 12px; border-bottom:1px solid var(--ui-border); }
        .mobilepanel .b{ padding:12px; overflow:auto; max-height:calc(55vh - 48px); }
        .pinimg{ width:100%; max-height:38vh; object-fit:contain; background:#f6f6f6; border:1px solid var(--ui-border); border-radius:8px; }
        .pinmeta{ font:13px/1.5 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:#222; white-space:pre-wrap; }
        .title{ font-weight:600; margin:6px 0 4px; }
        .row{ display:grid; grid-template-columns: 90px 1fr; gap:8px; align-items:center; margin:6px 0; }
        .row input, .row textarea{ width:100%; box-sizing:border-box; border:1px solid var(--ui-border); border-radius:8px; padding:8px; font:13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        .row textarea{ min-height:72px; }
        .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
        .ghost{ opacity:.65; }
        @media (max-width: 900px){ .chip{ display:none; } .panel{ bottom: calc(56px + 10px); max-height: 40vh; } }
      `;
      const tpl = document.createElement('template');
      tpl.innerHTML = `<style>${css}</style>
        <button id="chip" class="chip" title="Ë®∫Êñ≠„É≠„Ç∞Ôºà„ÉÅ„É´„ÉÄÊ®™„Ç≠„Éº„ÅßÈñãÈñâÔºâ">Ë®∫Êñ≠„É≠„Ç∞</button>
        <div id="panel" class="panel"><h3>Ë®∫Êñ≠„É≠„Ç∞</h3><ul id="list" class="list"></ul></div>
        <div id="overlay" class="overlay"><div class="center"><div class="spinner"></div><div id="msg">Ë™≠„ÅøËæº„Åø‰∏≠‚Ä¶</div></div></div>
        <aside class="rightpane" part="rightpane" aria-label="vNextÂè≥„Éö„Ç§„É≥">
          <div class="caplist" id="caplist" part="caplist"></div>
          <div class="capeditor" id="capeditor" part="capeditor"></div>
        </aside>
        <div class="mobilebar" part="mobilebar">
          <button class="mb-btn" id="btnHUD">Ë®∫Êñ≠</button>
          <button class="mb-btn" id="btnReader">Ë™≠Êõ∏</button>
          <button class="mb-btn" id="btnList">‰∏ÄË¶ß</button>
          <button class="mb-btn" id="btnAdd">ËøΩÂä†</button>
          <div id="mobileStatus" class="ghost">vNext „É¢„Éê„Ç§„É´</div>
        </div>
        <div class="mobilepanel" id="panelReader">
          <div class="h"><div style="font-weight:600">„Ç≠„É£„Éó„Ç∑„Éß„É≥</div><div style="margin-left:auto"><button class="mb-btn" id="btnRClose">Èñâ„Åò„Çã</button></div></div>
          <div class="b">
            <img id="rImg" class="pinimg" alt="ÁîªÂÉè„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì" />
            <div class="pinmeta">
              <div id="rTitle" class="title"></div>
              <div id="rBody"></div>
            </div>
          </div>
        </div>
        <div class="mobilepanel" id="panelList">
          <div class="h"><div style="font-weight:600">„Éî„É≥‰∏ÄË¶ß</div><div style="margin-left:auto"><button class="mb-btn" id="btnLClose">Èñâ„Åò„Çã</button></div></div>
          <div class="b" id="listBody">Ë™≠„ÅøËæº„ÅøÂæÖ„Å°‚Ä¶</div>
        </div>
        <div class="mobilepanel" id="panelAdd">
          <div class="h"><div style="font-weight:600">„Éî„É≥ËøΩÂä†</div><div style="margin-left:auto"><button class="mb-btn" id="btnAClose">Èñâ„Åò„Çã</button></div></div>
          <div class="b">
            <div class="row"><label for="aTitle">„Çø„Ç§„Éà„É´</label><input id="aTitle" placeholder="‰æãÔºöÂè£Á∏ÅÈÉ®„ÅÆÊ¨†Êêç" /></div>
            <div class="row"><label for="aBody">Êú¨Êñá</label><textarea id="aBody" placeholder="„É°„É¢‚Ä¶"></textarea></div>
            <div class="row"><label for="aImg">ÁîªÂÉèURL</label><input id="aImg" placeholder="https://..." /></div>
            <div class="actions"><button class="mb-btn" id="btnSave">‰øùÂ≠ò</button></div>
            <div class="ghost">‚Äª ÁèæÊÆµÈöé„Åß„ÅØ URL ÊåáÂÆö„Åß‰øùÂ≠ò„Åó„Åæ„ÅôÔºàDrive„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÁµ±Âêà„ÅØÂæåÁ∂öÔºâ</div>
          </div>
        </div>`;
      this.shadowRoot.appendChild(tpl.content.cloneNode(true));

      // HUD refs
      this.__list = this.shadowRoot.getElementById('list');
      this.__panel = this.shadowRoot.getElementById('panel');
      this.__msg = this.shadowRoot.getElementById('msg');
      this.__overlay = this.shadowRoot.getElementById('overlay');
      this.__chip = this.shadowRoot.getElementById('chip');
      this.__autoOpened = false;
      this.__userClosed = false;
      this.__refCount = 0;

      // Mobile refs
      this.$reader = this.shadowRoot.getElementById('panelReader');
      this.$list = this.shadowRoot.getElementById('panelList');
      this.$add = this.shadowRoot.getElementById('panelAdd');
      this.$listBody = this.shadowRoot.getElementById('listBody');
      this.$rImg = this.shadowRoot.getElementById('rImg');
      this.$rTitle = this.shadowRoot.getElementById('rTitle');
      this.$rBody = this.shadowRoot.getElementById('rBody');
      this.$aTitle = this.shadowRoot.getElementById('aTitle');
      this.$aBody = this.shadowRoot.getElementById('aBody');
      this.$aImg = this.shadowRoot.getElementById('aImg');
      this.__pins = [];
      this.__sheetId = null;
      this.__selected = null;
      this.__glbFileId = null;
      this.__lastAltMediaURL = null;
    }
    connectedCallback(){
      const togglePanel = ()=>{
        const st = (this.__panel.style.display==='none' || !this.__panel.style.display) ? 'block' : 'none';
        this.__panel.style.display = st; this.__userClosed = (st==='none');
        if(st!=='none') this.__panel.scrollTop = this.__panel.scrollHeight;
      };
      this.__chip.addEventListener('click', togglePanel, {capture:true});
      this.shadowRoot.getElementById('btnHUD').addEventListener('click', togglePanel);
      window.addEventListener('keydown', (e)=>{ if(e.key === '`'){ togglePanel(); } }, {capture:true});

      const show = (el)=>{ [this.$reader,this.$list,this.$add].forEach(x=>x.style.display='none'); el.style.display='block'; };
      this.shadowRoot.getElementById('btnReader').addEventListener('click', ()=> show(this.$reader));
      this.shadowRoot.getElementById('btnList').addEventListener('click', async ()=>{ show(this.$list); await this.ensureSheetResolved(); this.renderList(); });
      this.shadowRoot.getElementById('btnAdd').addEventListener('click', ()=> show(this.$add));
      this.shadowRoot.getElementById('btnRClose').addEventListener('click', ()=> this.$reader.style.display='none');
      this.shadowRoot.getElementById('btnLClose').addEventListener('click', ()=> this.$list.style.display='none');
      this.shadowRoot.getElementById('btnAClose').addEventListener('click', ()=> this.$add.style.display='none');
      this.shadowRoot.getElementById('btnSave').addEventListener('click', ()=> this.quickSave());

      if (!window.M3DBusy) window.M3DBusy = { show: (m)=>this.showBusy(m), hide: ()=>this.hideBusy() };
      if (!window.logStep) window.logStep = (s)=>this.log(String(s||''));
      if (!window.logError) window.logError = (s)=>this.log(String(s||''), 'error');

      this.hookGapi();
      this.hookFetchAndXHR();
      this.hookLegacyAPIs();

      window.addEventListener('m3d:model-loaded', async ()=>{ this.log('modelLoaded'); await this.ensureSheetResolved(); });
      window.addEventListener('m3d:pin-selected', (ev)=> this.onSelect(ev && ev.detail));

      try{ const sp = new URLSearchParams(location.search); if (sp.get('hud')==='0'){ this.__chip.style.display='none'; this.__panel.style.display='none'; this.shadowRoot.querySelector('#btnHUD').style.display='none'; } }catch(_){}

      this.hideLegacyChipOnMobile();

      this.log('vNext Phase2 mounted');
    }

    log(s, level){
      const li = document.createElement('li'); li.textContent = '[' + new Date().toLocaleTimeString() + '] ' + s;
      if(level==='error') li.classList.add('error');
      this.__list.appendChild(li);
      if((!this.__autoOpened && !this.__userClosed) || level==='error'){ this.__panel.style.display='block'; this.__autoOpened = true; }
      if(this.__panel.style.display!=='none'){ this.__panel.scrollTop = this.__panel.scrollHeight; }
      while(this.__list.children.length>250) this.__list.removeChild(this.__list.firstChild);
    }
    showBusy(m){ this.__refCount++; this.__overlay.style.display='block'; if(m) this.__msg.textContent=m; }
    hideBusy(){ this.__refCount = Math.max(0,this.__refCount-1); if(this.__refCount===0) this.__overlay.style.display='none'; }

    onSelect(pin){
      this.__selected = pin || null;
      if (!pin){
        this.$rImg.src = ''; this.$rTitle.textContent = ''; this.$rBody.textContent = '';
        return;
      }
      const t = pin.title || pin.name || pin.id || '';
      const b = pin.body || pin.note || pin.caption || '';
      const img = pin.img || pin.image || '';
      this.$rTitle.textContent = String(t);
      this.$rBody.textContent = String(b);
      if (img){ this.$rImg.src = img; this.$rImg.style.display='block'; }
      else { this.$rImg.removeAttribute('src'); this.$rImg.style.display='none'; }
    }
    async renderList(){
      try{
        if (!this.__sheetId){ this.$listBody.textContent = '„Ç∑„Éº„ÉàÊú™ÂèñÂæóÔºàGLB„ÇíË™≠„ÅøËæº„ÇÄ„Å®ÂèñÂæó„Åó„Åæ„ÅôÔºâ'; return; }
        if (!this.__pins.length) await this.fetchPins(this.__sheetId);
        if (!this.__pins.length){ this.$listBody.textContent = '„Éî„É≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì'; return; }
        const frag = document.createDocumentFragment();
        this.__pins.forEach((p, idx)=>{
          const div = document.createElement('div');
          div.style.cssText = 'padding:8px 4px;border-bottom:1px solid var(--ui-border);display:grid;grid-template-columns:44px 1fr;gap:8px;align-items:center;';
          const ph = document.createElement('div'); ph.style.cssText='width:44px;height:44px;border-radius:6px;background:#f2f2f2;border:1px solid var(--ui-border);overflow:hidden;';
          if (p.img){ const im = document.createElement('img'); im.src = p.img; im.style.cssText='width:100%;height:100%;object-fit:cover;'; ph.appendChild(im); }
          const text = document.createElement('div'); text.innerHTML = '<div style="font-weight:600>'+ (p.title || p.name || ('Pin ' + (idx+1))) + '</div><div style="font-size:12px;opacity:.8">' + (p.body || '') + '</div>';
          div.appendChild(ph); div.appendChild(text);
          div.addEventListener('click', ()=>{
            try{ if (typeof window.selectPin === 'function') window.selectPin(p.id || p._row || idx); }catch(_){}
            this.onSelect(p);
            this.$reader.style.display='block';
          });
          frag.appendChild(div);
        });
        this.$listBody.innerHTML='';
        this.$listBody.appendChild(frag);
      }catch(e){
        this.$listBody.textContent = '‰∏ÄË¶ßÊèèÁîª„Ç®„É©„Éº';
        this.log('‰∏ÄË¶ßÊèèÁîª„Ç®„É©„Éº: '+(e&&e.message?e.message:e), 'error');
      }
    }
    async fetchPins(sheetId){
      try{
        if (!window.gapi || !gapi.client || !gapi.client.sheets){ this.log('Sheets APIÊú™ÂàùÊúüÂåñ'); return; }
        this.showBusy('„Éî„É≥„Éª„Ç∑„Éº„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠‚Ä¶');
        const meta = await gapi.client.sheets.spreadsheets.get({ spreadsheetId: sheetId });
        const firstSheet = (meta.result.sheets && meta.result.sheets[0] && meta.result.sheets[0].properties && meta.result.sheets[0].properties.title) || 'Sheet1';
        const vals = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: sheetId, range: firstSheet + '!A:Z' });
        const rows = vals.result.values || [];
        if (!rows.length){ this.__pins=[]; this.$listBody.textContent='„Éî„É≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì'; return; }
        const header = rows[0].map(x=>String(x||'').trim().toLowerCase());
        const pins = [];
        for (let i=1;i<rows.length;i++){
          const r = rows[i]; const obj = {_row: i+1};
          for (let c=0;c<header.length;c++){ const key = header[c] || ('c'+(c+1)); obj[key] = r[c] || ''; }
          obj.id = obj.id || obj.pinid || obj.key || obj._row;
          obj.title = obj.title || obj.name || obj.captiontitle || obj.c2 || '';
          obj.body = obj.body || obj.note || obj.caption || obj.description || obj.c3 || '';
          obj.img = obj.img || obj.image || obj.photourl || obj.thumbnail || '';
          pins.push(obj);
        }
        this.__pins = pins;
        this.log('„Éî„É≥ÂèñÂæó: ' + pins.length + '‰ª∂');
      }catch(e){
        this.log('„Éî„É≥ÂèñÂæóÂ§±Êïó: ' + (e && e.result && e.result.error && e.result.error.message ? e.result.error.message : (e.message || e)), 'error');
      }finally{
        this.hideBusy();
      }
    }
    async quickSave(){
      try{
        const pin = {
          title: (this.$aTitle.value||'').trim(),
          body: (this.$aBody.value||'').trim(),
          img: (this.$aImg.value||'').trim()
        };
        if (!pin.title && !pin.body){ this.log('„Çø„Ç§„Éà„É´„ÅãÊú¨Êñá„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error'); return; }
        if (typeof window.upsertPinToSheet === 'function'){
          this.showBusy('‰øùÂ≠ò‰∏≠‚Ä¶');
          await Promise.resolve(window.upsertPinToSheet(pin));
          this.hideBusy();
          this.log('‰øùÂ≠òÂÆå‰∫Ü');
          this.$aTitle.value=''; this.$aBody.value=''; this.$aImg.value='';
          if (this.__sheetId) this.fetchPins(this.__sheetId);
        }else{
          this.log('upsertPinToSheet „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„ÇìÔºàÊóßÂÆüË£Ö„ÅÆ‰øùÂ≠òAPIÔºâ', 'error');
        }
      }catch(e){
        this.hideBusy();
        this.log('‰øùÂ≠òÂ§±Êïó: ' + (e && e.message ? e.message : e), 'error');
      }
    }

    hideLegacyChipOnMobile(){
      try{
        if (!window.matchMedia) return;
        if (!matchMedia('(max-width: 900px)').matches) return;
        const cands = Array.from(document.querySelectorAll('button,div,a,span'));
        for(const el of cands){
          const txt = (el.textContent||'').trim();
          if (!txt) continue;
          if (txt.includes('Ë®∫Êñ≠„É≠„Ç∞') || txt.includes('Diagnostics')){
            const cs = getComputedStyle(el);
            if (cs.position==='fixed'){ try{ el.style.display='none'; el.setAttribute('data-m3d-hidden','chip'); }catch(_){ } }
          }
        }
      }catch(_){}
    }
    captureGLBIdFromURL(u){
      try{
        if (!u) return;
        const m = String(u).match(/\/drive\/v3\/files\/([^/?]+)\?[^#]*alt=media/i);
        if (m && m[1]){ this.__glbFileId = decodeURIComponent(m[1]); }
      }catch(_){}
    }
    async ensureSheetResolved(){
      try{
        if (this.__sheetId) return this.__sheetId;
        if (!window.gapi || !gapi.client || !gapi.client.drive){ return null; }
        if (!this.__glbFileId && this.__lastAltMediaURL){ this.captureGLBIdFromURL(this.__lastAltMediaURL); }
        if (!this.__glbFileId){ return null; }
        const meta = await gapi.client.drive.files.get({ fileId: this.__glbFileId, fields: 'parents' });
        const parents = (meta.result && meta.result.parents) || [];
        const parent = parents[0];
        if (!parent){ return null; }
        const q = [
          "'" + parent + "' in parents",
          "mimeType='application/vnd.google-apps.spreadsheet'",
          "trashed=false",
          "appProperties has { key='lociFor' and value='" + this.__glbFileId + "' }"
        ].join(' and ');
        let res = await gapi.client.drive.files.list({ q, pageSize: 10, fields: 'files(id,name)', includeItemsFromAllDrives: true, supportsAllDrives: true });
        let files = (res.result && res.result.files) || [];
        if (!files.length){
          const q2 = ["'" + parent + "' in parents", "mimeType='application/vnd.google-apps.spreadsheet'", "trashed=false"].join(' and ');
          res = await gapi.client.drive.files.list({ q: q2, pageSize: 10, fields: 'files(id,name)', includeItemsFromAllDrives: true, supportsAllDrives: true });
          files = (res.result && res.result.files) || [];
        }
        if (files.length){
          this.__sheetId = files[0].id;
          this.log('„Ç∑„Éº„ÉàËá™ÂãïËß£Ê±∫: ' + files[0].name + ' (' + this.__sheetId + ')');
          try{ this.fetchPins(this.__sheetId); }catch(_){}
          return this.__sheetId;
        }
        return null;
      }catch(e){
        this.log('„Ç∑„Éº„ÉàËá™ÂãïËß£Ê±∫Â§±Êïó: ' + (e && e.message ? e.message : e), 'error');
        return null;
      }
    }
    hookLegacyAPIs(){
      const self = this;
      let tries = 0;
      const t = setInterval(function(){
        tries++;
        try{
          if (typeof window.loadPinsFromActiveSheet === 'function'){
            const orig = window.loadPinsFromActiveSheet;
            window.loadPinsFromActiveSheet = async function(spreadsheetId){
              self.__sheetId = spreadsheetId || self.__sheetId;
              self.log('„Ç∑„Éº„ÉàIDÂèñÂæó: ' + self.__sheetId);
              try{ self.showBusy('„Éî„É≥„Éª„Ç∑„Éº„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠‚Ä¶'); }catch(_){}
              try{
                const r = await orig.apply(this, arguments);
                if (self.__sheetId) self.fetchPins(self.__sheetId);
                return r;
              } finally { try{ self.hideBusy(); }catch(_){ } }
            };
            self.log('legacy loadPinsFromActiveSheet „Çí„Éï„ÉÉ„ÇØ');
            clearInterval(t);
          }
        }catch(_){}
        if (tries>50) clearInterval(t);
      }, 200);
    }
    hookGapi(){
      let tries = 0;
      const timer = setInterval(()=>{
        tries++;
        try{
          const req = window.gapi && gapi.client && gapi.client.request;
          if (typeof req === 'function'){
            const orig = req;
            const self = this;
            gapi.client.request = function(){
              try{
                var args = (arguments && arguments[0]) || {};
                if (args && args.params && typeof args.params.q === 'string'){
                  var q0 = args.params.q;
                  var q1 = q0.replace(/\s*&&\s*/g, ' and ')
                             .replace(/appProperties has \{\s*key=([^}]+)\s*and\s*value=([^}]+)\s*\}/g, 'appProperties has { key=$1 and value=$2 }');
                  if (q1 !== q0){ args.params.q = q1; try{ window.logStep && window.logStep('DriveQSanitized: ' + q1); }catch(_){ } }
                }
                var url = (args.path || args.url || '') + '';
                if (url.includes('/drive/v3/files')){
                  try{ var m = url.match(/\/drive\/v3\/files\/([^/?]+)/); if (m && m[1]) self.__glbFileId = decodeURIComponent(m[1]); }catch(_){ }
                  var q = args.params && args.params.q;
                  if (q){ try{ window.logStep && window.logStep('DriveQ: ' + q); }catch(_){ } }
                }
                try{ window.M3DBusy && window.M3DBusy.show('ÈÄö‰ø°‰∏≠‚Ä¶'); }catch(_){}
              }catch(_){}
              const r = orig.apply(this, arguments);
              try{
                if (r && typeof r.then === 'function'){
                  return r.then((v)=>{ try{ M3DBusy && M3DBusy.hide(); }catch(_){ } return v; },
                                 (e)=>{ try{ M3DBusy && M3DBusy.hide(); }catch(_){ } throw e; });
                }
              }catch(_){}
              try{ M3DBusy && M3DBusy.hide(); }catch(_){}
              return r;
            };
            this.log('gapi hook ready');
            clearInterval(timer);
          }
        }catch(_){}
        if (tries>50) clearInterval(timer);
      }, 200);
    }
    hookFetchAndXHR(){
      try{
        const origFetch = window.fetch;
        const self = this;
        window.fetch = async (input, init)=>{
          let url = '';
          try{ url = (typeof input==='string') ? input : (input && input.url ? input.url : ''); }catch(_){}
          const isMedia = url.includes('alt=media') || url.includes('/uc?export=download');
          const isSheet = url.includes('sheets.googleapis.com') || url.includes('/spreadsheets/');
          if (isMedia || isSheet) self.showBusy(isMedia ? 'GLB/ÁîªÂÉèÂèñÂæó‰∏≠‚Ä¶' : '„Ç∑„Éº„ÉàÈÄö‰ø°‰∏≠‚Ä¶');
          try{ const res = await origFetch(input, init); return res; }
          finally{ if (isMedia) { try{ self.__lastAltMediaURL = url; self.captureGLBIdFromURL(url); }catch(_){ } } if (isMedia || isSheet) self.hideBusy(); }
        };
      }catch(_){}
      try{
        const OrigXHR = window.XMLHttpRequest;
        if (!OrigXHR) return;
        const self = this;
        const Hook = function(){ const x = new OrigXHR(); return hook(x); };
        function hook(x){
          try{
            let url = '';
            const open = x.open; x.open = function(method, u){ url = String(u||''); return open.apply(this, arguments); };
            const send = x.send; x.send = function(){
              try{
                const isMedia = url.includes('alt=media') || url.includes('/uc?export=download');
                const isG = url.includes('googleapis.com') || url.includes('gapi') || url.includes('/spreadsheets/');
                if (isMedia || isG){ self.showBusy(isMedia ? 'GLB/ÁîªÂÉèÂèñÂæó‰∏≠‚Ä¶' : 'ÈÄö‰ø°‰∏≠‚Ä¶'); }
              }catch(_){}
              x.addEventListener('loadend', function(){ try{ self.hideBusy(); }catch(_){ } }, {once:false});
              return send.apply(this, arguments);
            };
          }catch(_){}
          return x;
        }
        Hook.prototype = OrigXHR.prototype;
        window.XMLHttpRequest = Hook;
      }catch(_){}
    }
  }
  customElements.define('locimyu-ui', LocimyuUI);

  (function(){
    if (!window.M3DUI) window.M3DUI = {};
    const origPin = window.M3DUI.onPinSelected;
    window.M3DUI.onPinSelected = function(pin){
      try{ window.dispatchEvent(new CustomEvent('m3d:pin-selected', { detail: pin })); }catch(_){}
      if (typeof origPin === 'function') return origPin.apply(this, arguments);
    };
    const origLoaded = window.M3DUI.modelLoaded;
    window.M3DUI.modelLoaded = function(){
      try{ window.dispatchEvent(new Event('m3d:model-loaded')); }catch(_){}
      if (typeof origLoaded === 'function') return origLoaded.apply(this, arguments);
    };
  })();

  function mount(){ document.body.appendChild(document.createElement('locimyu-ui')); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', mount, {once:true}); else mount();
})();
</script>
</body>
</html>
