<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GLB Viewer + Sheets Pins (ESM)</title>
  <style>
    :root{--bg:#0b0f14;--panel:#101823;--muted:#9bb0c6;--text:#e9f1fb;--line:#1f2a3a;--accent:#4cc9f0;--ok:#4caf50;--warn:#fbc02d;--err:#ef5350}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.6 system-ui,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;overflow:hidden}
    header{display:flex;gap:10px;align-items:center;padding:8px 12px;background:#0c141e;border-bottom:1px solid var(--line)}
    .pill{padding:4px 10px;border:1px solid var(--line);border-radius:999px;color:#cfe3ff;background:#132135}
    .muted{color:var(--muted)}
    .btn{background:#162134;border:1px solid #273247;color:#d9e9ff;border-radius:10px;padding:6px 10px;cursor:pointer}
    .btn[disabled]{opacity:.55;cursor:not-allowed}
    .ok{background:#14301a;border-color:#27552c}
    .warn{background:#332909;border-color:#5b4f1a}
    .err{background:#3a1111;border-color:#5b1c1c}
    .layout{display:grid; grid-template-columns: 1fr 360px; grid-template-rows: auto 1fr; height:calc(100% - 48px)}
    .toolbar{grid-column:1/3; display:flex; gap:10px; align-items:center; padding:8px; border-bottom:1px solid var(--line); background:#0c1624}
    .panel{background:var(--panel); border-left:1px solid var(--line); display:flex; flex-direction:column}
    .viewer{position:relative; background:#060a10}
    canvas{display:block}
    .kv{display:grid; grid-template-columns: 140px 1fr; gap:8px; align-items:center; padding:8px}
    input, select, textarea{background:#0e1520;border:1px solid #243047;color:#e6f2ff;border-radius:10px;padding:6px 8px;width:100%; font:inherit}
    textarea{min-height:64px; resize:vertical}
    .row{display:flex; gap:8px; align-items:center}
    .sep{flex:1}
    .tiny{font-size:12px;color:var(--muted)}
    .status{min-width:140px;text-align:center;padding:4px 8px;border-radius:999px;border:1px solid #273247;background:#132135}
    .list{flex:1; overflow:auto; padding:8px}
    table{width:100%; border-collapse:collapse}
    th,td{border-bottom:1px solid #223046; padding:6px 8px; font-size:12px; vertical-align:top}
    th{position:sticky; top:0; background:#142034; color:#cfe3ff; text-align:left; z-index:1}
    .log{white-space:pre-wrap;background:#0a1018;border-top:1px solid #1d293a;padding:8px;max-height:160px;overflow:auto}
    .pinRow.selected{background:#13263f}
    .badge{display:inline-block; padding:2px 6px; border-radius:999px; background:#18253a; border:1px solid #273247; font-size:11px; color:#cfe3ff}
  </style>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/api.js" async defer></script>
</head>
<body>
<header>
  <div class="pill">GLB Viewer + Sheets Pins (ESM)</div>
  <div id="authStatus" class="tiny">未サインイン</div>
  <div class="sep"></div>
  <button id="btnSignIn" class="btn">Googleにサインイン</button>
  <button id="btnSignOut" class="btn warn" disabled>サインアウト</button>
</header>

<div class="layout">
  <div class="toolbar">
    <div class="row" style="gap:6px;">
      <span class="tiny">GLB</span>
      <input id="inpGlbId" placeholder="GLB fileId / 共有リンク" style="width:360px">
      <button id="btnLoadGlb" class="btn">読み込む</button>
    </div>
    <div class="row" style="gap:6px; margin-left:16px;">
      <span class="tiny">シートID</span>
      <input id="inpSheetId" placeholder="空なら同階層に &lt;GLB名&gt;_pins を自動作成" style="width:340px">
      <button id="btnFindOrCreate" class="btn ok">検出/作成</button>
      <button id="btnOpenSheet" class="btn" disabled>開く</button>
    </div>
    <div class="sep"></div>
    <label class="row tiny"><input type="checkbox" id="chkAutosave"> オートセーブ</label>
    <span id="saveStatus" class="status">待機中</span>
  </div>

  <div class="viewer" id="viewer"></div>

  <aside class="panel">
    <div class="kv">
      <label>選択ピン</label>
      <div><span id="selPinId" class="badge">-</span></div>
      <label>タイトル</label>
      <input id="pinTitle" placeholder="Title">
      <label>本文</label>
      <textarea id="pinBody" placeholder="Body"></textarea>
      <label>色 (#rrggbb)</label>
      <input id="pinColor" placeholder="#ffcc00" value="#ffcc00">
      <div class="row" style="grid-column:1/3; gap:8px;">
        <button id="btnAddPin" class="btn">クリックで配置モード</button>
        <button id="btnDelPin" class="btn warn">削除フラグ</button>
        <div class="sep"></div>
        <button id="btnSave" class="btn ok">差分を保存</button>
        <button id="btnSnapshot" class="btn">スナップショット</button>
      </div>
    </div>
    <div class="list">
      <table>
        <thead><tr><th>id</th><th>title</th><th>pos</th><th>v</th></tr></thead>
        <tbody id="tblPins"></tbody>
      </table>
    </div>
    <div id="log" class="log"></div>
  </aside>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

/* ============================== Config ============================== */
const CONFIG = {
  API_KEY: "YOUR_API_KEY_HERE",
  CLIENT_ID: "YOUR_CLIENT_ID.apps.googleusercontent.com",
};
const DISCOVERY_DOCS = [
  "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
  "https://sheets.googleapis.com/$discovery/rest?version=v4"
];
const SCOPES = [
  "https://www.googleapis.com/auth/drive.file",
  "https://www.googleapis.com/auth/drive.readonly",
  "https://www.googleapis.com/auth/spreadsheets"
].join(" ");

/* ============================== State ============================== */
let accessToken=null, tokenClient=null, gapiReady=false;
let scene, camera, renderer, controls;
let glbRoot=null, raycaster, mouse=new THREE.Vector2(), addMode=false;
const markers = new Map(); // id -> THREE.Mesh
let current = { glbId:"", glbName:"", parentId:"", sheetId:"" };
let pins = [];          // in-memory
let indexById = new Map();
let dirty = new Set();
let autosaveTimer = null;
let selectedId = null;

/* ============================== Utils ============================== */
const $ = s=>document.querySelector(s);
const esc = s => String(s??"").replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
const nowIso = () => new Date().toISOString();
const log = s => { const el=$("#log"); el.textContent += s + "\\n"; el.scrollTop=el.scrollHeight; };
const setAuth = t => $("#authStatus").textContent = t;
function setSaveState(kind,msg){
  const el=$("#saveStatus");
  el.textContent = msg||({ok:"保存済み",pending:"保存中…",fail:"保存失敗",muted:"待機中"}[kind]||"");
  el.style.background = {ok:"#14301a",pending:"#1f2637",fail:"#3a1111",muted:"#132135"}[kind]||"#132135";
  el.style.borderColor = {ok:"#27552c",pending:"#273247",fail:"#5b1c1c",muted:"#273247"}[kind]||"#273247";
}
function extractId(s){
  if(!s) return "";
  const str=String(s);
  const m1 = str.match(/\/d\/([a-zA-Z0-9_-]{20,})/); if(m1) return m1[1];
  const m2 = str.match(/[?&](?:id|fileId)=([a-zA-Z0-9_-]{20,})/); if(m2) return m2[1];
  const m3 = str.match(/([a-zA-Z0-9_-]{25,})/); return m3?m3[1]:"";
}
function cryptoRandomId(){ const a=new Uint8Array(16); crypto.getRandomValues(a); return [...a].map(b=>b.toString(16).padStart(2,"0")).join(""); }

/* ============================== Boot ============================== */
window.addEventListener("load", async ()=>{
  initViewer();
  bindUI();
  // gapi
  if (window.gapi){
    gapi.load("client", async ()=>{
      await gapi.client.init({ apiKey: CONFIG.API_KEY, discoveryDocs: DISCOVERY_DOCS });
      gapiReady = true; log("gapi ready");
    });
  }
  // GIS
  if (window.google?.accounts?.oauth2){
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CONFIG.CLIENT_ID, scope: SCOPES, prompt:"",
      callback: (resp)=>{
        if (resp?.access_token){
          accessToken = resp.access_token; setAuth("サインイン済み");
          $("#btnSignOut").disabled=false; $("#btnSignIn").disabled=true; log("token acquired");
        }
      }
    });
  }
  // hash token
  try{
    const h=new URLSearchParams((location.hash||"").replace(/^#/,""));
    if (h.get("access_token")){ accessToken=h.get("access_token"); setAuth("サインイン済み"); history.replaceState(null,"",location.pathname+location.search); }
  }catch{}
});

/* ============================== Viewer ============================== */
function initViewer(){
  const el = $("#viewer");
  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(el.clientWidth, el.clientHeight);
  el.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0f14);
  camera = new THREE.PerspectiveCamera(60, el.clientWidth/el.clientHeight, 0.01, 1000);
  camera.position.set(2.8, 1.6, 2.8);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 1.0));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(3,4,5); scene.add(dir);

  const grid = new THREE.GridHelper(20, 20); grid.material.opacity=0.15; grid.material.transparent=true; scene.add(grid);

  raycaster = new THREE.Raycaster();
  window.addEventListener("resize", ()=>{
    renderer.setSize(el.clientWidth, el.clientHeight);
    camera.aspect = el.clientWidth/el.clientHeight; camera.updateProjectionMatrix();
  });

  renderer.setAnimationLoop(()=>{
    controls.update();
    renderer.render(scene, camera);
  });
}

async function loadGlbByDriveId(fileId){
  if (!accessToken) throw new Error("サインインしてください");
  const url = "https://www.googleapis.com/drive/v3/files/"+encodeURIComponent(fileId)+"?alt=media";
  const res = await fetch(url, { headers:{ "Authorization":"Bearer "+accessToken }});
  if (!res.ok) throw new Error("GLBダウンロード失敗: "+res.status);
  const ab = await res.arrayBuffer();
  const blob = new Blob([ab], { type:"model/gltf-binary" });
  const objUrl = URL.createObjectURL(blob);
  const loader = new GLTFLoader();
  return await new Promise((resolve, reject)=>{
    loader.load(objUrl, (gltf)=>{
      URL.revokeObjectURL(objUrl);
      resolve(gltf);
    }, undefined, (e)=>{ URL.revokeObjectURL(objUrl); reject(e); });
  });
}

function clearModel(){
  if (glbRoot){ scene.remove(glbRoot); glbRoot.traverse(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material){ if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose()); else o.material.dispose(); } }); glbRoot=null; }
  for (const [id,mesh] of markers){ scene.remove(mesh); }
  markers.clear();
}

function addMarker(id, pos, color="#ffcc00"){
  const geo = new THREE.SphereGeometry(0.02, 16, 16);
  const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(color) });
  const m = new THREE.Mesh(geo, mat);
  m.position.set(pos[0], pos[1], pos[2]);
  m.userData.pinId = id;
  scene.add(m);
  markers.set(id, m);
  return m;
}

/* ============================== UI ============================== */
function bindUI(){
  $("#btnSignIn").onclick = async ()=>{
    if (!tokenClient){ alert("GIS未ロード"); return; }
    tokenClient.requestAccessToken({ prompt:"consent" });
    setTimeout(()=>{ if(!accessToken) redirectOAuth(); }, 700);
  };
  $("#btnSignOut").onclick = ()=>{
    if (accessToken) google.accounts.oauth2.revoke(accessToken);
    accessToken=null; setAuth("未サインイン"); $("#btnSignOut").disabled=true; $("#btnSignIn").disabled=false;
  };
  $("#btnLoadGlb").onclick = async ()=>{
    try{
      await ensureSigned();
      const glbRaw = $("#inpGlbId").value.trim(); const glbId = extractId(glbRaw);
      if (!glbId) throw new Error("GLB id/リンクを入力");
      const meta = await driveGetFile(glbId, "id,name,parents");
      current.glbId = meta.id; current.glbName=(meta.name||"model").replace(/\.[^.]+$/,""); current.parentId=(meta.parents&&meta.parents[0])||"";
      clearModel();
      const gltf = await loadGlbByDriveId(glbId);
      glbRoot = gltf.scene; scene.add(glbRoot);
      fitCameraToObject(glbRoot, camera, controls);
      log("GLB読み込みOK: "+meta.name);
    }catch(e){ log("loadGlb: "+e.message); }
  };

  $("#btnFindOrCreate").onclick = findOrCreateSheet;
  $("#btnOpenSheet").onclick = ()=>{ if (current.sheetId) window.open(`https://docs.google.com/spreadsheets/d/${current.sheetId}/edit`,"_blank"); };

  $("#btnAddPin").onclick = ()=>{
    if (!glbRoot){ alert("先にGLBを読み込んでください"); return; }
    addMode = !addMode;
    $("#btnAddPin").textContent = addMode ? "表示中：クリックでピン設置（Escで終了）" : "クリックで配置モード";
  };
  $("#btnDelPin").onclick = ()=>{
    if (!selectedId) return;
    const p = pins[indexById.get(selectedId)]; if (!p) return;
    p.deleted = true; dirty.add(p.id);
    if (markers.get(p.id)){ scene.remove(markers.get(p.id)); markers.delete(p.id); }
    renderPinTable();
  };
  $("#pinTitle").oninput = ()=>{ if(!selectedId) return; const p=pins[indexById.get(selectedId)]; p.title=$("#pinTitle").value; dirty.add(p.id); };
  $("#pinBody").oninput  = ()=>{ if(!selectedId) return; const p=pins[indexById.get(selectedId)]; p.body=$("#pinBody").value; dirty.add(p.id); };
  $("#pinColor").onchange= ()=>{ if(!selectedId) return; const p=pins[indexById.get(selectedId)]; p.color_hex=$("#pinColor").value; dirty.add(p.id); if(markers.get(p.id)) markers.get(p.id).material.color.set(p.color_hex); };

  $("#btnSave").onclick = saveChanges;
  $("#btnSnapshot").onclick = snapshotSave;
  $("#chkAutosave").onchange = ()=>{ $("#chkAutosave").checked ? startHeartbeat() : stopHeartbeat(); };

  $("#viewer").addEventListener("pointerdown", onPointerDown);
  window.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && addMode){ addMode=false; $("#btnAddPin").textContent="クリックで配置モード"; }});
}

function fitCameraToObject(obj, camera, controls){
  const box = new THREE.Box3().setFromObject(obj);
  const size = box.getSize(new THREE.Vector3()).length();
  const center = box.getCenter(new THREE.Vector3());
  controls.reset();
  obj.position.sub(center);
  controls.maxDistance = size*10;
  camera.near = size/100; camera.far = size*10; camera.updateProjectionMatrix();
  camera.position.copy(center).add(new THREE.Vector3(size/2, size/5, size/2));
  controls.target.copy(center);
  controls.update();
}

function onPointerDown(ev){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster = raycaster || new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const objs = []; glbRoot && glbRoot.traverse(o=>{ if (o.isMesh) objs.push(o); });
  const hits = raycaster.intersectObjects(objs, true);
  if (!hits.length) return;
  const hit = hits[0];
  if (addMode){
    const id = cryptoRandomId();
    const p = { id, title:"", body:"", color_hex: $("#pinColor").value || "#ffcc00",
      pos:[hit.point.x, hit.point.y, hit.point.z], rot:[0,0,0], order:pins.length, deleted:false, updated_at:"", updated_by:"", version:0 };
    indexById.set(id, pins.length); pins.push(p); dirty.add(id);
    addMarker(id, p.pos, p.color_hex);
    addMode=false; $("#btnAddPin").textContent="クリックで配置モード";
    selectPin(id);
    renderPinTable();
  } else {
    const world = hit.point;
    let nearestId=null, nearestDist=1e9;
    for (const [id,mesh] of markers){
      const d = mesh.position.distanceTo(world);
      if (d < nearestDist){ nearestDist=d; nearestId=id; }
    }
    if (nearestId && nearestDist<0.15) selectPin(nearestId);
  }
}

function renderPinTable(){
  const tb=$("#tblPins"); tb.innerHTML="";
  for (const p of pins){
    if (p.deleted) continue;
    const tr=document.createElement("tr"); tr.className="pinRow"; tr.dataset.id=p.id;
    if (p.id===selectedId) tr.classList.add("selected");
    tr.innerHTML = `<td class="tiny">${esc(p.id.slice(0,8))}</td><td>${esc(p.title||"(無題)")}</td><td class="tiny">${p.pos.map(n=>n.toFixed(2)).join(",")}</td><td>${p.version|0}</td>`;
    tr.onclick = ()=> selectPin(p.id);
    tb.appendChild(tr);
  }
}

function selectPin(id){
  selectedId = id;
  const p = pins[indexById.get(id)];
  $("#selPinId").textContent = id.slice(0,8);
  $("#pinTitle").value = p.title||"";
  $("#pinBody").value  = p.body||"";
  $("#pinColor").value = p.color_hex||"#ffcc00";
  renderPinTable();
}

/* ============================== Drive ============================== */
async function ensureSigned(){
  if (accessToken) return true;
  if (!tokenClient) throw new Error("GIS未ロード");
  return await new Promise((ok)=>{
    tokenClient.callback=(resp)=>{ if(resp?.access_token){ accessToken=resp.access_token; setAuth("サインイン済み"); ok(true);} else ok(false); };
    tokenClient.requestAccessToken({ prompt:"consent" });
    setTimeout(()=>{ if(!accessToken){ redirectOAuth(); } }, 700);
  });
}
function redirectOAuth(){
  const redir = location.origin+location.pathname+location.search;
  const url = "https://accounts.google.com/o/oauth2/v2/auth"
    + "?client_id=" + encodeURIComponent(CONFIG.CLIENT_ID)
    + "&redirect_uri=" + encodeURIComponent(redir)
    + "&response_type=token"
    + "&scope=" + encodeURIComponent(SCOPES)
    + "&include_granted_scopes=true"
    + "&prompt=consent";
  location.assign(url);
}
async function driveGetFile(fileId, fields="id,name,parents,mimeType"){
  if(!gapiReady) throw new Error("gapi not ready");
  const r = await gapi.client.drive.files.get({ fileId, fields });
  return r.result;
}
async function driveList(q, fields="files(id,name,modifiedTime)", pageToken){
  if(!gapiReady) throw new Error("gapi not ready");
  const r = await gapi.client.drive.files.list({ q, fields, pageSize: 200, pageToken });
  return r.result;
}
async function driveCreateSpreadsheet(name, parentId){
  if(!accessToken) throw new Error("no token");
  const meta = { name, mimeType:"application/vnd.google-apps.spreadsheet" };
  const boundary = "-------314159265358979323846";
  const body = `--${boundary}\r\nContent-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(meta)}\r\n--${boundary}--`;
  const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
    method:"POST",
    headers:{ "Authorization":"Bearer "+accessToken, "Content-Type":"multipart/related; boundary="+boundary },
    body
  });
  const j = await res.json();
  if (parentId){
    await gapi.client.drive.files.update({ fileId: j.id, addParents: parentId });
  }
  return j;
}

/* ============================== Sheets ============================== */
async function sheetsValuesGet(id, range){
  const r = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId:id, range });
  return r.result;
}
async function sheetsValuesUpdate(id, range, values, opt="RAW"){
  const r = await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId:id, range, valueInputOption:opt, resource:{ values:Array.isArray(values[0])?values:[values] } });
  return r.result;
}
async function sheetsValuesAppend(id, range, values, opt="RAW"){
  const r = await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId:id, range, valueInputOption:opt, insertDataOption:"INSERT_ROWS", resource:{ values:Array.isArray(values[0])?values:[values] } });
  return r.result;
}
async function sheetsBatchUpdate(id, requests){
  const r = await gapi.client.sheets.spreadsheets.batchUpdate({ spreadsheetId:id, resource:{ requests } });
  return r.result;
}
async function setupSheet(id){
  const ss = await gapi.client.sheets.spreadsheets.get({ spreadsheetId:id });
  const titles = new Set((ss.result.sheets||[]).map(s=>s.properties.title));
  const needs = [];
  for (const t of ["Pins","Materials","AuditLog","Meta"]){
    if (!titles.has(t)) needs.push({ addSheet:{ properties:{ title:t, gridProperties:{ frozenRowCount:1 }}}});
  }
  if (needs.length) await sheetsBatchUpdate(id, needs);
  await sheetsValuesUpdate(id, "Pins!A1:Q1", [["id","title","body","color_hex","pos_x","pos_y","pos_z","rot_x","rot_y","rot_z","order","deleted","updated_at","updated_by","version","",""]]);
  await sheetsValuesUpdate(id, "Materials!A1:C1", [["name","key","value"]]);
  await sheetsValuesUpdate(id, "AuditLog!A1:G1", [["when","who","pin_id","field","old","new","client_rev"]]);
  await sheetsValuesUpdate(id, "Meta!A1:B1", [["key","value"]]);
  await sheetsValuesUpdate(id, "Meta!A2:B2", [["app_version","viewer-sheets-esm-1.0"]]);
}

/* ============================== Pins (load/save) ============================== */
$("#btnFindOrCreate").disabled = false;
async function findOrCreateSheet(){
  try{
    await ensureSigned();
    const manual = extractId($("#inpSheetId").value.trim());
    if (manual){
      current.sheetId = manual; $("#btnOpenSheet").disabled=false;
      await setupSheet(current.sheetId);
      log("指定シートを使用: "+current.sheetId);
      return;
    }
    if (!current.parentId || !current.glbName) throw new Error("先にGLBを読み込んで親フォルダを確定してください");
    const q = `'${current.parentId}' in parents and trashed=false and mimeType='application/vnd.google-apps.spreadsheet' and name='${current.glbName.replace(/'/g,"\\'")}_pins'`;
    const res = await driveList(q, "files(id,name,modifiedTime)");
    if (res.files && res.files.length){ current.sheetId = res.files[0].id; }
    else { const created = await driveCreateSpreadsheet(`${current.glbName}_pins`, current.parentId); current.sheetId = created.id; }
    $("#inpSheetId").value = current.sheetId; $("#btnOpenSheet").disabled=false;
    await setupSheet(current.sheetId);
    log("シート準備OK: "+current.sheetId);
  }catch(e){ log("findOrCreateSheet: "+e.message); }
}

async function loadPins(){
  try{
    if (!current.sheetId){ const id=extractId($("#inpSheetId").value.trim()); if(!id) throw new Error("シートID未設定"); current.sheetId=id; }
    const val = await sheetsValuesGet(current.sheetId, "Pins!A2:Q");
    pins = []; indexById.clear(); dirty.clear();
    for (const [id,m] of markers){ scene.remove(m); } markers.clear();
    for (const row of (val.values||[])){
      const get=(i,d="")=>(i<row.length?row[i]:d);
      const num=(i,d=0)=>{ const v=get(i,""); const n=parseFloat(v); return Number.isFinite(n)?n:d; };
      const p={
        id:get(0), title:get(1), body:get(2), color_hex:get(3)||"#ffcc00",
        pos:[num(4),num(5),num(6)], rot:[num(7),num(8),num(9)],
        order:parseInt(get(10)||"0",10), deleted:(get(11)||"0")==="1"||(get(11)||"FALSE")==="TRUE",
        updated_at:get(12)||"", updated_by:get(13)||"", version:parseInt(get(14)||"0",10)
      };
      if (!p.deleted){
        indexById.set(p.id, pins.length); pins.push(p);
        addMarker(p.id, p.pos, p.color_hex);
      }
    }
    renderPinTable();
    log(`Pins 読込: ${pins.length}件`);
  }catch(e){ log("loadPins: "+e.message); }
}

function pinToRow(p){
  return [
    p.id, p.title, p.body, p.color_hex,
    p.pos?.[0]??0, p.pos?.[1]??0, p.pos?.[2]??0,
    p.rot?.[0]??0, p.rot?.[1]??0, p.rot?.[2]??0,
    p.order|0, p.deleted?1:0, p.updated_at||"", p.updated_by||"", p.version|0, "", ""
  ];
}

async function saveChanges(){
  try{
    if (!current.sheetId) throw new Error("先にシートIDを設定/作成してください");
    if (!dirty.size){ setSaveState("muted","保存対象なし"); return; }
    setSaveState("pending","保存中…");

    const cur = await sheetsValuesGet(current.sheetId, "Pins!A2:Q");
    const rows = cur.values || [];
    const rowIndexById = new Map();
    for (let i=0;i<rows.length;i++){ const id=rows[i][0]; if(id) rowIndexById.set(id, i+2); }

    for (const id of [...dirty]){
      const p = pins[indexById.get(id)]; if(!p) continue;
      if (!rowIndexById.has(p.id)){
        p.version=1; p.updated_at=nowIso(); p.updated_by=await whoami();
        await sheetsValuesAppend(current.sheetId, "Pins!A:Q", [pinToRow(p)]);
        await appendAudit({pin_id:p.id, field:"__create__", old:"", new:JSON.stringify(p)});
      } else {
        const rowIndex = rowIndexById.get(p.id);
        const curRow = rows[rowIndex-2] || [];
        const curVer = parseInt(curRow[14]||"0",10);
        const curAt  = curRow[12]||"";
        if (curVer !== (p.version|0) || curAt !== (p.updated_at||"")){
          await appendAudit({pin_id:p.id, field:"__conflict__", old:JSON.stringify({version:curVer,updated_at:curAt}), new:JSON.stringify({version:p.version,updated_at:p.updated_at})});
        }
        p.version = Math.max(curVer, p.version|0) + 1;
        p.updated_at = nowIso(); p.updated_by = await whoami();
        await sheetsValuesUpdate(current.sheetId, `Pins!A${rowIndex}:Q${rowIndex}`, [pinToRow(p)]);
        await appendAudit({pin_id:p.id, field:"__update__", old:"", new:JSON.stringify(p)});
      }
    }
    dirty.clear();
    await loadPins();
    setSaveState("ok");
  }catch(e){ setSaveState("fail","保存失敗"); log("saveChanges: "+e.message); }
}

async function snapshotSave(){
  try{
    if (!current.sheetId) throw new Error("sheet未設定");
    const nm = prompt("新規シート名（タブ名）を入力してください", "pins_"+new Date().toISOString().replace(/[:T]/g,"").slice(0,12));
    if(!nm) return;
    await sheetsBatchUpdate(current.sheetId, [{ addSheet:{ properties:{ title:nm }}}]);
    await sheetsValuesUpdate(current.sheetId, `${nm}!A1:Q1`, [["id","title","body","color_hex","pos_x","pos_y","pos_z","rot_x","rot_y","rot_z","order","deleted","updated_at","updated_by","version","",""]]);
    const rows = pins.map(pinToRow);
    if (rows.length) await sheetsValuesUpdate(current.sheetId, `${nm}!A2:Q`, rows);
    alert("スナップショット保存しました");
  }catch(e){ alert("スナップショット保存に失敗: "+e.message); }
}

async function appendAudit({pin_id, field, old, new:newVal}){
  try{
    const who = await whoami();
    await sheetsValuesAppend(current.sheetId, "AuditLog!A:G", [[nowIso(), who, pin_id, field, String(old||""), String(newVal||""), "web"]]);
  }catch{}
}
async function whoami(){
  try{
    const r = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", { headers:{ "Authorization":"Bearer "+accessToken }});
    if (!r.ok) return "";
    const j = await r.json(); return j.email || j.sub || "";
  }catch{ return ""; }
}

function startHeartbeat(){
  stopHeartbeat();
  autosaveTimer=setInterval(async()=>{ if(dirty.size) await saveChanges(); },10000);
  setSaveState("muted","オートセーブON");
}
function stopHeartbeat(){ if(autosaveTimer){ clearInterval(autosaveTimer); autosaveTimer=null; setSaveState("muted","オートセーブOFF"); } }
</script>
</body>
</html>
