<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Drive GLB Viewer + Pins (v1.22.0-bg)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='%23222'/%3E%3Ccircle cx='32' cy='32' r='18' fill='%23e33'/%3E%3C/svg%3E">

  <!-- ★★ 先読み & 事前ロード（モバイルの“ユーザー操作扱い”維持のため、クリック時にawaitさせない） -->
  <link rel="preconnect" href="https://accounts.google.com">
  <script async src="https://accounts.google.com/gsi/client"></script>
  <script async src="https://apis.google.com/js/api.js"></script>

  <style>
  /* 非活性行の見た目と操作抑止 */
.disabled { opacity: .55; pointer-events: none; }
    :root { --bg:#111; --muted:#666; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:#222;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    header{display:flex;gap:8px;align-items:center;padding:10px 12px;background:#f8f8f8;border-bottom:1px solid #e8e8e8;position:sticky;top:0;z-index:10;flex-wrap:wrap}
    header input{padding:6px 8px;border:1px solid #ddd;border-radius:8px;min-width:200px}
    header button{padding:6px 10px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer}
    header .grow{flex:1}
    main{display:grid;grid-template-columns: 1fr 360px;gap:10px;}
    #view{position:relative;width:100%;height:calc(100vh - 56px);overflow:hidden;background:#222}
    #canvas{display:block;width:100%;height:100%}
    aside{height:calc(100vh - 56px);overflow:auto;background:#fafafa;border-left:1px solid #eee}
    .sec{padding:10px 12px;border-bottom:1px solid #eee}
    .row{display:flex;gap:8px;align-items:center;margin-top:6px;flex-wrap:wrap}
    .muted{color:var(--muted);font-size:12px}
    .hidden{display:none}
    .warn{color:#b00}
    .badge{display:inline-block;background:#eef;border:1px solid #dde;border-radius:999px;padding:2px 8px;font-size:12px}
    .pin{border:1px solid #e5e5e5;background:#fff;border-radius:10px;padding:8px;margin-top:8px}
    .pin input,.pin textarea{width:100%;border:1px solid #ddd;border-radius:6px;padding:6px}
    .pin img{max-width:100%;border-radius:8px;margin-top:6px;cursor:zoom-in}
    #dbg{position:fixed;left:8px;bottom:8px;color:#0f0;font:12px/1.2 monospace;z-index:9999;pointer-events:none;white-space:pre}
    .float-layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .float-card{
      position:absolute; min-width:200px; max-width:280px; pointer-events:auto;
      background:#fff; border:1px solid #ddd; border-radius:10px; box-shadow:0 8px 22px rgba(0,0,0,0.3);
      user-select:none;
    }
    .float-card header{display:flex; align-items:center; gap:8px; padding:6px 8px; border-bottom:1px solid #eee;
      background:#f6f7fb; border-radius:10px 10px 0 0; cursor:grab;}
    .float-card header:active{ cursor:grabbing; }
    .float-card header input{flex:1; min-width:0; border:1px solid #ddd; border-radius:6px; padding:4px 6px; font-size:13px; background:#fff;}
    .float-card .body{ padding:8px }
    .float-card .body textarea{ width:100%; border:1px solid #ddd; border-radius:6px; padding:6px; min-height:70px }
    .float-card .body img{ display:block; max-width:100%; border-radius:8px; margin-top:6px; cursor:zoom-in }
    .float-card .footer{ display:flex; gap:6px; padding:8px; border-top:1px solid #eee; flex-wrap:wrap; align-items:center }
    .float-card .btn{ padding:4px 8px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer; font-size:12px }
    .float-card .btn.warn{ color:#b00 }
    .float-card a.small { font-size:12px; color:#06c; text-decoration:none }
    .float-card a.small:hover { text-decoration:underline }
    .lines{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none }
    .lines line{ stroke:#fff; stroke-opacity:0.85; stroke-width:2; filter:drop-shadow(0 0 1px rgba(0,0,0,.7)); }
    .pill {font-size:12px;border:1px solid #ddd;border-radius:999px;padding:4px 8px;background:#fff;display:inline-flex;gap:6px;align-items:center}
    .pill input{margin:0}
    .pill.small{font-size:11px;padding:2px 6px}
    .save-ok{color:#0a0}.save-pending{color:#a60}.save-fail{color:#b00}

    /* ==== Editor Dock ==== */
    .dock{
      position:absolute; top:12px; right:12px; width:340px; max-height:80vh; overflow:auto;
      background:#ffffffea; backdrop-filter:saturate(1.2) blur(4px);
      border:1px solid #ddd; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35);
      z-index:8; /* ← ヘッダー(z=10)より下：被り防止 */
    }
    .dock header{
      display:flex; align-items:center; gap:8px; padding:8px 10px; border-bottom:1px solid #eee;
      position:sticky; top:0; background:#f6f7fb; border-radius:12px 12px 0 0;
    }
    .dock .tabs{ display:flex; gap:6px; flex-wrap:wrap }
    .dock .tabbtn{ padding:4px 10px; font-size:12px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:pointer; }
    .dock .tabbtn.active{ background:#eef; border-color:#cdd; }
    .dock .minbtn{ margin-left:auto; padding:4px 8px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer; font-size:12px }
    .dock .body{ padding:10px }
    .dock.collapsed .body{ display:none }
    .dock.collapsed header{ border-radius:12px }
    .tool-row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:8px }
    .tool-btn{ padding:6px 10px; border:1px solid #ddd; background:#fff; border-radius:8px; font-size:12px; cursor:pointer }
    .tool-btn.toggled{ background:#e8f0fe; border-color:#c7dafc }
    .tool-input{ display:flex; align-items:center; gap:8px; margin-bottom:8px }
    .tool-input input[type="range"]{ width:160px }

    /* ==== Modal (list/picker) ==== */
    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:50; }
    .modal{ width:840px; max-width:95vw; max-height:86vh; overflow:auto; background:#fff; border:1px solid #ddd; border-radius:12px; box-shadow:0 20px 40px rgba(0,0,0,0.4); }
    .modal header{ position:sticky; top:0; background:#f6f7fb; border-bottom:1px solid #eee; padding:10px 12px; display:flex; gap:8px; align-items:center }
    .modal .body{ padding:12px }
    .list{ border:1px solid #eee; border-radius:10px; overflow:hidden }
    .rowi{ display:grid; grid-template-columns: 1fr 200px 120px; gap:8px; padding:8px 10px; border-bottom:1px solid #f0f0f0; align-items:center }
    .rowi:last-child{ border-bottom:none }
    .rowi .name{ font-weight:600 }
    .rowi .meta{ font-size:12px; color:#666 }
    .modal footer{ padding:10px 12px; border-top:1px solid #eee; display:flex; gap:8px; justify-content:flex-end }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap:10px }
    .card{ border:1px solid #eee; border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:6px; }
    .card img{ width:100%; aspect-ratio: 1 / 1; object-fit:cover; border-radius:8px; background:#f3f3f3 }
    .card .title{ font-size:12px; line-height:1.4; }
    .card .meta{ font-size:11px; color:#666; }
    .card button{ padding:6px 8px; font-size:12px; }

    /* ==== Image Zoom Viewer ==== */
    
    /* ==== Sign-in Gate (mobile first) ==== */
.gate-overlay{
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.55); z-index:40;
}
.gate{
  background:#fff; border:1px solid #ddd; border-radius:14px; padding:16px 18px;
  width:min(92vw,420px); text-align:center; box-shadow:0 18px 40px rgba(0,0,0,.35);
}
.gate h3{ margin:0 0 8px; font-size:16px }
.gate p { margin:0 0 12px; color:#666; font-size:13px }
.gate .btn{ padding:10px 14px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:pointer; font-size:14px }
.hidden{ display:none }

/* FAB: モバイルでドックを開く小ボタン */
#dockFab{
  position:absolute; right:12px; bottom:12px; z-index:9;
  display:none; padding:10px 14px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:pointer;
}
@media (max-width: 640px){
  header{ padding:8px 10px }
  .hgroup .tiny, .header-utils{ display:none }   /* 右端のPDF等を隠す */
  .dock{ display:none }                          /* 初期は隠す。必要時はFABで開く */
  #dockFab{ display:block }
}

    
    .zoom-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.85); display:flex; align-items:center; justify-content:center; z-index:60; cursor:grab }
    .zoom-img{ max-width:none; max-height:none; transform-origin: 0 0; user-select:none; -webkit-user-drag:none; }
    .zoom-close{ position:fixed; top:12px; right:12px; z-index:61; padding:8px 10px; background:#fff; border:1px solid #ddd; border-radius:8px; cursor:pointer; }

    /* ==== Toolbar groups ==== */
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-start; width:100% }
    .hgroup{
      background:#fff; border:1px solid #e6e6e6; border-radius:12px; padding:8px 10px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .hgroup .title{ font-weight:600; font-size:12px; color:#444; padding:2px 8px; background:#f4f4f6; border:1px solid #e9e9ee; border-radius:999px }
    .hgroup input{ padding:6px 8px; border:1px solid #ddd; border-radius:8px; min-width:220px }
    .hgroup .tiny{ font-size:12px; color:#666 }
    .hgroup .iconbtn{ padding:4px 8px; font-size:12px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer }
    .hgroup .sep{ width:1px; height:20px; background:#eee; margin:0 2px }
    header .grow{ flex:1 }
    .header-utils{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    #pillAutosave { padding:2px 8px }
    #pillAutosave input { transform:scale(.95) }

    @media (max-width: 960px){
      main{ grid-template-columns: 1fr }
      aside{ display:none }
      .dock{ left:12px; right:12px; width:auto }
      .dock .tabbtn{ padding:6px 12px }
      .tool-btn{ padding:8px 12px }
    }
  </style>
</head>
<body>
<header>
  <div class="toolbar">
    <!-- 📦 モデル -->
    <div class="hgroup" id="grpModel">
      <span class="title">モデル</span>
      <input id="fileId" placeholder="GLBの fileId または 共有リンク" autocomplete="off" />
      <button id="btnLoad" class="iconbtn">読み込む</button>
      <button id="helpModel" class="iconbtn" title="対応形式など">？</button>
      <span class="tiny" id="status">未サインイン</span>
    </div>

    <!-- 📍 キャプション -->
    <div class="hgroup" id="grpPins">
      <span class="title">キャプション</span>
      <input id="pinsId" placeholder="（任意）pins.json の fileId / 共有リンク" autocomplete="off" />
      <button id="btnPickPins" class="iconbtn">選択…</button>
      <button id="btnClearPins" class="iconbtn">クリア</button>
      <span class="sep"></span>
      <span class="tiny">Save FolderId:</span>
      <input id="folderId" placeholder="（任意）保存先フォルダID" autocomplete="off" />
      <button id="helpPins" class="iconbtn" title="pins.jsonの説明">？</button>
    </div>

    <!-- 🔑 共有・権限 -->
    <div class="hgroup" id="grpShare">
      <span class="title">共有・権限</span>
      <button id="btnAuth" class="iconbtn">Googleにサインイン</button>

      <div class="pill" id="pillAutosave" title="pins.json を自動保存">
        <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;">
          <input type="checkbox" id="autoSave" checked> 🧷オートセーブ
        </label>
        <span id="saveStatus" class="muted">待機中</span>
      </div>

      <div class="sep"></div>
      <div class="pill"><button id="btnCopyReadonlyUrl" title="閲覧専用URLをコピー">閲覧専用URLをコピー</button></div>
      <div class="pill"><span class="muted">GLB:</span><button id="btnToggleGlbPublic" title="公開/限定を切替（デフォルトは限定）">限定</button></div>
      <div class="pill"><span class="muted">pins:</span><button id="btnTogglePinsPublic" title="公開/限定を切替（デフォルトは限定）" disabled>限定</button></div>
    </div>

    <div class="grow"></div>

    <!-- 右端ユーティリティ -->
    <div class="header-utils">
      <a class="iconbtn" id="btnGuidePdf" href="./docs/museum3dviewer_user_guide.pdf" target="_blank" rel="noopener">使い方ガイド（PDF）</a>
      <span class="tiny">v1.22.0-bg</span>
    </div>
  </div>
</header>

<main>
  <div id="view">
    <canvas id="canvas"></canvas>
    <svg class="lines" id="lines"></svg>
    <div class="float-layer" id="floatLayer"></div>
    
    <!-- サインインゲート（必要なときだけ表示） -->
<div id="signinGateWrap" class="gate-overlay hidden">
  <div class="gate">
    <h3>Googleにサインイン</h3>
    <p>Driveの読み書きが必要です。ボタンを押して開始してください。</p>
    <button id="btnGateSignIn" class="btn">サインインして続行</button>
  </div>
</div>

<!-- モバイル用：ドック表示トグル -->
<button id="dockFab" title="ツール">ツール</button>


    <!-- 編集ドック -->
    <div class="dock" id="editorDock">
      <header>
        <div class="tabs">
          <button class="tabbtn active" data-tab="move">移動</button>
          <button class="tabbtn" data-tab="materials">マテリアル</button>
          <button class="tabbtn" data-tab="camera">カメラ</button>
        </div>
        <button class="minbtn" id="dockMin">最小化</button>
      </header>
      <div class="body">
        <div id="tab-move">
          <div class="tool-row">
            <button class="tool-btn" id="dockMoveToggle">ギズモ ON</button>
            <button class="tool-btn" id="dockCenterSelected">選択ピンへ</button>
          </div>
          <div class="tool-row">
            <button class="tool-btn toggled" id="axisX">X</button>
            <button class="tool-btn toggled" id="axisY">Y</button>
            <button class="tool-btn toggled" id="axisZ">Z</button>
          </div>
          <div class="muted">G：ギズモ切替 / X,Y,Z：軸表示 / Esc：ポップアップ閉じ</div>
        </div>

        <div id="tab-materials" style="display:none">
          <div class="muted" style="margin-bottom:6px">3Dスキャン前提。必要最低限の調整のみ。</div>
          <div id="materialsDock"></div>
        </div>

        <div id="tab-camera" style="display:none">
          <div class="tool-row">
            <label class="pill" style="gap:10px">
              <span>投影:</span>
              <select id="projMode">
                <option value="persp">透視投影</option>
                <option value="ortho">平行投影</option>
              </select>
            </label>
            <button class="tool-btn" id="btnFrame">モデルにフィット</button>
          </div>
          <div class="tool-input" id="rowFov">
            <span class="muted" style="width:70px">視野角</span>
            <input type="range" id="fov" min="25" max="90" step="1">
            <span class="muted" id="fovVal"></span>
          </div>
          <div class="tool-input" id="rowZoom" style="display:none">
            <span class="muted" style="width:70px">ズーム</span>
            <input type="range" id="zoom" min="0.5" max="3" step="0.01" value="1">
            <span class="muted" id="zoomVal">1.00</span>
          </div>
          <div class="tool-row">
            <span class="muted" style="width:70px">ビュー</span>
            <button class="tool-btn" data-view="front">前</button>
            <button class="tool-btn" data-view="back">後</button>
            <button class="tool-btn" data-view="left">左</button>
            <button class="tool-btn" data-view="right">右</button>
            <button class="tool-btn" data-view="top">上</button>
            <button class="tool-btn" data-view="bottom">下</button>
          </div>
          <div class="tool-row">
            <label class="pill" style="gap:10px">
              <span>背景:</span>
              <select id="bgMode">
                <option value="dark" selected>暗</option>
                <option value="light">明</option>
              </select>
            </label>
            <label class="pill" style="gap:10px">
              <span>背景色</span>
              <input type="color" id="bgColor" value="#222222">
            </label>
          </div>
          <div class="tool-row">
            <label class="pill" style="gap:10px">
              <input type="checkbox" id="touchMode"> タッチUIを使う
            </label>
          </div>
          <div class="muted" id="touchHelp"></div>
        </div>
      </div>
    </div>
  </div>

  <aside>
    <div class="sec">
      <div class="muted" id="hintDesktop" style="margin-top:6px">
        Shift+クリック = ピン追加 / 左=回転 / 右=パン / ホイール=ズーム<br>
        ピンをクリック → ポップアップを<strong>複数</strong>開けます（Ctrl+クリック＝このピンだけ残す）<br>
        Escで全ポップアップ閉、移動モードOFFでギズモ非表示
      </div>
      <div class="muted hidden" id="hintTouch" style="margin-top:6px">
        1本指=回転 / 2本指=パン / ピンチ=ズーム / <b>長押し</b>=ピン追加<br>
        ピンをタップ → ポップアップを複数開けます（長押しで位置追加）
      </div>
      <div class="warn muted" id="scopeWarn" style="display:none;margin-top:6px">
        書き込み権限不足。上の「Googleにサインイン」から再同意、または「ピンをDriveに保存」を押してください。
      </div>
    </div>

    <div class="sec">
      <div class="row" id="pinActions">
        <button id="btnUndo" disabled>元に戻す (Ctrl+Z)</button>
        <button id="btnRedo" disabled>やり直す (Ctrl+Shift+Z)</button>
        <button id="btnSavePins">ピンをDriveに保存（リネーム）</button>
        <button id="btnAddPin">ピン追加（画面中央）</button>
        <label class="pill" id="pillMove" title="Gキーでも切替"><input type="checkbox" id="moveMode"> 移動モード（ギズモ）</label>
      </div>

      <strong>ピン一覧（クリックで編集） <span class="badge" id="pinCount">ピン: 0</span></strong>
      <div id="pins"></div>
      <div class="muted" style="margin-top:6px" id="pinsInfo"></div>
    </div>
  </aside>
</main>

<div id="dbg"></div>
<div id="modalRoot" class="hidden"></div>

<script type="module">
'use strict';
console.log('drive_three_pins v1.22.0-bg');

/* ===== Config: OAuth / Drive ===== */
const SCOPES_READ  = "https://www.googleapis.com/auth/drive.readonly";
const SCOPES_WRITE = "https://www.googleapis.com/auth/drive.file";
const SCOPES_FULL  = "https://www.googleapis.com/auth/drive";
const ALL_SCOPES   = `${SCOPES_READ} ${SCOPES_WRITE} ${SCOPES_FULL}`;
const CLIENT_ID    = "595200751510-ncahnf7edci6b9925becn5to49r6cguv.apps.googleusercontent.com";

/* ===== DOM ===== */
const canvas       = document.getElementById('canvas');
const view         = document.getElementById('view');
const statusEl     = document.getElementById('status');
const dbg          = document.getElementById('dbg');
const linesSvg     = document.getElementById('lines');
const floatLayer   = document.getElementById('floatLayer');
const pinsEl       = document.getElementById('pins');
const pinCountEl   = document.getElementById('pinCount');
const pinsInfoEl   = document.getElementById('pinsInfo');
const scopeWarnEl  = document.getElementById('scopeWarn');
const autoSaveEl   = document.getElementById('autoSave');
const saveStatusEl = document.getElementById('saveStatus');
const btnAuth      = document.getElementById('btnAuth');
const btnLoad      = document.getElementById('btnLoad');
const btnSavePins  = document.getElementById('btnSavePins');
const btnAddPin    = document.getElementById('btnAddPin');
const moveModeEl   = document.getElementById('moveMode');
const pillMove     = document.getElementById('pillMove');
const pillAutosave = document.getElementById('pillAutosave');
const fileIdInput  = document.getElementById('fileId');
const pinsIdInput  = document.getElementById('pinsId');
const folderIdInput= document.getElementById('folderId');
const btnPickPins  = document.getElementById('btnPickPins');
const btnClearPins = document.getElementById('btnClearPins');
const btnCopyReadonlyUrl = document.getElementById('btnCopyReadonlyUrl');
const btnToggleGlbPublic = document.getElementById('btnToggleGlbPublic');
const btnTogglePinsPublic= document.getElementById('btnTogglePinsPublic');
const btnHelpModel = document.getElementById('helpModel');
const btnHelpPins  = document.getElementById('helpPins');

/* Gate & FAB */
const signinGateWrap = document.getElementById('signinGateWrap');
const btnGateSignIn  = document.getElementById('btnGateSignIn');
const dockFab        = document.getElementById('dockFab');

/* 端末判定（モバイル寄り） */
const IS_MOBILE = window.matchMedia('(max-width: 640px), (pointer: coarse)').matches;

/* Driveの共有URLでもIDでもOK */
function extractDriveId(v=''){
  if(!v) return '';
  v = String(v).trim();
  const m1 = v.match(/https?:\/\/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]{10,})/);
  if (m1) return m1[1];
  const m2 = v.match(/https?:\/\/drive\.google\.com\/open\?id=([a-zA-Z0-9_-]{10,})/);
  if (m2) return m2[1];
  const m3 = v.match(/[a-zA-Z0-9_-]{10,}/);
  return m3 ? m3[0] : '';
}
['fileId','pinsId'].forEach(id=>{
  const el = document.getElementById(id);
  el.addEventListener('blur', ()=>{ el.value = extractDriveId(el.value) || ''; });
  el.addEventListener('paste', (e)=>{
    const txt = (e.clipboardData || window.clipboardData).getData('text');
    const id = extractDriveId(txt);
    if (id){ e.preventDefault(); el.value = id; }
  });
});
fileIdInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') btnLoad.click(); });

/* Dock 他（略：あなたの元コードのまま） */
const dock = document.getElementById('editorDock');
const materialsDockEl = document.getElementById('materialsDock');
const tabButtons = dock.querySelectorAll('.tabbtn');
const tabMove = document.getElementById('tab-move');
const tabMaterials = document.getElementById('tab-materials');
const tabCamera = document.getElementById('tab-camera');
const dockMoveToggle = document.getElementById('dockMoveToggle');
const dockCenterSelected = document.getElementById('dockCenterSelected');
const axisBtnX = document.getElementById('axisX');
const axisBtnY = document.getElementById('axisY');
const axisBtnZ = document.getElementById('axisZ');
const dockMin = document.getElementById('dockMin');
const projModeSel = document.getElementById('projMode');
const fovRange = document.getElementById('fov');
const fovVal = document.getElementById('fovVal');
const zoomRange = document.getElementById('zoom');
const zoomVal = document.getElementById('zoomVal');
const btnFrame = document.getElementById('btnFrame');
const bgModeSel = document.getElementById('bgMode');
const bgColorEl = document.getElementById('bgColor');
const touchModeEl = document.getElementById('touchMode');
const hintDesktop = document.getElementById('hintDesktop');
const hintTouch = document.getElementById('hintTouch');
const touchHelp = document.getElementById('touchHelp');
const modalRoot    = document.getElementById('modalRoot');

/* ===== State ===== */
let READ_ONLY = false;

const pinMap = new Map();
let selectedPinId = '';

let PINS = [];
let MATERIALS = {};
const materialList = [];
const materialCache = new Map();

let loadedPinsId = '';
let autosaveId   = '';
let loadedPinsName = '';
let autosaveName   = 'pins.json';

// Camera
let camera, cameraPersp, cameraOrtho, controls, gizmo, labelRenderer;
let cameraMode = 'persp';
let fitMaxDim = 1, fitDist = 3;

// Touch UI
let TOUCH_MODE = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
const DOCK_MIN_KEY = 'editorDock_min';

/* ===== Local mapping for autosave pins.json ===== */
const MAP_KEY = 'pinsMap_v1';
function loadMap(){ try{ return JSON.parse(localStorage.getItem(MAP_KEY)||'{}') }catch{ return {} } }
function saveMap(m){ localStorage.setItem(MAP_KEY, JSON.stringify(m)) }
function rememberAutosave(glbId, id){ const m=loadMap(); m[glbId]=id; saveMap(m); }

/* ===== gapi / GSI ===== */
function showSignInGate() {
  signinGateWrap.classList.remove('hidden');
  statusEl.textContent = 'サインインが必要です';
}
function hideSignInGate() {
  signinGateWrap.classList.add('hidden');
}

/* ★ loadGapi を「すでに読み込まれていれば待つだけ」に安全化 */
async function loadGapi() {
  if (window.gapiLoaded) return;
  await new Promise((resolve) => {
    if (window.gapi) return resolve();
    const t = setInterval(()=>{ if (window.gapi){ clearInterval(t); resolve(); } }, 30);
  });
  await new Promise((res)=> gapi.load('client', res));
  await gapi.client.init({ discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"] });
  window.gapiLoaded = true;
}
/* ★ 起動時に非同期でgapiを初期化（クリック前に終わっているのが理想） */
(async ()=>{ try{ await loadGapi(); }catch(e){ /* noop */ } })();

let accessToken = null;
let accessTokenExpiresAt = 0;
let tokenRefreshing = null;

/* ★ クリック“直下”専用：初回トークン取得（ポップアップブロック回避） */
function requestTokenInteractive(scopes = ALL_SCOPES) {
  return new Promise((resolve, reject) => {
    try {
      if (!window.google?.accounts?.oauth2) {
        reject(new Error('GSIがまだ読み込まれていません'));
        return;
      }
      const client = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: scopes,
        prompt: '',               // 初回 consent にしたい場合は 'consent' でもOK
        callback: (resp) => {
          if (!resp?.access_token) { reject(new Error('access_tokenなし')); return; }
          accessToken = resp.access_token;
          const ttlMs = Math.max(60_000, (Number(resp.expires_in) || 3600) * 1000);
          accessTokenExpiresAt = Date.now() + ttlMs;
          resolve(resp);
        }
      });
      // ここが重要：ユーザー操作（クリック）と同一ハンドラ内で即座に呼ぶ
      client.requestAccessToken();
    } catch (e) { reject(e); }
  });
}

/* 以後の更新/401リトライ用（ユーザー操作外でもサイレントに通ることが多い） */
async function ensureToken() {
  const now = Date.now();
  if (accessToken && accessTokenExpiresAt - 30_000 > now) return;
  if (tokenRefreshing) { await tokenRefreshing; return; }

  tokenRefreshing = new Promise((resolve, reject)=>{
    try{
      if (!window.google?.accounts?.oauth2) throw new Error('GSI未ロード');
      const client = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: ALL_SCOPES,
        prompt: '',
        callback: (resp)=>{
          try{
            if (!resp?.access_token) throw new Error('トークンが返らない');
            accessToken = resp.access_token;
            const ttl = (resp.expires_in ? Number(resp.expires_in) : 3600) * 1000;
            accessTokenExpiresAt = Date.now() + Math.max(60_000, ttl);
            resolve();
          }catch(e){ reject(e); }
        }
      });
      client.requestAccessToken();
    }catch(e){ reject(e); }
  });

  try{ await tokenRefreshing; } finally { tokenRefreshing = null; }
}

/* 未サインインならゲートを出して中断。すでに有効なら true */
async function ensureSignedInIfNeeded() {
  if (accessToken && (accessTokenExpiresAt - 30_000 > Date.now())) {
    scopeWarnEl.style.display = 'none';
    statusEl.textContent = 'サインイン済み';
    return true;
  }
  statusEl.textContent = '未サインイン（公開ファイルのみ閲覧可）';
  showSignInGate();
  return false;
}

/* ===== Drive helpers ===== */
const DRIVE_BASE   = 'https://www.googleapis.com/drive/v3';
const UPLOAD_BASE  = 'https://www.googleapis.com/upload/drive/v3';
async function fetchWithRetry(url, init={}, {expect='json'} = {}) {
  const doFetch = async () => {
    const headers = new Headers(init.headers || {});
    if (accessToken) headers.set('Authorization', `Bearer ${accessToken}`);
    return fetch(url, { ...init, headers });
  };
  let res = await doFetch();
  if (res.status === 401) {
    try { await ensureToken(); res = await doFetch(); } catch {}
  }
  if (!res.ok) {
    let body = ''; try { body = await res.text(); } catch {}
    throw new Error(`Drive fetch ${res.status}: ${body || url}`);
  }
  if (expect === 'blob')  return res.blob();
  if (expect === 'text')  return res.text();
  if (expect === 'raw')   return res;
  return res.json();
}
async function driveFetchBinary(fileId) {
  const url = `${DRIVE_BASE}/files/${fileId}?alt=media&supportsAllDrives=true`;
  return fetchWithRetry(url, {}, { expect:'blob' });
}
async function driveGetMetadata(fileId, fields='id,name,parents,mimeType,modifiedTime') {
  const url = `${DRIVE_BASE}/files/${fileId}?fields=${encodeURIComponent(fields)}&supportsAllDrives=true`;
  return fetchWithRetry(url);
}
async function driveCreateFile({ name, mimeType, parents, dataBlob }) {
  const boundary = '-------314159265358979323846';
  const meta = { name, mimeType, parents };
  const body = new Blob([
    `--${boundary}\r\n`,
    'Content-Type: application/json; charset=UTF-8\r\n\r\n',
    JSON.stringify(meta) + '\r\n',
    `--${boundary}\r\n`,
    `Content-Type: ${mimeType || 'application/octet-stream'}\r\n\r\n`,
    dataBlob,
    `\r\n--${boundary}--\r\n`
  ], { type: 'multipart/related; boundary=' + boundary });
  const url = `${UPLOAD_BASE}/files?uploadType=multipart&supportsAllDrives=true`;
  return fetchWithRetry(url, { method:'POST', headers:{ 'Content-Type': body.type }, body });
}
async function driveUpdateFile({ fileId, name, mimeType, dataBlob }) {
  const boundary = '-------314159265358979323846';
  const meta = { name };
  const body = new Blob([
    `--${boundary}\r\n`,
    'Content-Type: application/json; charset=UTF-8\r\n\r\n',
    JSON.stringify(meta) + '\r\n',
    `--${boundary}\r\n`,
    `Content-Type: ${mimeType || 'application/octet-stream'}\r\n\r\n`,
    dataBlob,
    `\r\n--${boundary}--\r\n`
  ], { type: 'multipart/related; boundary=' + boundary });
  const url = `${UPLOAD_BASE}/files/${fileId}?uploadType=multipart&supportsAllDrives=true`;
  return fetchWithRetry(url, { method:'PATCH', headers:{ 'Content-Type': body.type }, body });
}
async function driveListFiles({ q, orderBy='modifiedTime desc', pageSize=100 }) {
  const fields = 'files(id,name,modifiedTime,parents,iconLink,thumbnailLink,mimeType),nextPageToken';
  const url = `${DRIVE_BASE}/files?q=${encodeURIComponent(q)}&pageSize=${pageSize}&fields=${encodeURIComponent(fields)}&orderBy=${encodeURIComponent(orderBy)}&supportsAllDrives=true&includeItemsFromAllDrives=true`;
  return fetchWithRetry(url);
}
async function driveGetPermissions(fileId) {
  const url = `${DRIVE_BASE}/files/${fileId}/permissions?supportsAllDrives=true&fields=permissions(id,type,role)`;
  return fetchWithRetry(url);
}
async function driveSetPublic(fileId, makePublic) {
  const base = `${DRIVE_BASE}/files/${fileId}/permissions?supportsAllDrives=true`;
  if (makePublic) {
    await fetchWithRetry(base, { method:'POST', headers:{ 'Content-Type': 'application/json' }, body: JSON.stringify({ role:'reader', type:'anyone', allowFileDiscovery:false }) }, { expect:'json' });
  } else {
    const { permissions = [] } = await driveGetPermissions(fileId);
    const any = permissions.find(p => p.type === 'anyone');
    if (any) {
      const delUrl = `${DRIVE_BASE}/files/${fileId}/permissions/${any.id}?supportsAllDrives=true`;
      await fetchWithRetry(delUrl, { method:'DELETE' }, { expect: 'raw' });
    }
  }
}
async function driveIsPublic(fileId) {
  const { permissions = [] } = await driveGetPermissions(fileId);
  return !!permissions.find(p => p.type === 'anyone' && p.role === 'reader');
}

/* ===== Three.js ===== */
import * as THREE from 'https://esm.sh/three@0.152.2';
import { OrbitControls } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://esm.sh/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { CSS2DRenderer as ThreeCSS2DRenderer } from 'https://esm.sh/three@0.152.2/examples/jsm/renderers/CSS2DRenderer.js';
import { TransformControls as ThreeTransformControls } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/TransformControls.js';

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.max(1, window.devicePixelRatio || 1));
renderer.setSize(view.clientWidth, view.clientHeight);
const scene = new THREE.Scene();
scene.background = null;

function makePerspective(){
  const aspect = view.clientWidth / view.clientHeight;
  const c = new THREE.PerspectiveCamera(60, aspect, 0.01, 2000);
  return c;
}
function makeOrtho(frustumHeight){
  const aspect = view.clientWidth / view.clientHeight;
  const h = frustumHeight || (fitMaxDim*2.2);
  const w = h * aspect;
  const c = new THREE.OrthographicCamera(-w/2, w/2, h/2, -h/2, 0.01, 2000);
  c.zoom = 1; c.updateProjectionMatrix(); return c;
}

cameraPersp = makePerspective();
camera = cameraPersp;
camera.position.set(0, 1, 3);

controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = true;
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
controls.target.set(0, 0, 0);

scene.add(new THREE.AmbientLight(0xffffff, 1.0));
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(3, 5, 2); scene.add(dir);

labelRenderer = new ThreeCSS2DRenderer();
labelRenderer.setSize(view.clientWidth, view.clientHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.top = '0';
labelRenderer.domElement.style.left = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
view.appendChild(labelRenderer.domElement);

function updateCameraAspect(){
  const aspect = view.clientWidth / view.clientHeight;
  if (cameraMode==='persp'){
    camera.aspect = aspect;
  } else {
    const h = fitMaxDim*2.2, w = h * aspect;
    camera.left = -w/2; camera.right = w/2; camera.top = h/2; camera.bottom = -h/2;
  }
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', ()=>{
  renderer.setSize(view.clientWidth, view.clientHeight);
  labelRenderer.setSize(view.clientWidth, view.clientHeight);
  updateCameraAspect();
});

/* ===== 背景 ===== */
function applyBackgroundMode(mode){
  const col = mode==='light' ? '#f2f2f2' : '#222';
  view.style.background = col;
  renderer.setClearAlpha(0);
  scene.background = null;
}
function applyBackgroundColor(hex){
  if (!hex) return;
  view.style.background = hex;
  renderer.setClearAlpha(0);
  scene.background = null;
}

/* ===== リーダーライン ===== */
function updateLeaderLines(){
  for (const [id, rec] of pinMap){
    if (!rec.floatDom || !rec.lineEl) continue;
    const world = rec.node.getWorldPosition(new THREE.Vector3());
    const v = world.clone().project(camera);
    const w=view.clientWidth, h=view.clientHeight;
    const sx = (v.x * 0.5 + 0.5) * w;
    const sy = (-v.y * 0.5 + 0.5) * h;
    const cr = rec.floatDom.getBoundingClientRect();
    const vr = view.getBoundingClientRect();
    const cx = (cr.left - vr.left) + Math.min(16, cr.width*0.2);
    const cy = (cr.top  - vr.top ) + Math.min(16, cr.height*0.2);
    rec.lineEl.setAttribute('x1', sx.toFixed(1));
    rec.lineEl.setAttribute('y1', sy.toFixed(1));
    rec.lineEl.setAttribute('x2', cx.toFixed(1));
    rec.lineEl.setAttribute('y2', cy.toFixed(1));
  }
}
function tick(){
  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
  updateLeaderLines();
  requestAnimationFrame(tick);
}
tick();

/* ===== カメラ補間 ===== */
function animateCameraTo({ fromPos, toPos, fromTarget, toTarget, duration=400, ease=(t)=>t }){
  const start = performance.now();
  function step(){
    const now = performance.now();
    const t = Math.min(1, (now - start) / duration);
    const k = ease(t);
    camera.position.lerpVectors(fromPos, toPos, k);
    controls.target.lerpVectors(fromTarget, toTarget, k);
    camera.updateProjectionMatrix?.();
    controls.update();
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* ===== GLB 読み込み ===== */
let gltfRoot = null;
const pinsGroup = new THREE.Group(); scene.add(pinsGroup);

function frameToObject(){
  if (!gltfRoot) return;
  const box = new THREE.Box3().setFromObject(gltfRoot);
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  gltfRoot.position.sub(center);
  fitMaxDim = Math.max(size.x, size.y, size.z) || 1;
  fitDist = fitMaxDim * 1.8 / Math.tan(THREE.MathUtils.degToRad((camera.fov||60)/2));
  camera.position.set(0, fitMaxDim*0.6, fitDist);
  controls.target.set(0, 0, 0); controls.update();
  cameraOrtho = makeOrtho(fitMaxDim*2.2);
  cameraOrtho.position.copy(camera.position);
  cameraOrtho.lookAt(controls.target);
  updateCameraAspect();
}
async function loadGLBFromDrive(fileId){
  const blob = await driveFetchBinary(fileId);
  const url  = URL.createObjectURL(blob);
  if (gltfRoot) {
    scene.remove(gltfRoot);
    gltfRoot.traverse(o=>{
      if(o.geometry) o.geometry.dispose();
      if(o.material){
        const mats = Array.isArray(o.material)? o.material : [o.material];
        mats.forEach(m=>{
          if (m.map && m.map.dispose) m.map.dispose();
          if (m.dispose) m.dispose();
        });
      }
    });
    gltfRoot = null;
    materialList.length = 0;
    materialCache.clear();
    materialsDockEl.innerHTML = '';
  }
  const loader = new GLTFLoader();
  await new Promise((resolve, reject)=>{
    loader.load(url, (gltf)=>{
      gltfRoot = gltf.scene; scene.add(gltfRoot);
      frameToObject();
      collectMaterials(gltfRoot);
      buildMaterialsUI(materialsDockEl);
      URL.revokeObjectURL(url);
      resolve();
    }, undefined, reject);
  });
}

/* ===== ピン（略。元コードのまま） ===== */
const safePos = a => (Array.isArray(a)&&a.length>=3)?a.map(n=>Number(n)||0):[0,0,0];

function pinColorOf(pin){ return (pin && pin.color) ? String(pin.color) : '#e33'; }
function makePinSprite(color='#e33'){
  const size = 64, cvs = document.createElement('canvas'); cvs.width=cvs.height=size;
  const ctx = cvs.getContext('2d');
  ctx.beginPath(); ctx.arc(size/2,size/2,size*0.28,0,Math.PI*2);
  ctx.fillStyle='#fff'; ctx.fill();
  ctx.beginPath(); ctx.arc(size/2,size/2,size*0.22,0,Math.PI*2);
  ctx.fillStyle=color; ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2; ctx.stroke();
  const tex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({ map: tex, depthTest: true, depthWrite: false, transparent: true });
  const spr = new THREE.Sprite(mat); spr.scale.set(0.022,0.022,0.022); return spr;}
function updatePinSpriteColor(id){
  const rec = pinMap.get(id); if (!rec) return;
  const pin = PINS.find(p=>p.id===id); const col = pinColorOf(pin);
  const tex = makePinSprite(col).material.map;
  rec.sprite.material.map.dispose?.();
  rec.sprite.material.map = tex;
  rec.sprite.material.needsUpdate = true;
}

/* ……（中略：ピンUI/ポップアップ/ギズモ/ドック/カメラ/タッチ/マテリアル/Undo/保存/ピッカー/共有 などは元コードのとおり） …… */
/* 以降はあなたの提供コードを踏襲。差分がある箇所のみ下で置換しています。 */

/* ===== 共有エラー診断 / 共有UI など（元コードと同じ） ===== */
async function explainShareError(fileId, err){
  console.warn('share-toggle failed', err);
  try{
    const meta = await driveGetMetadata(
      fileId,
      'id,name,owners,driveId,capabilities(canShare,canEdit,canCopy,canComment),permissions'
    );
    const caps = meta.capabilities||{};
    const onDrive = !!meta.driveId;
    let reasons = [];
    if (!caps.canShare) reasons.push('このファイルの共有設定は変更できない（capabilities.canShare=false）');
    if (!caps.canEdit)  reasons.push('あなたは編集権限がない可能性（capabilities.canEdit=false）');
    if (onDrive)        reasons.push('共有ドライブ：組織ポリシー制限の可能性');
    if (!reasons.length) reasons.push('スコープ不足か管理者ポリシーの可能性');
    alert(
      `共有設定の変更に失敗しました。\n`+
      `ファイル名: ${meta.name||'(不明)'}\n\n`+
      `診断:\n - `+reasons.join('\n - ')+"\n\n"+
      `ヒント:\n1) 共有ドライブは役割が必要\n2) 組織でリンク共有禁止の可能性\n3) DriveのUIで手動変更も試してください`
    );
  }catch(_){
    alert('共有設定の変更に失敗しました。DriveのUIで共有設定をご確認ください。');
  }
}
function copyText(text, okMsg='コピーしました'){
  if (navigator.clipboard && window.isSecureContext){
    navigator.clipboard.writeText(text).then(()=> alert(okMsg)).catch(()=> fallbackCopy(text, okMsg));
  } else { fallbackCopy(text, okMsg); }
}
function fallbackCopy(text, okMsg){
  const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
  ta.select(); try{ document.execCommand('copy'); alert(okMsg); } finally{ document.body.removeChild(ta); }
}

/* ★ サインインゲート：クリック直下で requestAccessToken() を発火（awaitで前段を跨がない） */
btnGateSignIn?.addEventListener('click', async ()=>{
  try{
    statusEl.textContent='サインイン中…';
    // クリックの同一ハンドラ内で要求
    await requestTokenInteractive(ALL_SCOPES);
    // gapi は事前にasync初期化されるが、未完でも後から使えるので待たない
    statusEl.textContent='サインイン完了';
    hideSignInGate();
    scopeWarnEl.style.display = 'none';
    if (extractDriveId(fileIdInput.value)) { btnLoad.click(); }
  }catch(e){
    console.error(e);
    statusEl.textContent='サインイン失敗';
    alert('サインインに失敗しました。別ブラウザやSafariのポップアップ許可をご確認ください。');
  }
});

/* ===== Header actions ===== */
/* ★ 「Googleにサインイン」：こちらもクリック直下で要求 */
btnAuth.onclick = async ()=>{
  try{
    statusEl.textContent='サインイン中…';
    await requestTokenInteractive(ALL_SCOPES);
    statusEl.textContent='サインイン完了';
    hideSignInGate();
    scopeWarnEl.style.display='none';
  }catch(e){
    console.error(e);
    alert('Googleサインインに失敗しました。設定/ポップアップ/拡張のブロックをご確認ください。');
    statusEl.textContent='サインイン失敗';
  }
};

btnLoad.onclick = async ()=>{
  const glbId = extractDriveId(fileIdInput.value);
  const manualPinsId = extractDriveId(pinsIdInput.value);
  if(!glbId){ alert('GLBの fileId / 共有リンクを入力してください'); return; }

  // 未サインインなら中央ゲートを出して中断
  const ok = await ensureSignedInIfNeeded();
  if (!ok) return;

  try{
    statusEl.textContent='GLB読込中…';
    await loadGLBFromDrive(glbId);

    /* （以下、あなたの元コードの読込・pins適用・UI同期ロジックをそのまま維持） */
    /* …………………………………………………………………………………………………………………………… */

    // 読み込み時の状態初期化
    PINS=[]; MATERIALS={}; redrawPins(); lastSavedJson='';
    loadedPinsId=''; loadedPinsName=''; autosaveId=''; autosaveName='pins.json';

    // オートセーブ候補
    if (!READ_ONLY && accessToken){ await ensureAutosaveTarget(glbId); }

    // pins.json の候補（明示指定→既存オートセーブ）
    let targetPinsId = manualPinsId || autosaveId || '';

    if (targetPinsId){
      statusEl.textContent='pins 読込中…';
      const pblob = await driveFetchBinary(targetPinsId);
      const text  = await pblob.text();
      let data=null; try{ data=JSON.parse(text); }catch{}
      if(Array.isArray(data)){
        PINS=data.map(p=>({...p, position:safePos(p.position), color:p.color||'#e33'}));
        MATERIALS={};
      } else if(data && typeof data==='object'){
        PINS = Array.isArray(data.pins)? data.pins.map(p=>({...p, position:safePos(p.position), color:p.color||'#e33'})) : [];
        MATERIALS = (data.materials && typeof data.materials==='object') ? data.materials : {};
      }
      loadedPinsId = targetPinsId;
      if (accessToken){ try{ const m=await driveGetMetadata(loadedPinsId); loadedPinsName=m.name||''; }catch{} }
      redrawPins();
      for (const {name, material} of materialList){ const cfg = MATERIALS[name]; if (cfg) applyMaterialConfig(material, cfg); }
      lastSavedJson = JSON.stringify({pins:PINS,materials:MATERIALS});
      setSaveStatus('ok','読み込み完了');
    } else {
      lastSavedJson = JSON.stringify({pins:PINS,materials:MATERIALS});
      setSaveStatus('muted','新規セッション');
    }

    buildMaterialsUI(materialsDockEl);
    resetHistoryBaseline();
    syncDockMoveToggle();
    axisBtnX.classList.toggle('toggled', gizmo.showX);
    axisBtnY.classList.toggle('toggled', gizmo.showY);
    axisBtnZ.classList.toggle('toggled', gizmo.showZ);
    updatePinsInfo();
    refreshShareButtons();

    // カメラ/背景UIの同期
    projModeSel.value = cameraMode;
    fovRange.value = Math.round(camera.fov||60);
    fovVal.textContent = (camera.fov||60).toFixed(0)+'°';
    zoomRange.value = (camera.zoom||1);
    zoomVal.textContent = (camera.zoom||1).toFixed(2);
    syncBgUI();
  }catch(e){
    console.error(e);
    alert('読み込みに失敗しました。権限と fileId を確認してください。');
    statusEl.textContent='エラー';
  }
};

/* （保存・ピッカー・共有ボタン等は元のまま） */

/* ===== READ-ONLY mode (URL ?mode=read) ===== */
function applyReadOnlyUI(){
  if (!READ_ONLY) return;
  btnSavePins.style.display = 'none';
  btnAddPin.style.display = 'none';
  pillMove.style.display = 'none';
  pillAutosave.style.display = 'none';
  dock.style.display = 'none';
  dockFab.style.display = 'none';
}

(function bootFromUrl(){
  const sp = new URLSearchParams(location.search);
  const fRaw = sp.get('fileId') || sp.get('glb') || sp.get('model') || sp.get('file')  || sp.get('url')  || '';
  const pRaw = sp.get('pinsId') || sp.get('pins') || '';
  const fId = fRaw ? extractDriveId(fRaw) : '';
  const pId = pRaw ? extractDriveId(pRaw) : '';
  if (fId) fileIdInput.value = fId;
  if (pId) pinsIdInput.value = pId;
  const mode = sp.get('mode');
  READ_ONLY = (mode === 'read');
  TOUCH_MODE = TOUCH_MODE || (sp.get('touch') === '1');
  applyTouchUI();
  applyReadOnlyUI();

  if (fId) {
    (async ()=>{
      const ok = await ensureSignedInIfNeeded();
      if (!ok) return;   // ゲート表示 → サインイン完了まで待機
      btnLoad.click();   // サインイン済みなら自動ロード
    })();
  }
})();

/* ===== 画像拡大ビュー / D&D / 初期背景（元コードのまま） ===== */
function openImageViewer(src){
  const ov = document.createElement('div'); ov.className='zoom-overlay';
  const img = document.createElement('img'); img.className='zoom-img'; img.src = src;
  const btn = document.createElement('button'); btn.className='zoom-close'; btn.textContent='閉じる';
  btn.onclick = ()=> document.body.removeChild(ov);
  ov.appendChild(img); document.body.appendChild(ov); document.body.appendChild(btn);

  let scale = 1, ox = 0, oy = 0, dragging=false, sx=0, sy=0, tx=0, ty=0;
  function apply(){ img.style.transform = `translate(${ox}px, ${oy}px) scale(${scale})`; }
  ov.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = img.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    const ds = (e.deltaY<0)? 1.1 : 0.9;
    const newScale = Math.min(8, Math.max(0.2, scale * ds));
    ox = e.clientX - (px * newScale/scale + rect.left - ox);
    oy = e.clientY - (py * newScale/scale + rect.top  - oy);
    scale = newScale; apply();
  }, {passive:false});
  ov.addEventListener('mousedown', (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY; tx=ox; ty=oy; ov.style.cursor='grabbing'; });
  window.addEventListener('mousemove', (e)=>{ if(!dragging) return; ox = tx + (e.clientX - sx); oy = ty + (e.clientY - sy); apply(); });
  window.addEventListener('mouseup', ()=>{ dragging=false; ov.style.cursor='grab'; });
  ov.addEventListener('dblclick', ()=>{ scale=1; ox=oy=0; apply(); });
  ov.addEventListener('click', (e)=>{ if (e.target===ov) { document.body.removeChild(ov); btn.remove(); } });
}
document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
document.addEventListener('drop', async (e)=>{
  if (READ_ONLY) return;
  e.preventDefault();
  const f = e.dataTransfer.files?.[0];
  if (!f || !f.type.startsWith('image/')) return;
  const pin = PINS.find(p=>p.id===selectedPinId) || PINS[PINS.length-1];
  if (!pin){ alert('先にピンを1つ作成してください'); return; }
  await uploadAndAttachImage(f, pin);
});

/* ==== 初期背景反映 ==== */
applyBackgroundMode('dark');
applyBackgroundColor('#222222');

</script>
</body>
</html>
